<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"shadiaoyu.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://shadiaoyu.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://shadiaoyu.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://shadiaoyu.github.io/2024/08/29/%E5%AE%9E%E4%B9%A0%E5%86%85%E5%AE%B9%E6%8F%8F%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/29/%E5%AE%9E%E4%B9%A0%E5%86%85%E5%AE%B9%E6%8F%8F%E8%BF%B0/" class="post-title-link" itemprop="url">实习内容描述</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-08-29 14:29:09" itemprop="dateCreated datePublished" datetime="2024-08-29T14:29:09+08:00">2024-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-09-01 16:47:56" itemprop="dateModified" datetime="2024-09-01T16:47:56+08:00">2024-09-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Prometheus告警全技术流程："><a href="#Prometheus告警全技术流程：" class="headerlink" title="Prometheus告警全技术流程："></a>Prometheus告警全技术流程：</h2><p>使用telegraf进行指标采集。原因：Prometheus官方有许多exporter，但是每个服务都需要一个exporter，项目多了管理会非常麻烦，所以使用了influxdb旗下的telegraf作为客户端数据收集器。</p>
<p>具体监控项有nginx，mysql，es，redis，mq等。telegraf具体配置内容都是参考网上的。</p>
<h2 id="webhook-Prehandler告警推送"><a href="#webhook-Prehandler告警推送" class="headerlink" title="webhook-Prehandler告警推送:"></a>webhook-Prehandler告警推送:</h2><p>具体的推送方式分为短信推送、邮件推送、钉钉群聊机器人推送。</p>
<p><strong>短信推送和邮件推送负责推送error级别的告警，钉钉机器人负责推送error和warning级别的告警。</strong></p>
<p>由于AlertManager推送过来的消息有可能很大（钉钉机器人每次接受的请求最大不能超过2KB，否则报错），因此，要么对消息内容进行压缩，要么对发过来的json进行分割，当然分割后不能破坏原有的结构。这些是后话了，随后再写。</p>
<p>引入RabbitMq的原因之一，企业微信或钉钉群聊机器人有调用频率限制，比如钉钉，每个机器人每分钟最高处理20条消息。使用消息队列可以做流量削峰。</p>
<h3 id="短信-amp-邮件推送："><a href="#短信-amp-邮件推送：" class="headerlink" title="短信&amp;邮件推送："></a>短信&amp;邮件推送：</h3><p>引入mq后，虽然可以实现消息发送，但是还比较脆弱，例如：mq突然崩了、邮件发送失败了、重启mq服务出现消息重复消费，这时就需要做一些处理。</p>
<p>短信以及邮件需要保证消息不丢失，这里采用了消息队列保证消息一定会被消费。</p>
<p>同时短信内容不宜过长，因此用短信推送的内容需要做压缩处理。还可能涉及到一些大JSON，这也需要做分片处理。</p>
<p><strong>比较核心的一些类：</strong></p>
<p>SendMailUtil：发送邮件工具类；ProduceServiceImpl：生产者，发送消息；ConsumerMailService：消费者，消费消息，发送邮件。</p>
<p><strong>rabbitMq和mail的一些核心配置：</strong></p>
<p>rabbitMq：主要是开启confirm回调、开启returnedMessage回调、设置手动确认。</p>
<ul>
<li>开启confirm回调的效果就是，当生产者向mq发送消息时，如果消息成功到达了交换器（Exchange），rabbitMq会异步返回一个ack给生产者，表示消息是否成功到达了exchange。（注意：开启confirm回调仅能确认消息是否到达exchange，并不确认消息是否到达queue。因此需要下面的配置）。</li>
<li>开启returnedMessage回调的效果是，如果消息成功到达exchange，但是没有到达queue时，会触发rabbitMq返回机制，在返回机制中，消息会退回给生产者（或丢弃，这由是否配置mandatory&#x3D;true来决定的）。这个机制适用于对消息可靠性高的场景。</li>
</ul>
<h3 id="对失败消息进行处理，保证消息能100-发送出去"><a href="#对失败消息进行处理，保证消息能100-发送出去" class="headerlink" title="对失败消息进行处理，保证消息能100%发送出去"></a>对失败消息进行处理，保证消息能100%发送出去</h3><p><strong>引入数据库来记录消息的发送&#x2F;消费情况。</strong></p>
<p>新建一张表，这张表的字段包括消息<strong>id、消息体（json格式）、exchange交换机、routing_key路由键、status状态（投递中、投递成功、投递失败、已消费）、重试次数、下一次重试时间、创建时间、更新时间。</strong></p>
<p><strong>具体业务流程就是：</strong></p>
<ul>
<li>改造发送方：消息对象在发送到mq之前，先写入数据库一条记录（默认状态是投递中），随后往mq中投递，如果收到ack就更新状态（投递成功 or 失败）。</li>
<li>改造消费者，<strong>每次消费的时候，从数据库中查询，如果消息已经被消费，不用再重复发送数据。</strong>这样即可保证，如果rabbitMQ服务器，即使重启之后重新推送消息，通过数据库进行判断，也不会重复消费而发生业务异常。</li>
</ul>
<p><strong>利用定时任务对消息投递失败进行补偿：</strong></p>
<p>当rabbitMq服务器挂掉之后，生成者就无法正常进行投递数据，此时因为消息已经被记录到数据库，因此利用定时任务查询出没有投递成功的消息，进行补偿投递（这里设置为每10s执行一次定时任务）。</p>
<h2 id="消息预处理"><a href="#消息预处理" class="headerlink" title="消息预处理"></a>消息预处理</h2><p>预处理的工作包括，时间格式的转变、vm_uuid到ip的转变、消息压缩、大JSON拆分。重点的功能在后三个。</p>
<p><strong>vm_uuid转换为ip：</strong></p>
<p>为什么要有这么一个功能，是因为告警请求中的labels中只有vm_uuid和宿主机的ip，这些内容对于定位服务没有大的帮助。</p>
<p>具体实现：首先运维人员抓取vm_uuid和实例ip的映射关系，把他们整理成csv文件。然后用Java的CSVReader去做处理，这里就是把这些映射关系全部放到一个全局的Map中去，这样避免了多次IO从而影响响应时间。</p>
<p><strong>消息压缩：</strong></p>
<p>比如SMS短信发送，短信内容限制不能超过500字，并且发送频率也有限制，因此短信发送的都是严重级别的告警信息。并且还需要进行压缩。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://shadiaoyu.github.io/2024/06/19/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/19/%E8%AE%A1%E7%BB%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">计组学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-06-19 16:23:41" itemprop="dateCreated datePublished" datetime="2024-06-19T16:23:41+08:00">2024-06-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-06-26 16:30:06" itemprop="dateModified" datetime="2024-06-26T16:30:06+08:00">2024-06-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、计算机系统概述"><a href="#一、计算机系统概述" class="headerlink" title="一、计算机系统概述"></a>一、计算机系统概述</h1><h2 id="1-1-计算机发展历程"><a href="#1-1-计算机发展历程" class="headerlink" title="1.1 计算机发展历程"></a>1.1 计算机发展历程</h2><ol>
<li>硬件发展历程：第一代电子管、第二代晶体管、第三代集成电路、第四代超大规模集成电路。</li>
<li><strong>机器字长：</strong>指计算机进行一次整数运算所能处理的二进制数据的位数。</li>
<li>软件发展历程：机器语言 —-&gt;汇编语言 ——&gt;高级语言</li>
</ol>
<h2 id="1-2-计算机系统组成"><a href="#1-2-计算机系统组成" class="headerlink" title="1.2 计算机系统组成"></a>1.2 计算机系统组成</h2><h3 id="1-2-1-冯诺依曼机的特点"><a href="#1-2-1-冯诺依曼机的特点" class="headerlink" title="1.2.1 冯诺依曼机的特点"></a>1.2.1 冯诺依曼机的特点</h3><ul>
<li>采用存储程序的工作方式；</li>
<li>硬件系统由运算器、存储器、控制器、输入设备和输出设备组成（以运算器为中心，现代计算机结构以存储器为中心）；</li>
<li>指令和数据同等地位，保存在存储器中；</li>
<li>指令和数据均由二进制代码表示；</li>
<li>指令由操作码和地址码组成。</li>
</ul>
<h3 id="1-2-2-计算机的各个功能部件："><a href="#1-2-2-计算机的各个功能部件：" class="headerlink" title="1.2.2 计算机的各个功能部件："></a>1.2.2 计算机的各个功能部件：</h3><p>（1）<strong>输入设备&#x2F;输出设备；</strong></p>
<p>（2） <strong>存储器：</strong>存储器分为<strong>主存（理解为内存）和辅存（理解为硬盘）</strong>。存储器包括<strong>存储体</strong>，以及两个寄存器：<strong>MAR存储地址寄存器、MDR存储数据寄存器</strong>；</p>
<ul>
<li><strong>MAR用于寻址</strong>，其<strong>位数</strong>反映了<strong>存储单元的数量</strong>；</li>
<li><strong>MDR用于暂存要读&#x2F;写的数据</strong>。其<strong>位数 &#x3D; 存储字长</strong>；</li>
<li>需要了解概念：<strong>存储元、存储单元、存储字、存储字长、地址；</strong></li>
</ul>
<p>（3） <strong>运算器：</strong>用于<strong>进行算术运算和逻辑运算</strong>。其包括如下部分：</p>
<ul>
<li><strong>算数逻辑单元ALU（核心）：运算器的核心，</strong>用电路实现各种算数运算、逻辑运算；</li>
<li><strong>累加器ACC：</strong>存放操作数、运算的结果；</li>
<li><strong>乘商寄存器MQ：</strong>进行乘除的时候用得到；</li>
<li><strong>通用寄存器X：</strong>通用寄存器，存放操作数；</li>
</ul>
<p>（4） <strong>控制器：</strong>计算机的<strong>指挥中心</strong>，由<strong>程序计数器PC、指令寄存器IR、控制单元CU组成</strong>：</p>
<ul>
<li><strong>程序计数器PC：</strong> 存放下一条指令的地址；</li>
<li><strong>指令寄存器IR：</strong>存放当前执行的指令；</li>
<li><strong>控制单元CU（核心）：</strong>分析指令，给出控制信号；</li>
</ul>
<p>简单概括，<strong>计算机运行指令的工作过程如下：</strong></p>
<ul>
<li>初始：把指令、数据存入内存，PC指向第一条指令；</li>
<li>从主存中取指令放入指令寄存器IR，PC自动加一、控制单元CU分析指令、CU指挥其他部件执行指令。</li>
</ul>
<h2 id="1-3-计算机的性能指标（本章重点）"><a href="#1-3-计算机的性能指标（本章重点）" class="headerlink" title="1.3 计算机的性能指标（本章重点）"></a>1.3 计算机的性能指标（本章重点）</h2><p>（1）<strong>机器字长：</strong>“XX位机器”中的位数就代表机器字长，这里首先说明一下<strong>字长</strong>，字长就是<strong>计算机进行一次整数运算所能处理的二进制位数</strong>，其反映了计算机处理信息的能力。也有必要说明<strong>字，字长，机器字长，指令字长，存储字长之间的关系</strong>，它们的区别和联系如下：</p>
<ul>
<li><strong>字和字长的概念不同</strong>。<strong>字</strong>用来表示被处理信息的单位，<strong>用来衡量数据类型的宽度</strong>，如<strong>x86中一个字定义为16位</strong>；</li>
<li>字长也指CPU内部用于整数运算的数据通路的宽度，因此<strong>字长等于CPU内部用于整数运算的运算器位数和通用寄存器宽度</strong>；</li>
<li><strong>指令字长：</strong>一个指令字中包含的二进制位数；</li>
<li><strong>存储字长：</strong>一个存储单元存储的二进制位数；</li>
<li><strong>字长必须是字节的整数倍</strong>；</li>
</ul>
<p>（2）<strong>数据通路带宽：</strong>其实就是数据总线宽度。</p>
<p>（3）<strong>主存容量：</strong>指主存能存信息的最大容量，用<strong>字节</strong>或<strong>字长*字数</strong>来表示。</p>
<p>（4）<strong>吞吐量：</strong>单位时间内处理请求的数量。</p>
<p>（5）<strong>响应时间：</strong>用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间。</p>
<p>（6）<strong>时钟周期：</strong>机器内部主时钟脉冲信号的宽度，它是CPU工作的最小时间单位。</p>
<p>（7） <strong>主频：</strong>主时钟的频率，即<strong>时钟周期的倒数</strong>。</p>
<p>（8）<strong>CPI （cycle per Instruction）：</strong>执行一条指令所需的时钟周期数。不同指令的时钟周期数可能不同，因此对于一个程序或一台机器来说，其CPI指所有指令的平均周期数，是一个平均值。</p>
<p>（9）<strong>IPS （instruction per second）：</strong>即每秒可执行的指令数。<strong>IPS &#x3D; 主频&#x2F;CPI</strong>。</p>
<ul>
<li><strong>MIPS：</strong>每秒可执行几百万条指令数。 <strong>MIPS &#x3D; IPS &#x2F; 10^6</strong> 。</li>
<li><strong>MFLOPS：</strong>每秒执行几百万次浮点数操作。</li>
</ul>
<p>（10）<strong>CPU执行时间</strong>：指运行一个程序所花费的时间。 其等于：<strong>（程序所需指令数 * CPI ）&#x2F; 主频</strong></p>
<ul>
<li><strong>CPU的性能取决于三个要素：主频、CPI、指令条数。</strong></li>
</ul>
<p>（11）<strong>基准程序：</strong>专门用于性能评价的一组程序。</p>
<ul>
<li>基准程序中的语句存在频度的差异，因此<strong>运行结果并不能完全说明问题</strong>。</li>
</ul>
<h1 id="二、数据的表示和运算"><a href="#二、数据的表示和运算" class="headerlink" title="二、数据的表示和运算"></a>二、数据的表示和运算</h1><h2 id="2-1-1-无符号整数的表示和运算"><a href="#2-1-1-无符号整数的表示和运算" class="headerlink" title="2.1.1 无符号整数的表示和运算"></a>2.1.1 无符号整数的表示和运算</h2><p>（1）计算机如何做无符号整数的减法：</p>
<ul>
<li>被减数不变，减数 全部位 按位取反、末位加一，减法变加法（取补码）；</li>
<li>从最低位开始，按位相加，并向更高位进位。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://shadiaoyu.github.io/2024/05/08/api%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D-%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/08/api%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D-%E5%85%AB%E8%82%A1/" class="post-title-link" itemprop="url">api开放平台-项目介绍&八股</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-08 21:57:42" itemprop="dateCreated datePublished" datetime="2024-05-08T21:57:42+08:00">2024-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-26 17:07:16" itemprop="dateModified" datetime="2024-08-26T17:07:16+08:00">2024-08-26</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>项目介绍：</p>
<p>项目架构：</p>
<h1 id="项目点："><a href="#项目点：" class="headerlink" title="项目点："></a>项目点：</h1><h2 id="Sa-Token鉴权。"><a href="#Sa-Token鉴权。" class="headerlink" title="Sa-Token鉴权。"></a>Sa-Token鉴权。</h2><p>这一部分放在gateway网关内完成。</p>
<p>首先是权限划分，每个用户有一个权限&#x2F;角色列表，持久化的时候会将该列表序列化成JSON保存，取的时候进行反序列化。</p>
<p>在Sa-Token中，角色和权限可以分开验证。</p>
<p>鉴权失败，不能将异常显示给用户看，这里文档建议创建一个全局异常拦截器，统一返回给前端的格式。</p>
<h2 id="为防止接口被恶意调用，涉及API签名认证算法，为用户分配唯一access-key-amp-secret-key以鉴权，保证调用的安全性、可溯源性。"><a href="#为防止接口被恶意调用，涉及API签名认证算法，为用户分配唯一access-key-amp-secret-key以鉴权，保证调用的安全性、可溯源性。" class="headerlink" title="为防止接口被恶意调用，涉及API签名认证算法，为用户分配唯一access key &amp; secret key以鉴权，保证调用的安全性、可溯源性。"></a>为防止接口被恶意调用，涉及API签名认证算法，为用户分配唯一access key &amp; secret key以鉴权，保证调用的安全性、可溯源性。</h2><p>为用户分配两个密钥，access key &amp; secret key，类似用户名和密码（通过acckey，能得到secret key），以此作为用户信息的唯一标识，这两个密钥是无状态的（复杂无序无规律）。</p>
<p>因为请求有可能被拦截，所以<strong>密钥不能直接放在header里面明文传输</strong>。所以这里有两个密钥，<strong>acc key是放在请求体中（签名也放在请求体中），可以进行明文传输。后端根据acc key来查找secret key，然后生成签名sign。</strong></p>
<p>然后<strong>将生成的sign与 传递过来的签名进行对比</strong>，以进行用户鉴权。</p>
<h3 id="签名的做法："><a href="#签名的做法：" class="headerlink" title="签名的做法："></a>签名的做法：</h3><p><strong>将 用户参数、密钥组合</strong>，通过签名生成算法（md5，sha1等，<strong>这里使用md5</strong>）进行加密，得到一个不可解密的值。</p>
<h3 id="签名的验证："><a href="#签名的验证：" class="headerlink" title="签名的验证："></a>签名的验证：</h3><p>在后端，使用同样的方式，将用户参数，密钥组合（请求参数中有access key，可以通过acc key查到secret key）以同样的方式进行加密，比较两个生成的签名是否一致，以此来完成签名的验证。</p>
<h3 id="防重放处理"><a href="#防重放处理" class="headerlink" title="防重放处理"></a>防重放处理</h3><p>我们的请求可能被劫持后重放到后端，这里通过 时间戳 和 随机数 实现了防重放。</p>
<p>首先请求参数中，添加一项nonce随机数，以及timestamp时间戳。</p>
<p>后端接收到请求后，会将随机数保存在全局信息中，如果发现接收到了已经出现过的随机数，说明存在重放，就拒绝该请求。</p>
<p>时间戳用来进行随机数信息的清理，等到达时间戳中的时间后，便会清除该范围内的随机数信息，以保证无效信息能及时被清理。</p>
<p>请求参数包括 access key，加密后的签名，nonce随机数，时间戳，body数据。</p>
<p><strong>用户在前端界面请求时，只传递必要的参数，之后后端接口会查询access key，secret key加密生成签名，结合时间戳，随机数，把这些信息放到请求头里面，通过hutool再次发起http请求，这次会请求api接口，之后返回数据。</strong></p>
<h3 id="关于可溯源性的理解"><a href="#关于可溯源性的理解" class="headerlink" title="关于可溯源性的理解"></a>关于可溯源性的理解</h3><p>如果<strong>某个用户的请求发生了异常</strong>，后台在通知前端用户进行告警之后，<strong>后端得知发生问题的用户</strong>（这就是溯源？），<strong>随后对该用户进行监控或限制等措施</strong>。</p>
<h2 id="基于-SpringBoot-Starter开发了客户端SDK，通过简短的代码即可调用接口，解决了开发者调用成本过高的问题。"><a href="#基于-SpringBoot-Starter开发了客户端SDK，通过简短的代码即可调用接口，解决了开发者调用成本过高的问题。" class="headerlink" title="基于 SpringBoot Starter开发了客户端SDK，通过简短的代码即可调用接口，解决了开发者调用成本过高的问题。"></a>基于 SpringBoot Starter开发了客户端SDK，通过简短的代码即可调用接口，解决了开发者调用成本过高的问题。</h2><p>SDK是给开发者使用的，他们可以在自己的项目里引入我们的SDK，从而可以通过调api的方式调用接口。开发者只用关心调用哪些接口，传递哪些参数就行了，就跟调用自己的代码一样简单。</p>
<p>用户在自己项目的配置文件中，指定自己的access key，secret key。这是用户的身份标识。</p>
<p>显然，还需要给开发者一个SDK使用文档，让开发者知道得怎么用才行。</p>
<p>接口SDK其实就是一个starter，因此问题转变为如何开发一个starter了。</p>
<ol>
<li><p>首先，删除build标签里的所有内容，因为这个是meaven构建项目生成可运行jar包的，但我们现在要制作的是starter。</p>
</li>
<li><p>删除启动类，在SDK里面，启动类是不需要的。</p>
</li>
<li><p>编写一个配置类，这里的注解包括@ComponentScan，@Configuration，@ConfigurationProperties（prefix关联配置文件中的 key内容），这个配置类会通过构造器方式注入一个 apiClient类。apiClient类中，有请求接口的方法。</p>
</li>
<li><p>指定配置类（这一步不能忘）：</p>
<p>新建<strong>resources&#x2F;META-INF&#x2F;spring.factories</strong>并指定</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># spring boot starter</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">com.xuan.XuanApiClientConfig</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>发布我们的starter：直接命令行mvn install，或者 maven lifecycle下面的 install。发布到maven本地仓库。</p>
</li>
</ol>
<h2 id="管理员可以接入并发布接口，各接口的调用情况可-进行可视化展示"><a href="#管理员可以接入并发布接口，各接口的调用情况可-进行可视化展示" class="headerlink" title="管理员可以接入并发布接口，各接口的调用情况可 进行可视化展示"></a>管理员可以接入并发布接口，各接口的调用情况可 进行可视化展示</h2><p>接口发布下线功能首先是给管理员使用的。</p>
<p>关于管理员权限校验，用**@AuthCheck(mustRole &#x3D; “admin”)**的切面注解。这里是通过AOP切面编程实现的，我们设置一个环绕通知，（后面直接在gateway网关里进行权限校验。）</p>
<p>接口的上下线状态信息通过一个枚举值来表示。设置状态信息也是，直接更新接口信息对象的 状态，返回给前端是否上下线成功；</p>
<p>管理员上线一个接口的时候，需要<strong>先判断接口是否可用</strong>，上线方法传入的是前端传过来的请求id，然后可以获取接口的请求地址以及示例请求体，之后请求该接口并验证是否能调用成功。</p>
<h2 id="用户可以开通接口调用权限，浏览接口并在线调试"><a href="#用户可以开通接口调用权限，浏览接口并在线调试" class="headerlink" title="用户可以开通接口调用权限，浏览接口并在线调试"></a>用户可以开通接口调用权限，浏览接口并在线调试</h2><p>用户在前端浏览接口，并在线调试的时候，请求参数是用户根据接口文档，<strong>手动输入的json格式请求参数</strong>。（后期可以改成postman那种，通过输入表单内容来配置）。</p>
<p><strong>接口文档</strong>的内容暂时包括<strong>请求地址、请求方法、请求头、请求参数、响应头、创建时间、更新时间</strong>等。（后期可以给出接口<strong>使用的示例</strong>等。）</p>
<p>用户调用接口的时候，并<strong>不是直接调用后端接口，而是先请求接口平台后端，由接口平台后端对接口发起调用</strong>，这样的<strong>好处</strong>就是更安全更规范，<strong>接口的地址不会暴露出来</strong>。</p>
<p><strong>用户在注册的时候，给用户分配一个初始的access key和secret key。用户可以在之后申请更换这两个key</strong>。</p>
<h2 id="接口使用次数统计"><a href="#接口使用次数统计" class="headerlink" title="接口使用次数统计"></a>接口使用次数统计</h2><p>接口调用次数主要是考虑到，付费用户可以进行不限次数或者大量次数的调用，免费用户只能有固定的调用次数，因此需要对接口调用次数进行统计。</p>
<p>为此，需要引入引入 <strong>用户-接口 关系表</strong>，这个表会<strong>记录用户可以调用哪些接口</strong>，这些<strong>可调用的接口的 总调用次数 和 剩余调用次数</strong> 。同时，有一个状态字段，标识接口是否开放给该用户（如果用户发生了恶意调用，我们可以禁止用户调用该接口）。</p>
<p>调用次数的统计，<strong>需要同时修改 总调用次数 和 剩余调用次数两个字段</strong>，这里需要<strong>使用事务 或者加锁</strong>。</p>
<p><strong>一个致命问题是，每个接口的开发者都得自己写一个 统计的方法</strong>，很麻烦而且可能产生一些问题。因此选择<strong>引入网关，在网关层面进行解决</strong>，这样就避免了重复开发。</p>
<h2 id="选用-SpringCloud-Gateway作为API网关，实现了路由转发、访问控制、流量染色，并集中处理签名校验、请求参数校验、接口调用统计-等业务逻辑，提高安全性的同时、便于系统开发维护"><a href="#选用-SpringCloud-Gateway作为API网关，实现了路由转发、访问控制、流量染色，并集中处理签名校验、请求参数校验、接口调用统计-等业务逻辑，提高安全性的同时、便于系统开发维护" class="headerlink" title="选用 SpringCloud Gateway作为API网关，实现了路由转发、访问控制、流量染色，并集中处理签名校验、请求参数校验、接口调用统计 等业务逻辑，提高安全性的同时、便于系统开发维护"></a>选用 SpringCloud Gateway作为API网关，实现了路由转发、访问控制、流量染色，并集中处理签名校验、请求参数校验、接口调用统计 等业务逻辑，提高安全性的同时、便于系统开发维护</h2><p><strong>网关的好处就是，对于请求可以统一进行处理</strong>，包括上面的调用次数统计，权限校验等。</p>
<p><strong>网关的具体作用</strong>有很多：</p>
<ul>
<li>路由、负载均衡、统一处理跨域；</li>
<li>统一鉴权、访问控制、流量染色；</li>
<li>统一的接口保护 （包括：限制请求、信息脱敏、降级，限流（令牌桶算法、漏桶算法）、超时时间、重试）</li>
<li>统一日志：这个做的比较多，用户调用接口情况可以统一进行记录。</li>
<li>统一文档。</li>
</ul>
<p><strong>转发规则</strong>在这里称为<strong>断言predicate</strong>，方便让请求过来找到对应的route进行处理，<strong>gateway内置了几种断言</strong>（转发uri都设定为<code>http://localhost:9023</code>）：</p>
<table>
<thead>
<tr>
<th align="center">规则</th>
<th>实例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Path</td>
<td>- Path&#x3D;&#x2F;gate&#x2F;<strong>,&#x2F;rule&#x2F;</strong></td>
<td>## 当请求的路径为gate、rule开头的时，转发到<a href="http://localhost:9023服务器上">http://localhost:9023服务器上</a></td>
</tr>
<tr>
<td align="center">Before</td>
<td>- Before&#x3D;2017-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td>
<td>在某个时间之前的请求才会被转发到 <a href="http://localhost:9023服务器上">http://localhost:9023服务器上</a></td>
</tr>
<tr>
<td align="center">After</td>
<td>- After&#x3D;2017-01-20T17:42:47.789-07:00[America&#x2F;Denver]</td>
<td>在某个时间之后的请求才会被转发</td>
</tr>
<tr>
<td align="center">Between</td>
<td>- Between&#x3D;2017-01-20T17:42:47.789-07:00[America&#x2F;Denver],2017-01-21T17:42:47.789-07:00[America&#x2F;Denver]</td>
<td>在某个时间段之间的才会被转发</td>
</tr>
<tr>
<td align="center">Cookie</td>
<td>- Cookie&#x3D;chocolate, ch.p</td>
<td>名为chocolate的表单或者满足正则ch.p的表单才会被匹配到进行请求转发</td>
</tr>
<tr>
<td align="center">Header</td>
<td>- Header&#x3D;X-Request-Id, \d+</td>
<td>携带参数X-Request-Id或者满足\d+的请求头才会匹配</td>
</tr>
<tr>
<td align="center">Host</td>
<td>- Host&#x3D;<a target="_blank" rel="noopener" href="http://www.hd123.com/">www.hd123.com</a></td>
<td>当主机名为<a target="_blank" rel="noopener" href="http://www.hd123.com的时候直接转发到http//localhost:9023%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A">www.hd123.com的时候直接转发到http://localhost:9023服务器上</a></td>
</tr>
<tr>
<td align="center">Method</td>
<td>- Method&#x3D;GET</td>
<td>只有GET方法才会匹配转发请求，还可以限定POST、PUT等请求方式</td>
</tr>
</tbody></table>
<p>引入网关后，<strong>用户请求流程如下</strong>：</p>
<ol>
<li>用户请求先打到网关；</li>
<li>gateway网关根据断言，将用户的请求转发到对应的路由</li>
<li>网关还可以设置过滤器web handler，用户请求一层层经过过滤器。</li>
<li>最终实际调用服务。</li>
</ol>
<h3 id="路由转发"><a href="#路由转发" class="headerlink" title="路由转发:"></a>路由转发:</h3><p>使用path匹配断言，将所有前缀为：&#x2F;api&#x2F;的请求进行转发，转发到实际的接口地址：<a target="_blank" rel="noopener" href="http://localhost:8123/api">http://localhost:8123/api</a></p>
<p>比如请求网关：<a target="_blank" rel="noopener" href="http://localhost:8090/api/name/?name=archer%E8%BD%AC%E5%8F%91%E5%88%B0">http://localhost:8090/api/name/?name=archer转发到</a> <a target="_blank" rel="noopener" href="http://localhost:8123/api/name/?name=archer">http://localhost:8123/api/name/?name=archer</a></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span>  </span><br><span class="line">  <span class="attr">port:</span> <span class="number">8090</span>  </span><br><span class="line">  </span><br><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">cloud:</span>  </span><br><span class="line">    <span class="attr">gateway:</span>  </span><br><span class="line">      <span class="attr">routes:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">api_route</span>  </span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8123</span>  </span><br><span class="line">          <span class="attr">predicates:</span>  </span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/api/**</span></span><br></pre></td></tr></table></figure>

<h3 id="流量染色："><a href="#流量染色：" class="headerlink" title="流量染色："></a>流量染色：</h3><p>流量染色主要是通过在过滤器中为请求添加请求头来实现，</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8090</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">name_api_route</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://localhost:8123</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/api/**</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=color,</span> <span class="string">blue</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestParameter=name,</span> <span class="string">mars</span></span><br></pre></td></tr></table></figure>

<p><strong>后端接口检查请求头的时候，会对请求头进行判断，不是网关来的请求会被拒绝。</strong></p>
<h3 id="签名校验："><a href="#签名校验：" class="headerlink" title="签名校验："></a>签名校验：</h3><p>accesskey是可以放在请求头中进行验证的，网关收到请求头，根据access key获得secret key（网关没有数据库的包，这一步是通过Dubbo远程调用实现的），然后生成签名。</p>
<p>将生成的签名 与 请求头里带的签名 进行对比，同时对比 时间戳 和 随机数，如果都有效，则放行，否则返回失败。</p>
<h3 id="访问控制："><a href="#访问控制：" class="headerlink" title="访问控制："></a>访问控制：</h3><p>这里是通过IP白名单进行控制的，如果不是白名单内的IP发来的请求，则直接进行拦截。访问白名单暂时是一个static final的arraylist。后期可以改成从redis缓存中获取。</p>
<h2 id="为解决多个子系统内代码大量重复的问题，抽象模型层和业务层代码为公共模块，并使用Dubbo-RPC框架实现子系统间的高性能接口调-用，大幅减少重复代码。"><a href="#为解决多个子系统内代码大量重复的问题，抽象模型层和业务层代码为公共模块，并使用Dubbo-RPC框架实现子系统间的高性能接口调-用，大幅减少重复代码。" class="headerlink" title="为解决多个子系统内代码大量重复的问题，抽象模型层和业务层代码为公共模块，并使用Dubbo RPC框架实现子系统间的高性能接口调 用，大幅减少重复代码。"></a>为解决多个子系统内代码大量重复的问题，抽象模型层和业务层代码为公共模块，并使用Dubbo RPC框架实现子系统间的高性能接口调 用，大幅减少重复代码。</h2><p><strong>网关不需要自个去请求数据库，我们希望网关的功能比较纯粹。因此直接请求到其他项目的方法</strong>，由其他服务来给我们提供我们想要的信息。这里使用Dubbo来做RPC远程调用。</p>
<p>一些<strong>公用的信息</strong>，比如接口信息、用户信息、用户接口调用关系等各种实体类，以及获取接口信息、接口是否存在、是否已分配给用户密钥的接口。需要<strong>抽离到公共服务</strong>上，避免代码的重复编写。</p>
<p><strong>RPC的作用</strong>：<strong>像调用本地方法一样调用远程方法。</strong></p>
<p><strong>RPC优点</strong>：<strong>对开发者透明</strong>，减少沟通成本；其次是，<strong>RPC向远程服务器发送请求时，未必使用HTTP协议，比如还可以使用TCP&#x2F;IP，性能更高。</strong></p>
<p>这里将nacos整合dubbo，<strong>服务调用方从nacos注册中心获取provider的信息，之后再去调用provider的方法</strong>。这里注册中心只负责提供服务信息，并不会帮助调用。</p>
<p><strong>这里抽取一些公共项目放到api-commen中，然后由gateway来RPC调用：</strong></p>
<ul>
<li>去数据库中查询是否已经分配给用户密钥（根据 accessKey 拿到用户信息，返回用户信息，为空表示不存在）</li>
<li>从数据库中查询模拟接口是否存在（请求路径、请求方法、请求参数，返回接口信息，为空表示不存在）</li>
<li>接口调用次数+ 1 invokeCount (accessKey、secretKey(标识用户），请求接口路径)</li>
</ul>
<p>api-common里面只放置接口，这些接口的实现需要放在api-backend中（将api-common打包并导入api-backend项目中），<strong>实现类用@DubboService标识</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://shadiaoyu.github.io/2024/04/23/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/23/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" class="post-title-link" itemprop="url">面试准备</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-23 19:55:39" itemprop="dateCreated datePublished" datetime="2024-04-23T19:55:39+08:00">2024-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-19 21:53:32" itemprop="dateModified" datetime="2024-05-19T21:53:32+08:00">2024-05-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="黑马点评相关问题"><a href="#黑马点评相关问题" class="headerlink" title="黑马点评相关问题"></a>黑马点评相关问题</h1><h2 id="1-项目里为什么要用消息队列："><a href="#1-项目里为什么要用消息队列：" class="headerlink" title="1. 项目里为什么要用消息队列："></a>1. 项目里为什么要用消息队列：</h2><p>在异步秒杀优惠券的业务中，涉及访问数据库的操作包括：根据优惠券id查询优惠券信息、查询当前用户是否已经购买过该优惠券、库存扣减、新增订单。串行执行的时候会相当消耗时间，于是对业务进行异步化改造。</p>
<p>使用阻塞队列的话，它用的是jvm内存，在高并发场景下可能会导致内存的溢出；同时，由于内容都是存在内存中，如果发生宕机，内存中的数据丢失会导致安全问题。因此选择使用消息队列来进行处理。</p>
<h2 id="2-请求很多，消息堆积处理不过来了如何应对（消息积压）"><a href="#2-请求很多，消息堆积处理不过来了如何应对（消息积压）" class="headerlink" title="2. 请求很多，消息堆积处理不过来了如何应对（消息积压）"></a>2. 请求很多，消息堆积处理不过来了如何应对（消息积压）</h2><ul>
<li>消费者扩容：如果当前主题（Topic）的消息队列数量大于消费者数量，可以通过增加消费者来扩容，从而提高消费能力，尽快消费积压的消息。通过增加消费者，可以使消息队列分配给更多的消费者进行并行消费，加快消息处理速度</li>
<li>消息迁移Queue扩容： 如果当前主题的消息队列数量小于或等于消费者数量，增加消费者可能无法有效提高消费能力。这时需要考虑<strong>扩容消息队列。</strong> <ul>
<li><strong>一种方法是创建一个临时主题</strong>，在临时主题上设置更多的消息队列。然后将部分消费者用于将消息从原主题转发到临时主题，这个过程不需要进行业务处理，只是简单地将消息转发，因此速度很快。接下来，使用扩容后的消费者来消费临时主题中的消息。当所有积压消息都被消费完毕后，可以恢复到原始状态。</li>
</ul>
</li>
</ul>
<h2 id="3-用户在消息堆积时以为卡了，多次请求怎么处理"><a href="#3-用户在消息堆积时以为卡了，多次请求怎么处理" class="headerlink" title="3. 用户在消息堆积时以为卡了，多次请求怎么处理"></a>3. 用户在消息堆积时以为卡了，多次请求怎么处理</h2><p>前端在用户点击按钮之后，禁用按钮直到有结果返回。</p>
<h2 id="4-项目都有哪些表"><a href="#4-项目都有哪些表" class="headerlink" title="4. 项目都有哪些表"></a>4. 项目都有哪些表</h2><p>博文表、博文的评论表、关注表、秒杀优惠券表、优惠券表、店铺信息表、店铺类型表（美食、酒吧等，以及关联icon）、用户信息表、优惠券订单表。</p>
<h2 id="5-超卖问题怎么解决？"><a href="#5-超卖问题怎么解决？" class="headerlink" title="5. 超卖问题怎么解决？"></a>5. 超卖问题怎么解决？</h2><p>使用乐观锁解决超卖问题，这里直接对比库存值，在进行扣减操作之前会查询库存stack值，在进行扣减操作时，检查stack（内存中的值V）是否与最开始读到的值（预期原始值A），如果相同则可以进行扣减，反之，不同的话说明有其他线程更改过库存了，此时应该进行重试工作。</p>
<h2 id="5-秒杀场景下扣减库存太慢了怎么解决"><a href="#5-秒杀场景下扣减库存太慢了怎么解决" class="headerlink" title="5. 秒杀场景下扣减库存太慢了怎么解决"></a>5. 秒杀场景下扣减库存太慢了怎么解决</h2><ul>
<li>采用上面所说的异步执行秒杀逻辑的方法</li>
<li>对库存进行拆分，比如将十万库存，分成100段，每段1000个库存。对应的，有100把锁去锁这100个库存段了，可以满足100个线程同时跑。</li>
</ul>
<h2 id="7-Redis大key怎么解决？"><a href="#7-Redis大key怎么解决？" class="headerlink" title="7. Redis大key怎么解决？"></a>7. Redis大key怎么解决？</h2><p>大key是指简单的key存储的value过大，或者hash，set，zset，list中存储过多的元素。</p>
<p>大key会导致如下问题：</p>
<ul>
<li>客户端耗时增加：数据量大导致网络传输时间会增加，导致响应时间增加</li>
<li>带宽和cpu资源占用过高：对大key进行读写操作时，会严重影响redis的性能和吞吐量。</li>
<li>数据倾斜：大key集中到某个redis节点上时，会导致数据在redis中集群中的分布不均衡，造成节点负载不均</li>
<li>阻塞问题：对大key进行删除或清理工作时，可能会导致redis阻塞。删除时会占用大量的CPU和IO资源导致响应变慢。在被动删除大key时，当redis内存不足时，会触发内存淘汰机制，可能导致部分大key被删除。</li>
</ul>
<p><strong>删除大key:</strong></p>
<ul>
<li>当Redis版本大于4.0时，可使用UNLINK命令安全地删除大Key，该命令能够 以非阻塞的方式，逐步地清理传入的Key。</li>
<li>当Redis版本小于4.0时，避免使用阻塞式命令KEYS，而是建议通过SCAN命 令执行增量迭代扫描key，然后判断进行删除。</li>
</ul>
<p><strong>压缩和拆分key:</strong></p>
<ul>
<li>当vaule是string时，比较难拆分，则使用序列化、压缩算法将key的大小控制 在合理范围内，但是序列化和反序列化都会带来更多时间上的消耗。</li>
<li>当value是string，压缩之后仍然是大key，则需要进行拆分，一个大key分为不 同的部分，记录每个部分的key，使用multiget等操作实现事务读取。</li>
<li>当value是list&#x2F;set等集合类型时，根据预估的数据规模来进行分片，不同的元 素计算后分到不同的片。</li>
</ul>
<p>总结：</p>
<ol>
<li>对bigkey进行拆分，比如一个hash结构的key，可以拆成多个hash来存储</li>
<li>直接删除bigkey，redis4.0起提供了unlink的非阻塞删除key方式</li>
<li>对value采用压缩算法，如果压缩后还是很大，那么就继续拆分</li>
<li>对失效的数据进行定期的清理</li>
</ol>
<h2 id="8-什么是热Key"><a href="#8-什么是热Key" class="headerlink" title="8. 什么是热Key"></a>8. 什么是热Key</h2><p>热key就是一个非常热销的产品，比如突然有几十万的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。</p>
<h2 id="9-如何解决热key问题"><a href="#9-如何解决热key问题" class="headerlink" title="9. 如何解决热key问题"></a>9. 如何解决热key问题</h2><p>方案主要有两种：</p>
<ol>
<li>利用二级缓存：比如ehcache或者hashmap，都可以作为二级缓存，当发现热key之后，把热key加载到jvm中，而针对这种热key请求，会直接从jvm中获取，而不是从redis中，比如一个十万的请求，应用层有50台机器，那么每台机器备份到2000个请求，还是可以处理的</li>
<li>备份热key：就是在redis集群当中，将这个key在多个redis上都进行保存，那么当有请求过来时，从集群当中挑选一个区访问进行取值</li>
</ol>
<h2 id="10-短信登录的短信怎么发送的"><a href="#10-短信登录的短信怎么发送的" class="headerlink" title="10.  短信登录的短信怎么发送的"></a>10.  短信登录的短信怎么发送的</h2><h2 id="11-项目的拦截器详细讲讲"><a href="#11-项目的拦截器详细讲讲" class="headerlink" title="11. 项目的拦截器详细讲讲"></a>11. 项目的拦截器详细讲讲</h2><h2 id="12-怎么保存验证码"><a href="#12-怎么保存验证码" class="headerlink" title="12. 怎么保存验证码"></a>12. 怎么保存验证码</h2><h2 id="13-项目里存在redis里的key的格式，存的什么"><a href="#13-项目里存在redis里的key的格式，存的什么" class="headerlink" title="13.项目里存在redis里的key的格式，存的什么"></a>13.项目里存在redis里的key的格式，存的什么</h2><h2 id="14-如何标识用户"><a href="#14-如何标识用户" class="headerlink" title="14. 如何标识用户"></a>14. 如何标识用户</h2><p>手机号作为用户标识</p>
<h2 id="15-项目的权限刷新什么意思"><a href="#15-项目的权限刷新什么意思" class="headerlink" title="15.项目的权限刷新什么意思"></a>15.项目的权限刷新什么意思</h2><h2 id="16-旁路缓存机制具体解决的什么场景"><a href="#16-旁路缓存机制具体解决的什么场景" class="headerlink" title="16. 旁路缓存机制具体解决的什么场景"></a>16. 旁路缓存机制具体解决的什么场景</h2><h2 id="17-更新缓存失败了怎么办"><a href="#17-更新缓存失败了怎么办" class="headerlink" title="17 更新缓存失败了怎么办"></a>17 更新缓存失败了怎么办</h2><p>涉及Redis的高可用.</p>
<p>当客户端发现master节点不可写后，可以采取降级措施，将数据暂时写入本地缓存和磁盘中，在一段时间后（master恢复正常后）重新写入master来保证数据不丢失。也可以将数据写入Kafka消息队列，等master恢复正常，再隔一段时间去消费Kafka中的数据，将数据重新写入master。</p>
<h2 id="重试的时候，缓存中的错数据被访问多次了，怎么解决"><a href="#重试的时候，缓存中的错数据被访问多次了，怎么解决" class="headerlink" title="重试的时候，缓存中的错数据被访问多次了，怎么解决"></a>重试的时候，缓存中的错数据被访问多次了，怎么解决</h2><h2 id="项目为什么要加个消息队列"><a href="#项目为什么要加个消息队列" class="headerlink" title="项目为什么要加个消息队列"></a>项目为什么要加个消息队列</h2><h2 id="抢优惠券没有及时处理怎么办"><a href="#抢优惠券没有及时处理怎么办" class="headerlink" title="抢优惠券没有及时处理怎么办"></a>抢优惠券没有及时处理怎么办</h2><h2 id="抢优惠券处理完了如何通知用户"><a href="#抢优惠券处理完了如何通知用户" class="headerlink" title="抢优惠券处理完了如何通知用户"></a>抢优惠券处理完了如何通知用户</h2><h2 id="Redis的Zset"><a href="#Redis的Zset" class="headerlink" title="Redis的Zset"></a>Redis的Zset</h2><p>Zset是redis当中的SortedSet，比set多了一个score值，按score值升序排序</p>
<p>那么zset底层依靠的是ziplist或者skiplist实现，当如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</p>
<p>但是其实使用skiplist，是将skiplist和dict一起进行包装，使用通dict中的entry记录key和value，使用skiplist记录score，从而通过dict进行键值的存储，通过，skiplist存储socre并进行排序和快速的查找</p>
<p>当使用ziplist时，逻辑是将score和element连续存储</p>
<h2 id="Zset的范围查询的时间复杂度是多少"><a href="#Zset的范围查询的时间复杂度是多少" class="headerlink" title="Zset的范围查询的时间复杂度是多少"></a>Zset的范围查询的时间复杂度是多少</h2><p><code>ZRANGE</code> 或 <code>ZRANGEBYSCORE</code>，其时间复杂度是 O(log N + M)，其中 N 是有序集合中的元素数量，M 是返回的元素数量。</p>
<p>这是因为 Redis 内部使用了跳跃表（skip list）实现有序集合，而跳跃表的查询时间复杂度是 O(log N)。在执行范围查询时，Redis首先定位到开始的元素，然后按顺序移动到结束的元素，因此时间复杂度还取决于返回的元素数量 M。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://shadiaoyu.github.io/2024/04/08/%E5%A4%A9%E6%9C%BA%E5%AD%A6%E5%A0%82%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/08/%E5%A4%A9%E6%9C%BA%E5%AD%A6%E5%A0%82%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">天机学堂学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-08 14:29:18" itemprop="dateCreated datePublished" datetime="2024-04-08T14:29:18+08:00">2024-04-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://shadiaoyu.github.io/2024/03/19/redis%E5%A4%8D%E4%B9%A0-%E7%BB%93%E5%90%88%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/19/redis%E5%A4%8D%E4%B9%A0-%E7%BB%93%E5%90%88%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-19 20:30:25" itemprop="dateCreated datePublished" datetime="2024-03-19T20:30:25+08:00">2024-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-28 16:51:53" itemprop="dateModified" datetime="2024-05-28T16:51:53+08:00">2024-05-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis:"></a>Redis:</h2><h3 id="Redis数据结构："><a href="#Redis数据结构：" class="headerlink" title="Redis数据结构："></a>Redis数据结构：</h3><p>（1）5种基础数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p>
<p>（2）3种特殊数据结构：HyperLogLogs（基数统计）、BitMap（位存储）、Geospatial（地理位置）</p>
<h4 id="1-Redis-双写一致性：redis作为缓存，mysql的数据如何与redis进行同步呢？"><a href="#1-Redis-双写一致性：redis作为缓存，mysql的数据如何与redis进行同步呢？" class="headerlink" title="1.Redis 双写一致性：redis作为缓存，mysql的数据如何与redis进行同步呢？"></a>1.Redis 双写一致性：redis作为缓存，mysql的数据如何与redis进行同步呢？</h4><p>这里有两种需求（1）一致性要求高的 （2）允许延迟一致，这里分开来描述：</p>
<ul>
<li><strong>一致性要求高的（但是性能不高）：</strong><ul>
<li>读数据的时候添加读锁（其他线程可以读，但是不能写，跟共享锁一个概念），写数据的时候添加写锁（其他线程既不能读，也不能写，类似于排他锁），读写锁可以从redission中获取。</li>
</ul>
</li>
<li><strong>允许延迟一致的（异步通知、基于Canal的异步通知）：</strong><ul>
<li><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240406200855325.png" alt="image-20240406200855325"></li>
<li>基于Canal的异步通知<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240406201005207.png" alt="image-20240406201005207"></li>
</ul>
</li>
</ul>
<p>无论是先更新数据库，再更新缓存；还是先更新缓存，再更新数据库，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象。</p>
<p><strong>因此采用Cache Aside 策略，不更新缓存，而是删除缓存中的数据。最后到读取数据时，发现缓存中没有数据之后，再从数据库中读取数据，更新到缓存中。</strong></p>
<ul>
<li><strong>写策略的步骤：</strong><ul>
<li>更新数据库中的数据</li>
<li>删除缓存中的数据</li>
</ul>
</li>
<li><strong>读策略的步骤：</strong><ul>
<li>如果读取的数据命中了缓存，则直接返回数据；</li>
<li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存中，并返回给用户。</li>
</ul>
</li>
</ul>
<p><strong>针对写策略步骤的执行先后顺序，又会有一些问题：</strong></p>
<ul>
<li>如果先删除缓存，再更新数据库的话，在<strong>读+写</strong>并发的时候，还是会出现缓存和数据库数据的不一致的情况；<ul>
<li>这种情况下为了解决一致性问题，我们采用<strong>延迟双删</strong>的方法，即<strong>删除缓存，更新数据库，延迟一段时间后，再次删除缓存。</strong>主要是为了确保请求A在睡眠的时候，请求B能够在这一段时间内完成从数据库读取数据，再把缺失的缓存写入缓存的操作，<strong>但是具体睡眠多久比较玄学，搞不好依然会出现 读脏数据的问题。</strong></li>
</ul>
</li>
<li>如果<strong>先更新数据库，再删除缓存</strong>，在并发的时候，还是会出现缓存和数据库的数据不一致的情况，<strong>但是出现这种情况的概率很小，因为缓存的写入远快于数据库的写入，</strong>很难出现请求B已经更新了数据库并删除了缓存后，请求A才更新完缓存的情况。<strong>所以，这种情况是可以保证一致性的</strong><ul>
<li>但是这个方案因为在每次更新数据库的时候都要删除缓存，所以会导致缓存命中率降低。因此可以采用<strong>更新数据库+ 更新缓存的方案</strong>，但是会出现并发安全问题，因此有两种解决办法<strong>（1）在更新缓存之前添加一个分布式锁，保证同一时间只有一个请求更新缓存；（2）更新完缓存之后，给缓存加上较短的过期时间，这样即使出现不一致的情况，数据也会很快过期。</strong></li>
</ul>
</li>
</ul>
<h3 id="黑马点评"><a href="#黑马点评" class="headerlink" title="黑马点评"></a>黑马点评</h3><h4 id="（1）商家缓存主动更新策略（根据id查询商家信息时用到）："><a href="#（1）商家缓存主动更新策略（根据id查询商家信息时用到）：" class="headerlink" title="（1）商家缓存主动更新策略（根据id查询商家信息时用到）："></a>（1）商家缓存主动更新策略（根据id查询商家信息时用到）：</h4><ul>
<li><p>这一策略同时进行数据库操作和缓存操作，加入了事务，以保证同成功同失败。</p>
</li>
<li><p><strong>先更新数据库，再更新缓存：</strong> 缓存的读写是很快的，而数据库的操作是很慢的，如果先操作缓存（即先删除缓存），再更新数据库时，另一个线程在进行同样的查询的过程中，由于没有读到缓存，会去读数据库中的数据（而数据库数据更新很慢，这时还没更新完成），因此会读到旧数据，并把这个旧数据给写入缓存中，这就导致了缓存数据和数据库数据的不一致。<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240320213306700.png"></p>
</li>
<li><p>具体实现:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">    <span class="comment">//更新店铺信息</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺id 不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.更新数据库</span></span><br><span class="line">        updateById(shop);</span><br><span class="line">        <span class="comment">//2.删除缓存</span></span><br><span class="line">        stringRedisTemplate.delete(CACHE_SHOP_KEY + id);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（2）缓存穿透解决办法"><a href="#（2）缓存穿透解决办法" class="headerlink" title="（2）缓存穿透解决办法"></a>（2）缓存穿透解决办法</h4><ul>
<li><p><strong>缓存穿透是指，请求的数据在缓存和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库</strong></p>
</li>
<li><p><strong>解决策略：</strong></p>
<ul>
<li>缓存空对象（本项目用的这个） ：数据库也查不到信息后，向缓存中缓存空数据（会设置TTL），防止一直访问数据库。<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：因为缓存了空数据，造成了额外的内存消耗。同时，如果数据库又更新了数据，而此时缓存中仍为空数据，会造成短时间内的数据不一致（在缓存TTL结束后就可以保持一致了）。</li>
</ul>
</li>
<li>设置布隆过滤器：<ul>
<li>优点：内存占用比较少，没用使用多余的key。</li>
<li>缺点：实现复杂，并且存在误判的可能。</li>
</ul>
</li>
<li>缓存预热时，需要预热布隆过滤器。</li>
</ul>
</li>
</ul>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240320214835903.png" alt="image-20240320214835903"></p>
<ul>
<li>关于布隆过滤器的原理：<ul>
<li>当我们向过滤器添加一个元素key的时候，我们通过多个hash函数，分别计算出多个值，然后将这些值所在的位置置为1.</li>
<li><strong>那么如果新来一个数据，如何判断它存不存在？</strong>当新数据来的时候，同样使用前面的多个hash函数计算值，查看每一个计算结果对应的位置是不是1，如果有一个不是1，那么就认定这个数据不存在。</li>
<li><strong>如果每个位置都是1，也不能保证这个数据真的存在。</strong>毕竟多个数据可以通过hash计算出相同的位置。如果这个位置是1，可能是另一个数据计算得来的。<strong>因此，布隆过滤器可以判定某个数据一定不存在，但不能保证某个数据一定存在。</strong></li>
<li>布隆过滤器的优缺点很明显：使用二进制数组，占用内存极少，并且插入和查询速度都很快；但是随着数据的增加，误判率会增加，无法判断数据一定存在；此外还有一个重要的缺点，就是他无法删除数据。</li>
</ul>
</li>
</ul>
<h4 id="（3）缓存雪崩解决办法："><a href="#（3）缓存雪崩解决办法：" class="headerlink" title="（3）缓存雪崩解决办法："></a>（3）缓存雪崩解决办法：</h4><ul>
<li><strong>缓存雪崩</strong>是指在同一时段内，大量的缓存key同时失效或者redis服务宕机，导致大量的请求打到数据库，带来巨大的压力。</li>
<li>**解决策略： ** <ul>
<li>给不同的key的ttl添加随机值</li>
<li>利用redis集群提高服务的可用性</li>
<li>为缓存业务添加降级限流策略：分库分表可还行。</li>
<li>为业务设置多级缓存：例如使用本地缓存 + 分布式缓存的方式，不同级别缓存时间过时间不一样，即使某个级别缓存过期了，还有其他缓存级别兜底。</li>
</ul>
</li>
</ul>
<h4 id="（4）缓存击穿解决办法："><a href="#（4）缓存击穿解决办法：" class="headerlink" title="（4）缓存击穿解决办法："></a>（4）缓存击穿解决办法：</h4><ul>
<li><p><strong>缓存击穿</strong>也叫热点key问题，就是一个<strong>被高并发访问，并且缓存重建业务较复杂的key</strong>突然失效了，无数的请求访问会在瞬间给数据库带来巨大冲击。</p>
</li>
<li><p>缓存雪崩是指大量的缓存key失效，而缓存击穿是指热点key失效。缓存穿透是指要查的key在缓存中和数据库中都不存在。</p>
</li>
<li><p>（查询数据库和重建缓存的过程会很缓慢，在这期间如果有大量的请求过来，都是未命中，导致一直访问数据库。）<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240321202635871.png" alt="image-20240321202635871"></p>
</li>
<li><p><strong>解决策略：</strong> </p>
<ul>
<li><p>互斥锁：</p>
<ul>
<li><p>每个请求如果未命中缓存后需要进行缓存的重建工作，这时我们指定唯一获得互斥锁的线程进行缓存重建，等到重建完成后再释放锁。在此期间其他线程会重复缓存查询以及获取锁的过程。</p>
</li>
<li><p>关于互斥锁的构建，这里使用stringRedisTemplate 的setIfAbsent来进行实现（Redis的Setnx命令），<strong>在指定的key不存在时，为key设置指定的值。返回值表示设置成功与失败</strong></p>
</li>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F; 获取互斥锁，返回值标识是否获得<br>private boolean tryLock(String lockKey) {<br>    &#x2F;&#x2F; 添加锁，并设置有效期，有效期时长要比业务时间长<br>    Boolean flag &#x3D; stringRedisTemplate.opsForValue().setIfAbsent(lockKey, “1”, 10L, TimeUnit.SECONDS);<br>    &#x2F;&#x2F; 拆箱过程中可能会出现空指针异常，所以使用hutool提供的工具来解决<br>    return BooleanUtil.isTrue(flag);<br>}<br><br>&#x2F;&#x2F; 释放锁<br>private void unlock(String lockKey) {<br>    stringRedisTemplate.delete(lockKey);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 逻辑过期</span><br><span class="line"></span><br><span class="line">  * 逻辑过期并不是真正的过期，对于对应的key我们并不需要去设置TTL，而是通过业务逻辑来达到一个类似于过期的效果。其本质还是限制落到数据库的请求数量！</span><br><span class="line">  * 这样一来，缓存基本是会被命中的，因为没有给缓存设置任何过期时间，并且对于key的设置都是实现选择好的，如果出现未命中的情况基本可以判断他不在选择之内，这样我们就可以直接返回错误信息。</span><br><span class="line">  * 那么对于命中的情况，就需要先判断逻辑时间是否过期，再根据结果来决定是否进行缓存重建。**而这里的逻辑时间就是减少大量请求落到数据库的一个关口**</span><br><span class="line"></span><br><span class="line">* ![image-20240321202444133](https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240321202444133.png)</span><br><span class="line"></span><br><span class="line">* 在发现逻辑过期后（意味着数据更新），首先尝试获取互斥锁，在获取到锁后，会开启新的线程来进行缓存的重建，而原线程返回的是未更新的老数据，这意味着使用**逻辑时间不保证数据的一致性。**</span><br><span class="line"></span><br><span class="line">* **注意做逻辑过期时，要先预热，手动缓存热点key**</span><br><span class="line"></span><br><span class="line">* 在进行商铺信息的查询的过程中，使用了互斥锁以及逻辑过期时间的方式解决缓存击穿问题。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line">     * 使用互斥锁，解决缓存击穿问题</span><br><span class="line">     * 缓存穿透问题：缓存穿透是指客户请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会被打到数据库。</span><br><span class="line">     * 缓存击穿问题：指热点key失效，大量请求打到数据库的问题。</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    private Shop queryWithMutex(Long id) &#123;</span><br><span class="line">        Shop shop;</span><br><span class="line">        //1.从redis中查询商铺缓存</span><br><span class="line">        String key = CACHE_SHOP_KEY + id;</span><br><span class="line">        String shopJson = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        //2.判断是否存在</span><br><span class="line">        if (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            //3.存在则直接返回</span><br><span class="line">            shop = JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">            return shop;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 因为我们在解决缓存穿透的时候会将空值放入redis中，所以可能会取得空值，因此需要对空值再进行一次判断</span><br><span class="line">        if (shopJson != null) &#123;</span><br><span class="line">            // 命中的信息是空值，所以直接进行返回</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //添加互斥锁，解决缓存击穿问题</span><br><span class="line">        //第一步，获取互斥锁</span><br><span class="line">        String lockKey = RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean isLock = tryLock(lockKey);</span><br><span class="line">            //第二步，判断是否获得锁</span><br><span class="line">            if (!isLock) &#123;</span><br><span class="line">                //第三步，如果失败，进行休眠，休眠后重试</span><br><span class="line">                Thread.sleep(10);</span><br><span class="line">                return queryWithMutex(id);</span><br><span class="line">            &#125;</span><br><span class="line">            /*第四步，如果成功，应再次检测redis缓存是否存在，做double check，这样做的原因是我们在获得锁之后，其他</span><br><span class="line">             *线程可能已经将数据写入redis缓存中了，那么我们即使拿到锁，也没有必要再去查询数据库了，直接从redis中获取</span><br><span class="line">             * 就可以了。</span><br><span class="line">             * 而且，代码已经走到了这一步，说明我们的key取得的缓存不是我们用于解决缓存穿透时设置的空值了，因此不需要在进行</span><br><span class="line">             * 空值的校验了。</span><br><span class="line">             * */</span><br><span class="line">            String secondShopJson = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">            if (StrUtil.isNotBlank(secondShopJson)) &#123;</span><br><span class="line">                // 缓存中存在，则直接返回</span><br><span class="line">                Shop secondShop = JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">                return secondShop;</span><br><span class="line">            &#125;</span><br><span class="line">            //走到这，说明拿到锁后，缓存中依旧没有出现我们想要的值，那么就需要查询数据库了</span><br><span class="line">            shop = getById(id);</span><br><span class="line">            // 模拟重建的延时</span><br><span class="line">            Thread.sleep(200);</span><br><span class="line">            //5.判断数据库中是否存在</span><br><span class="line">            if (shop == null) &#123;</span><br><span class="line">                // 避免缓存穿透问题，若数据库中不存在数据，则在redis中存入空值</span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, &quot;&quot;, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                //7.若不存在，则报错</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            //6.若存在，则存入redis缓存，并返回</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonPrettyStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //释放锁</span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        return shop;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用线程池来管理线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Shop <span class="title function_">queryWithLocalExpire</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        Shop shop;</span><br><span class="line">        <span class="comment">//1.从redis中获取缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2.判断是否为空，如果为空则返回null;</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(shopJson)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.如果不为空，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, RedisData.class);</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> (JSONObject) redisData.getData();</span><br><span class="line">        shop = JSONUtil.toBean(data, Shop.class);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">//4.获取时间，判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span> (LocalDateTime.now().isBefore(expireTime)) &#123;</span><br><span class="line">            <span class="comment">//4.1 如果没有过期，则直接返回即可</span></span><br><span class="line">            <span class="keyword">return</span> shop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.2 如果过期，需要进行缓存重建</span></span><br><span class="line">        <span class="comment">//5 缓存重建</span></span><br><span class="line">        <span class="comment">//6 获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="comment">//6.1 判断是否获取成功，如果成功，开启新线程进行缓存重建</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.saveShop2Redis(id, <span class="number">20L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//7 返回旧数据</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240321210833411.png" alt="image-20240321210833411" style="zoom:67%;" /></li>
</ul>
<h4 id="5-基于List的点赞列表-amp-基于SortedSet的点赞排行榜"><a href="#5-基于List的点赞列表-amp-基于SortedSet的点赞排行榜" class="headerlink" title="(5) 基于List的点赞列表&amp;基于SortedSet的点赞排行榜"></a>(5) 基于List的点赞列表&amp;基于SortedSet的点赞排行榜</h4><ul>
<li><p>用户发表博文内容时，后端接收到的请求中不包含userID，userID需要我们从ThreadLocal中获取。在保存博文时，需要set博文的作者userID，在保存成功后，查询该用户的所有粉丝，并将博文信息推送给粉丝。</p>
</li>
<li><p>这里我们使用sortedSet来实现发布信息的推送，key为follow_user_id(粉丝ID)，value为blog_id，score为System.currentTimeMillis()。（这里可以优化为使用mq进行实现）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">        <span class="comment">//获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//保存blog</span></span><br><span class="line">        blog.setUserId(userId);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">save</span> <span class="operator">=</span> save(blog);</span><br><span class="line">        <span class="keyword">if</span> (save) &#123;</span><br><span class="line">            <span class="comment">//查询笔记作者的所有粉丝</span></span><br><span class="line">            List&lt;Follow&gt; follows = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, userId).list();</span><br><span class="line">            <span class="keyword">for</span> (Follow follow : follows) &#123;</span><br><span class="line">                <span class="comment">//获取粉丝id</span></span><br><span class="line">                <span class="type">Long</span> <span class="variable">followUserId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.FEED_KEY + followUserId;</span><br><span class="line">                <span class="comment">//推送</span></span><br><span class="line">                stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//推送笔记的id给所有粉丝</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回blog id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于博客实体类，我们通过‘@TableField(exist &#x3D; false)’注解来指定，icon（头像）,name（用户姓名）表示这两个字段不属于Blog表中的字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户图标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> String icon;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否点赞过了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isLike;</span><br></pre></td></tr></table></figure>


</li>
<li><p>因为用户和头像这俩字段不属于blog的数据表字段，所以不仅在保存博客的时候我们需要从threadLocal中获取用户id并保存，在查询博文内容的时候，我们还要根据博文的user ID来查询发布者的用户名以及头像等信息。</p>
</li>
<li><p><strong>点赞功能（首页探店排行榜&amp;博文详情页都可以点赞）</strong></p>
<p>点赞功能的需求如下：（1）同一个用户只能点赞一次，再次点击则取消点赞；（2）如果当前用户已经点赞，则点赞按钮高亮显示（前端已经实现了，判断字段Blog类的isLike属性）</p>
<ul>
<li><p>实现步骤：</p>
<ul>
<li><p>给Blog类中添加一个isLike字段，用来表示当前blog是否被当前用户点赞。</p>
</li>
<li><p>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数加1，已点赞过则点赞数-1。缓存key为blog的id，缓存采用sortedSet的数据结构，value为userID，score为用户点赞时刻（<strong>即，每个blogID对应的是所有点赞该blog的userid，userID根据用户点赞时间为score进行排序</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">//实现帖子点赞功能</span></span><br><span class="line">        <span class="comment">// 1. 获取当前登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//2.判断当前用户是否已经点赞</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.BLOG_LIKED_KEY + id;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">        <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//3.如果未点赞，可以点赞</span></span><br><span class="line">            <span class="comment">//3.1 数据库点赞数加一</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">            <span class="comment">//3.2 保存点赞用户id 到redis sortedSet集合</span></span><br><span class="line">            <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">                stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4. 如果已经点赞，取消点赞</span></span><br><span class="line">            <span class="comment">//4.1 数据库点赞数减一</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">            <span class="comment">//4.2 将用户信息从reids sortedSet集合中删除</span></span><br><span class="line">            <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">                stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>修改queryBlogById方法，判断当前登录用户是否点赞过（即判断能不能查到当前userID，有就说明已点赞），并将结果赋值给blog的isLike字段。(<strong>isLike字段不属于blog表字段，它的作用是，当前用户如果点赞过，那么就将isLike置为真，在客户端发请求查询blog信息时，前端根据这个字段决定是否高亮显示点赞按钮</strong>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isBlogLiked</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">       <span class="comment">//判断当前笔记是否被点赞过</span></span><br><span class="line">       <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">       <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//用户未登录，不用关心是否点赞过，直接返回</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.BLOG_LIKED_KEY + blog.getId();</span><br><span class="line">       <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">       blog.setIsLike(score != <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>修改分页查询Blog业务，判断当前用户是否点赞过，赋值给isLike字段（<strong>这个业务是用于分页展示点赞排行榜的博文，点赞排行榜根据博文的点赞数量降序排序并分页展示的</strong>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryHotBlog</span><span class="params">(Integer current)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据用户查询</span></span><br><span class="line">        Page&lt;Blog&gt; page = blogService.query()</span><br><span class="line">                .orderByDesc(<span class="string">&quot;liked&quot;</span>)</span><br><span class="line">                .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));</span><br><span class="line">        <span class="comment">// 获取当前页数据</span></span><br><span class="line">        List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line">        <span class="comment">// 查询用户,以及查询是否被点赞过</span></span><br><span class="line">        records.forEach(blog -&gt; &#123;</span><br><span class="line">            <span class="built_in">this</span>.queryBlogUser(blog);</span><br><span class="line">            <span class="built_in">this</span>.isBlogLiked(blog);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(records);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询当前帖子被哪些用户点赞了（<strong>这里只在前端展示前5位点赞用户的头像，按照点赞时间从前到后进行排序</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">//返回帖子点赞top5用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.BLOG_LIKED_KEY + id;</span><br><span class="line">        Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (top5 == <span class="literal">null</span> || top5.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 解析出其中的用户id</span></span><br><span class="line">        List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">        <span class="type">String</span> <span class="variable">idListStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">        <span class="comment">//3.根据用户id查询用户，返回已点赞用户列表</span></span><br><span class="line">        <span class="comment">//List&lt;UserDTO&gt; users = userService.listByIds(ids).stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());</span></span><br><span class="line">        List&lt;UserDTO&gt; users = userService.query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;order by field(id,&quot;</span> + idListStr + <span class="string">&quot;)&quot;</span>).list()</span><br><span class="line">                .stream()</span><br><span class="line">                .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="comment">//4.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(users);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="（6）好友关注功能"><a href="#（6）好友关注功能" class="headerlink" title="（6）好友关注功能"></a>（6）好友关注功能</h4><ul>
<li><p>在探店图文的详情页面中，可以关注发布笔记的作者：</p>
</li>
<li><p><strong>业务逻辑：</strong></p>
<ul>
<li><p><strong>关注用户</strong>功能的实现：前端传一个isFollow值，如果用户已经关注该博主，则isFollow为false，没有关注资格，但可以进行取关。反之为true，说明可以进行关注。new Follow对象，将user ID和userFollowID（用户关注的人）都set到Follow对象里。再将follow对象save到数据库表中。</p>
</li>
<li><pre><code class="java">public Result follow(Long id, boolean isFollow) &#123;
        //关注和取关
        //1. 获取登录用户
        UserDTO user = UserHolder.getUser();
        if (user == null) &#123;
            //如果用户未登录，不用判断是否关注
            return Result.ok();
        &#125;

        Long userId = user.getId();
        String key = RedisConstants.FOLLOW_USER_KEY + userId;
        if (isFollow) &#123;
            // 如果未关注，新增数据
            Follow follow = new Follow();
            follow.setUserId(userId);
            follow.setFollowUserId(id);
            boolean isSuccess = save(follow);
            if (isSuccess) &#123;
                stringRedisTemplate.opsForSet().add(key,id.toString());
            &#125;
        &#125; else &#123;
            //如果已关注，取关删除数据
            boolean isSuccess = remove(new QueryWrapper&lt;Follow&gt;().eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, id));
            if (isSuccess) &#123;
                stringRedisTemplate.opsForSet().remove(key,id.toString());
            &#125;
        &#125;
        return Result.ok();
    &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* **查看他人主页功能的实现：**前端传该人的userID ，首先根据user ID查询用户信息，其次还要查询该用户发表的博文信息，并分页进行展示：</span><br><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  // 根据id查询用户</span><br><span class="line">      @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">      public Result queryUserById(@PathVariable(&quot;id&quot;) Long userId)&#123;</span><br><span class="line">          // 查询详情</span><br><span class="line">          User user = userService.getById(userId);</span><br><span class="line">          if (user == null) &#123;</span><br><span class="line">              return Result.ok();</span><br><span class="line">          &#125;</span><br><span class="line">          UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">          // 返回</span><br><span class="line">          return Result.ok(userDTO);</span><br><span class="line">      &#125;</span><br><span class="line">  @GetMapping(&quot;/of/user&quot;)</span><br><span class="line">  public Result queryBlogByUserId(</span><br><span class="line">  		@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;) Integer current,</span><br><span class="line">  		@RequestParam(&quot;id&quot;) Long id) &#123;</span><br><span class="line">  	// 根据用户查询</span><br><span class="line">  	Page&lt;Blog&gt; page = blogService.query()</span><br><span class="line">  			.eq(&quot;user_id&quot;, id).page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));</span><br><span class="line">  	// 获取当前页数据</span><br><span class="line">  	List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line">  	return Result.ok(records);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><strong>共同关注功能的实现：</strong>共同关注功能使用redis中的<strong>set结构</strong>进行实现，求两个用户关注列表的交集，因此我们不仅需要吧数据存入follow表中（保存关注关系），还要把user ID放入redis的set集合中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">//获取当前用户</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果用户未登录，不用判断是否关注</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">key1</span> <span class="operator">=</span> RedisConstants.FOLLOW_USER_KEY + userId;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> RedisConstants.FOLLOW_USER_KEY + id;</span><br><span class="line">        <span class="comment">//求交集</span></span><br><span class="line">        Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key1, key2);</span><br><span class="line">        <span class="comment">//查询交集中的用户 信息</span></span><br><span class="line">        <span class="keyword">if</span> (intersect == <span class="literal">null</span> || intersect.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">        List&lt;UserDTO&gt; commons = userService.listByIds(ids)</span><br><span class="line">                .stream().map(followUser -&gt; BeanUtil.copyProperties(followUser, UserDTO.class))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> Result.ok(commons);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Feed流实现关注用户的博文推送：</strong></p>
<ul>
<li><p>本例中的个人界面，是基于关注的好友来进行feed流的，因此采用timeLine的方式，依照时间顺序刷新。（也有像抖音那种的，使用智能推荐算法进行推荐的智能排序的feed流）。</p>
</li>
<li><p>实现方案有三种：<strong>推模式、拉模式、推拉结合的模式（推拉是相对于当前用户而言的）</strong></p>
<ul>
<li>拉模式：又称为读扩散，每个博主发送信息的时候都发送到自己的发件箱中（一个缓冲区），用户读的时候从各个关注用户的发件箱中读取信息。但是读操作过于频繁，若用户关注了许多博主，一次要读的消息也是十分的多，延迟会很高。</li>
</ul>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240326203018064.png" alt="image-20240326203018064"></p>
<ul>
<li><p>推模式：又称为写扩散，每个用户有自己的收件箱（一个缓冲区），每个博主发送信息的时候，将发送内容推送至每一个用户的收件箱中。显然，这样会导致写操作十分频繁，如果博主有许多粉丝，写操作会更频繁。</p>
</li>
<li><p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240326203034238.png" alt="image-20240326203034238"></p>
</li>
<li><p>推拉结合的模式：也称作读写结合，兼具推和拉两种方式的优点。对于普通博主，粉丝少，那么就可以使用推模式，这样写操作就并不繁重；对于大博主，粉丝多，分为两种情况，活跃粉多，那么就可以使用拉模式；活跃粉少，那么就可以使用推模式。</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240326203318389.png" alt="image-20240326203318389"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>推送到粉丝收件箱：</strong></p>
<ul>
<li><p>需求：</p>
<ul>
<li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱（收件箱使用sortedSet实现）</li>
<li>收件箱满足可以根据时间戳排序，必须用redis的数据结构实现。</li>
<li>查询收件箱数据的 时候，可以进行分页查询。</li>
</ul>
</li>
<li><p><strong>注意：Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</strong></p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240326203940897.png" alt="image-20240326203940897"></p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240326204001342.png" alt="image-20240326204001342"></p>
</li>
</ul>
</li>
<li><p>新增博文信息的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">       <span class="comment">//获取登录用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="comment">//保存blog</span></span><br><span class="line">       blog.setUserId(userId);</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">save</span> <span class="operator">=</span> save(blog);</span><br><span class="line">       <span class="keyword">if</span> (save) &#123;</span><br><span class="line">           <span class="comment">//查询笔记作者的所有粉丝</span></span><br><span class="line">           List&lt;Follow&gt; follows = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, userId).list();</span><br><span class="line">           <span class="keyword">for</span> (Follow follow : follows) &#123;</span><br><span class="line">               <span class="comment">//获取粉丝id</span></span><br><span class="line">               <span class="type">Long</span> <span class="variable">followUserId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">               <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.FEED_KEY + followUserId;</span><br><span class="line">               <span class="comment">//推送</span></span><br><span class="line">               stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//推送笔记的id给所有粉丝</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//返回blog id</span></span><br><span class="line">       <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>滚动分页的实现：<strong>简单来说，每次查询，我们都记住上一次查询的score的最小值，然后从小于最小值的第一个值进行查询</strong>，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.FEED_KEY + userId;</span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet().reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2L</span>);</span><br></pre></td></tr></table></figure>

<p>对应的redis指令是<code>ZrevrangeByScore 【key]】【上次查到的score最小值】【score的最小值】 withscores Limit 【偏移量，这里为1】，【count，页面大小】</code>。</p>
<p>翻译一下就是：以上次查询的最小值作为本次查询range的max，min为0，limit指定从上次查询的最小值的下一个元素（为0的话是查询&lt;&#x3D;最大值的的元素，会造成重复，所以这里应该为1，查询&lt;&#x3D;最大值的最近的元素）进行查询（根据偏移量来的），总共查询count个元素。</p>
<p>这里计算最小时间minTime和偏移量offset的代码也很巧妙：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ofCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        List&lt;String&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">        <span class="comment">//3. 解析收件箱：blogId ,score ,minTime(时间戳)</span></span><br><span class="line">        <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; typedTuple : typedTuples) &#123;</span><br><span class="line">            ids.add(typedTuple.getValue());</span><br><span class="line">            <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> typedTuple.getScore().longValue();</span><br><span class="line">            <span class="keyword">if</span> (time == minTime) &#123;</span><br><span class="line">                ofCount ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ofCount = <span class="number">1</span>;</span><br><span class="line">                minTime = time;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>概括一下就是，ofCount是用来计算score值等于最小时间的元素个数，后续作为offset封装到对象中，time在遍历过程中不断进行更新，遍历完就是取得了最小值，把它付给minTime，封装到对象中去。</strong></p>
<p>在查询后，又会将本次查询的最小值和偏移量封装到ScrollResult对象中，供下一次查询使用。</p>
<p>总体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 获取当前登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//2. 获取收件箱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.FEED_KEY + userId;</span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet().reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2L</span>);</span><br><span class="line">        <span class="comment">// 非空判断</span></span><br><span class="line">        <span class="keyword">if</span> (typedTuples.isEmpty() || typedTuples == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ofCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        List&lt;String&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">        <span class="comment">//3. 解析收件箱：blogId ,score ,minTime(时间戳)</span></span><br><span class="line">        <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; typedTuple : typedTuples) &#123;</span><br><span class="line">            ids.add(typedTuple.getValue());</span><br><span class="line">            <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> typedTuple.getScore().longValue();</span><br><span class="line">            <span class="keyword">if</span> (time == minTime) &#123;</span><br><span class="line">                ofCount ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ofCount = <span class="number">1</span>;</span><br><span class="line">                minTime = time;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">        <span class="comment">//4. 根据id查询blog</span></span><br><span class="line">        List&lt;Blog&gt; blogs = blogService.query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;order By field (id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">        <span class="comment">//4.1 查询blog用户，blog是否被点赞过</span></span><br><span class="line">        <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">            queryBlogUser(blog);</span><br><span class="line">            isBlogLiked(blog);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//封装并返回</span></span><br><span class="line">        <span class="type">ScrollResult</span> <span class="variable">scrollResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">        scrollResult.setList(blogs);</span><br><span class="line">        scrollResult.setMinTime(minTime);</span><br><span class="line">        scrollResult.setOffset(ofCount);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(scrollResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（7）优惠券秒杀"><a href="#（7）优惠券秒杀" class="headerlink" title="（7）优惠券秒杀"></a>（7）优惠券秒杀</h4><ul>
<li><p><strong>全局ID生成器</strong>：是一种在分布式系统下用来生成全局唯一id的工具，满足以下特性</p>
<ul>
<li><strong>唯一性</strong></li>
<li>高可用</li>
<li>高性能</li>
<li><strong>递增性</strong></li>
<li><strong>安全性</strong></li>
</ul>
</li>
<li><p>我们生成的ID由以下部分组成，订单ID就使用了其生成的ID。</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240329215303515.png" alt="image-20240329215303515"></p>
</li>
<li><p>具体的工具类代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prefix是业务的前缀，我们可以为不同的业务使用不同的全局ID</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span>&#123;</span><br><span class="line">        <span class="comment">//1. 生成时间戳（31位）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timeStamp</span> <span class="operator">=</span> LocalDateTime.now().toEpochSecond(ZoneOffset.UTC) - BEGIN_TIMESTAMP;</span><br><span class="line">        <span class="comment">//2. 生成序列号</span></span><br><span class="line">        <span class="comment">//2.1 获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">//2.2 自增长（添加了date是为了防止key自增到上限，并且方便统计）</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line">        <span class="comment">//3. 拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> (timeStamp &lt;&lt; COUNT_BITS) | count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意拼接这一步，<code>timeStamp &lt;&lt;  32</code>是先让时间戳左移32位，然后与序列号进行或运算</strong></p>
</li>
<li><p><strong>乐观锁解决超卖问题</strong></p>
<ul>
<li><p>超卖问题产生的原因：线程1查询库存，发现余额为1并且大于0，可以进行扣减，但是在线程1进行扣减库存操作之前，有一个线程2，它也查询库存，发现为1(因为线程1还没开始扣减)，于是它也进行扣减，这就导致了1个库存却被两个线程消费了，这就是超卖问题。</p>
</li>
<li><p><strong>乐观锁&amp;悲观锁</strong>：</p>
<ul>
<li>悲观锁认为线程安全问题一定会发生，因此在<strong>操作数据之前都要先获取锁</strong>，确保线程串行执行。（例如Synchronize、Lock都属于悲观锁）；</li>
<li>乐观锁则认为，线程安全问题不一定会发生，因此不进行加锁，只是<strong>在数据进行更新的时候去判断有没有其他线程对数据做了修改</strong>。如果没有修改，则认为是安全的，自己可以更新数据；如果已经被其他线程修改，说明发生了安全问题，此时可以重试或者异常。</li>
</ul>
</li>
<li><p>悲观锁实现比较简单，操作前获取锁，操作结束后才释放锁，让多个线程串行执行，但是你让并发线程串行执行，效率会十分低下。</p>
</li>
<li><p><strong>乐观锁设计：</strong></p>
<ul>
<li><p>第一种设计：<strong>添加版本号version</strong>，在扣减操作前会读取库存stack和版本号version，在进行扣减时，要检查version的值是不是最开始查到的值，如果是的话，才进行stack的扣减，并且让version自增；如果version与最开始查到的值不同，说明有其他线程修改过库存了，此时应该进行重试操作。</p>
<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240330150853650.png" alt="image-20240330150853650" style="zoom: 50%;" />
</li>
<li><p>第二种设计：<strong>CAS法</strong>，这里我们直接对比库存值，在进行扣减操作前会查询库存stack值，在进行扣减操作时，检查statck值（<strong>内存中的值V</strong>）是否与最开始读到的值（<strong>预期原始值A</strong>）相同，如果相同则可以进行扣减，反之，不同的话说明有其他线程更改过库存了，此时应该进行重试工作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">什么是CAS机制（compare and swap）</span><br><span class="line">CAS算法的作用：解决多线程条件下使用锁造成性能损耗问题的算法，保证了原子性，这个原子操作是由CPU来完成的</span><br><span class="line">CAS的原理：CAS算法有三个操作数，通过内存中的值（V）、预期原始值（A)、修改后的新值。</span><br><span class="line">（1）如果内存中的值和预期原始值相等， 就将修改后的新值保存到内存中。</span><br><span class="line">（2）如果内存中的值和预期原始值不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作，直到重试成功。</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建订单功能采用CAS法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)<span class="comment">//set stock = stock -1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>,voucherId).eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock()) <span class="comment">//where id = ? and stock =?</span></span><br><span class="line">                .update();</span><br></pre></td></tr></table></figure>

<p>上面代码的意思就是，在执行update的时候，再次检查stock值和当前获取到的stack值是否相同。<strong>但是这样修改后，我们发现成功率很低，在开启200个线程执行的情况下，100张只卖出去了23张。</strong>原因就在于，在并发环境下，stock值前后匹配的成功率很小，这导致大量的线程购买失败了。</p>
<p>因此对上面的代码继续修改，在扣减前查询stack值是否大于0，如果大于0，当前线程就可以进行扣减库存的操作了，如果等于0，说明有其他线程已经把库存扣完了，于是返回false表示库存扣减失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)</span><br><span class="line">                .update();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>一人一单问题</strong></p>
<ul>
<li><p>需要修改业务逻辑，一名用户只能购买一张优惠券，防止黄牛刷券。</p>
</li>
<li><p>具体业务流程如下：</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240330154534430.png" alt="image-20240330154534430"></p>
</li>
<li><p>于是修改代码如下：</p>
<ul>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;查询订单<br>    int count &#x3D; query().eq(“user_id”, userId).eq(“voucher_id”, voucherId).count();<br>    if (count &gt; 0) {<br>        return Result.fail(“不可重复下单！”);<br>    }<br>    &#x2F;&#x2F; 5.扣减库存<br>    boolean success &#x3D; seckillVoucherService.update()<br>            .setSql(“stock &#x3D; stock - 1”)<br>            .eq(“voucher_id”, voucherId).gt(“stock”, 0)<br>            .update();<br>    if (!success) {<br>        return Result.fail(“优惠券库存不足！”);<br>    }<br>    &#x2F;&#x2F; 6.创建订单<br>。。。。。。。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">**问题1**但是我们在测试的时候，发现问题并没有解决，原因就在于，在高并发环境下，多个线程查询该userID下的订单数count，都会得到0，从而都进行库存的扣减。导致没有实现一人一单。</span><br><span class="line">  </span><br><span class="line">那么自然考虑要加锁了，但是这里并不能用乐观锁方案，因为我们这里是新增数据操作，不是更新操作，数据一开始是不存在的。所以这里要使用悲观锁。</span><br><span class="line">  </span><br><span class="line">那么这里将查询订单到创建订单这个过程为一个方法，给这个方法加锁。</span><br><span class="line">  </span><br><span class="line">```java</span><br><span class="line">    @Transactional</span><br><span class="line">    public synchronized Result createVoucherOrder(Long voucherId) &#123;</span><br><span class="line">        // 一人一单</span><br><span class="line">        Long userId = UserHolder.getUser().getId();</span><br><span class="line">        //synchronized (userId.toString().intern()) &#123;</span><br><span class="line">        //查询订单</span><br><span class="line">        int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            return Result.fail(&quot;不可重复下单！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 5.扣减库存</span><br><span class="line">        boolean success = seckillVoucherService.update()</span><br><span class="line">                .setSql(&quot;stock = stock - 1&quot;)</span><br><span class="line">                .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0)</span><br><span class="line">                .update();</span><br><span class="line">        if (!success) &#123;</span><br><span class="line">            return Result.fail(&quot;优惠券库存不足！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 6.创建订单</span><br><span class="line">        long orderId = redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">        VoucherOrder voucherOrder = new VoucherOrder();</span><br><span class="line">        //6.1订单id</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        //6.2用户id</span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        //6.3优惠券id</span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        //7.保存订单</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        // 8.返回订单id</span><br><span class="line">        return Result.ok(orderId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题二，缩小锁范围：</strong>但是在方法上使用synchronized锁的是当前this对象，导致每个用户到这里都要获取这一把锁，让这个方法串行执行了，效率会极低。我们只打算锁当前用户，不让他多次创建订单就可以了，那么这里我们synchronized（user ID.toString()）就可以了。</p>
<p><strong>问题三，但是用了toString还是不好使，因为toString底层都是new了一个新的对象，所以锁无法起作用。</strong>于是我们再次修改为<code>synchronized(userID.toString().intern())</code>，intern会从字符串常量池中寻找值一样的引用并返回。</p>
<p><strong>问题四，但是，我们这里将锁定义在了方法内部，因此在锁释放之后，创建订单的事务才会提交。而在锁释放到事务提交这段时间内（这个时候，由于事务尚未提交，数据库还没更新，如果此时有另外的线程进入的话，依然查不到count，会继续进行订单创建，这是我们不能允许的），因此synchronize不能放在方法内。</strong>于是就将代码改造成了下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 查询优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> seckillVoucher.getBeginTime();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> seckillVoucher.getEndTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LocalDateTime.now().isBefore(beginTime)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀活动尚未开始！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">        <span class="keyword">if</span> (LocalDateTime.now().isAfter(endTime)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀活动已经结束！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line">        <span class="keyword">if</span> (stock &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;优惠券已售空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意这里，这里是我们修改的地方</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">     *  <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;        </span><br><span class="line">     *     <span class="keyword">return</span> createVoucherOrder(voucherId);</span><br><span class="line">     *  &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题五，但是这里还存在一个事务的问题</strong>，这里return的实际上是this.createVoucherOrder()方法，而spring事务生效是因为spring对当前对象做了动态代理，用的是代理对象做事务处理，而这里用this，是一个非代理对象，显然事务是不会生效的。</p>
<p>解决方案就是，拿到当前对象的代理对象。确保事务生效。</p>
<p><strong>问题六，在分布式情况下，上面的一人一单解决方法不好使了。这里引出》》》》分布式锁！！</strong></p>
<p>问题的原因如下，分布式情况下，有多个jvm存在，不同的jvm有多个锁监视器，这会导致每个jvm都会成功一个。</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240330215139748.png" alt="image-20240330215139748"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>分布式锁：</strong></p>
<ul>
<li>分布式锁就是满足分布式系统或集群模式下多进程可见并且互斥的锁。</li>
<li>分布式锁应有如下功能特性：<strong>多进程可见、互斥、高可用、高性能、安全性</strong></li>
<li>分布式锁的实现：</li>
<li><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240330220500961.png" alt="image-20240330220500961"></li>
</ul>
</li>
<li><p><strong>Redis分布式锁误删问题：</strong></p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240331145142125.png" alt="image-20240331145142125"></p>
<p><strong>问题：</strong>线程1在获取到锁，在进行自己的业务逻辑的时候却发生了阻塞，阻塞时间甚至超过了我们预设的redis锁超时时间。这导致锁提前被释放掉了，这时线程2自然而然获得了锁，在它执行业务逻辑的时候，<strong>线程1的业务完成了，于是线程1二话不说，进行释放锁，</strong>于是线程2的锁也没了，线程3就能获取锁执行自己的业务了………</p>
<p><strong>解决方法：</strong>在释放锁的时候判断一下线程标识是否一致，如果一致，就释放锁，不一致就不释放。（很好判断，因为我们setNx的value就是线程id，但是在集群模式下，多个jvm会出现线程id的重复，因此我们存放的标识也要尽可能的唯一，这里采用UUID + 线程ID的方式。）</p>
</li>
<li><p><strong>分布式锁的原子性问题</strong>：</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240331152244051.png" alt="image-20240331152244051"></p>
<p>上面我们解决了分布式锁误删问题，但是在并发情况下还是会存在隐患。</p>
<p><strong>问题：</strong>线程1在获取锁执行完业务进行释放的时候，由于我们释放锁的过程分为两步（1）判断线程标识是否一致（2）delete KEY，<strong>而在完成第一步后释放锁之前，假设线程1阻塞了（很有可能发生，比如垃圾回收会阻塞所有线程），等到锁被超时释放掉的时候，</strong>线程2可以趁虚而入了，它可以获取锁并执行自己的业务，<strong>而在它执行业务的时候，线程1恢复了，由于线程1已经进行了一致性判断，因此线程1会直接把锁释放掉，</strong>加入此时又来一个线程3，它就又可以执行自己的业务了。</p>
<p><strong>解决方法：</strong>这里我们使用lua脚本来保证释放锁的原子性。具体如下所示：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取锁中的线程标识</span></span><br><span class="line"><span class="keyword">local</span> id = redis.call(<span class="string">&#x27;get&#x27;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 判断是否一致</span></span><br><span class="line"><span class="keyword">if</span> (ARGV[<span class="number">1</span>] == id)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这里，为了避免每次释放锁的时候都要用IO流读脚本，这里采用静态代码块的方式，直接预加载我们的脚本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了避免每次释放锁都要重新加载脚本浪费性能，所以我们选择使用静态代码块进行初始化加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，在类初始化后，我们的脚本也完成了预加载。</p>
</li>
<li><p><strong>分布式锁工具类SimpleRedisLock</strong></p>
<p>在解决了锁误删问题以及原子性问题后，我们的工具类如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">//获取当前线程标识</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX +Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(isSuccess);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 调用lua脚本, 参数列表： lua脚本，key,args</span></span><br><span class="line">        stringRedisTemplate.execute(UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX + <span class="built_in">this</span>.name),ID_PREFIX +Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>Redis分布式锁优化</strong></p>
<ul>
<li>基于setnx实现的分布式锁存在下面的问题<strong>（引出Redission）</strong>：<ul>
<li><strong>不可重入：</strong>同一个线程无法多次获取同一把锁。</li>
<li><strong>不可重试</strong>： 获取锁只尝试1次就返回了，没有重试机制。</li>
<li><strong>超时释放</strong>：锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致所释放，存在安全隐患。</li>
<li><strong>主从一致性：</strong>如果redis提供了主从集群，主从同步存在延迟，当主宕机时，如果从同步主中锁数据，则会出现锁失效。</li>
</ul>
</li>
<li><strong>Redission：</strong>redission是一个在redis基础上实现的java驻内存数据网格。它<strong>不仅提供了一系列的分布式地常用Java对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</strong>（redis下各种分布式工具集合）</li>
</ul>
</li>
<li><p><strong>Redission入门：</strong></p>
<ul>
<li><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240401141124091.png" alt="image-20240401141124091"><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240401142605710.png" alt="image-20240401142605710"><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240401143311866.png" alt="image-20240401143311866"><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240401150536638.png" alt="image-20240401150536638"></li>
<li><strong>Redission分布式锁原理：</strong><ul>
<li>可重入：利用Hash结构，记录线程id和重入次数</li>
<li>可重试：利用信号量和PubSub功能实现等待、唤醒、获取锁失败的重试机制</li>
<li>超时续约：利用watchDog，每隔一段时间（releaseTime &#x2F; 3），重置超时时间</li>
</ul>
</li>
<li><strong>Redission分布式锁主从一致性问题（联锁MultiLock）：</strong><ul>
<li>一般redis集群会设置主从模式，主节点用来写，从节点用来读，同时设置主从同步机制保证数据的一致性。但是如果我们从主节点获取锁，但是在主从同步过程中主节点宕机，这就会导致新的主节点没有锁的内容，产生并发安全问题。</li>
<li>Redission的解决方法是，不区分主从节点，所有节点同一级别，互不联系。在获取锁的时候，从每个redis节点获取锁，并且，只有当所有节点都能获取锁的时候该线程才能获取锁，这样就解决了分布式锁主从一致性问题。<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240401153807053.png" alt="image-20240401153807053"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>总结：</strong></p>
<ul>
<li>（1）不可重入Redis分布式锁:<ul>
<li>原理：利用setNx的互斥性；利用ex避免死锁；释放锁时判断线程标识。</li>
<li>缺陷：不可重入、无法重试、锁超时失效。</li>
</ul>
</li>
<li>（2）可重入的Redis分布式锁：<ul>
<li>原理：利用hash结构，记录线程标识可重入次数；利用watchDog延续锁时间；利用信号量控制锁充实等待</li>
<li>缺陷：redis宕机引起锁失效问题</li>
</ul>
</li>
<li>（3）Redission的multilock:<ul>
<li>原理：多个独立的redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li>
<li>缺陷：运维成本高、实现复杂</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>异步秒杀思路</strong></p>
<ul>
<li><p>在我们使用了分布式锁改造后的优惠券秒杀过程可以概括为如下几步：</p>
<ul>
<li>根据传入的voucher ID查询优惠券信息（<strong>访问数据库</strong>）；</li>
<li>判断秒杀是否开始或者已经结束（访问优惠券属性）</li>
<li>判断库存是否充足（访问优惠券属性）</li>
<li>获取当前用户id，查询当前用户是否已经购买过该优惠券（<strong>访问数据库</strong>）</li>
<li>如果符合一人一单，那么进行库存扣减（<strong>访问数据库</strong>）</li>
<li>创建订单信息并持久化（<strong>访问数据库</strong>）</li>
</ul>
</li>
<li><p><strong>该过程涉及4次数据库访问，串行执行的时候，会相当消耗时间，从而造成效率的降低，因此需要对整个流程进行异步化改造。</strong></p>
</li>
<li><p>这里，将判断秒杀库存和校验一人一单的功能交给redis来做，开启新的线程来完成那些需要访问数据库的操作。redis和tomcat之间通过一个消息队列来进行消息传递，当库存充足并且通过一人一单的校验后，redis向消息队列中发布消息，包含用户id，优惠券id，订单id；tomcat在接收到消息队列中的信息后，访问数据库，完成订单的创建。</p>
</li>
<li><p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240402140309308.png" alt="image-20240402140309308"></p>
</li>
<li><p><strong>缓存设计：</strong>对于判断秒杀库存的缓存设计，直接使用string结构就可以；而对于一人一单的校验，这里我们使用set结构来保存。1是因为同一张id的优惠券可以被多个用户购买，2是这些value不能有重复的，因此选用set结构正合适。</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240402141239535.png" alt="image-20240402141239535"></p>
</li>
<li><p>使用lua脚本来保证我们使用缓存进行库存判断和一人一单校验时的原子性：</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240402141618424.png" alt="image-20240402141618424"></p>
</li>
<li><p>整个工作流程如下：</p>
<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240402141928196.png" alt="image-20240402141928196" style="zoom:67%;" />
</li>
<li><p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//1. 执行lua脚本</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">               SECKILL_SCRIPT,</span><br><span class="line">               Collections.emptyList(),</span><br><span class="line">               voucherId.toString(), userId.toString(), String.valueOf(orderId));</span><br><span class="line">       <span class="comment">//2.判断结果，</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">       <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//2.1 不为0，代表没有</span></span><br><span class="line">           <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足！&quot;</span> : <span class="string">&quot;不能重复下单！&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">// 生成订单id</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">// 添加阻塞队列</span></span><br><span class="line">    .......</span><br><span class="line">    <span class="comment">//3.返回订单id</span></span><br><span class="line">       <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用阻塞队列的方式完成异步下单 有一个很重要的缺点，那就是<strong>阻塞队列使用的是jvm内存，在高并发情况下会有无数的对象放在阻塞队列中，这可能会导致内存的溢出；同时，由于内容都是存在于内存中，如果发生宕机，内存中的数据发生丢失，会出现数据的安全问题</strong>（引出消息队列）。</p>
</li>
<li><p>基于PubSub的消息队列的优缺点：</p>
<ul>
<li>优点：采用发布订阅模型，支持多生产，多消费</li>
<li>缺点：不支持持久化；无法避免消息丢失；消息堆积有上限，超出时数据丢失</li>
</ul>
</li>
<li><p><strong>基于Stream的消息队列–单消费模式：</strong></p>
<ul>
<li>stream是redis5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列</li>
<li>stream中的消息读完不会删除。</li>
<li><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240403140103440.png" alt="image-20240403140103440"></li>
<li><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240403140208717.png" alt="image-20240403140208717"></li>
<li><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240403140306245.png" alt="image-20240403140306245"></li>
<li><strong>阻塞方式的一个bug：</strong>当我们指定起始id为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能读取到最新的一条，会出现漏读消息的问题。</li>
<li><strong>总结，Stream类型的消息队列的xRead命令特点如下：</strong><ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>基于Stream的消费队列–消费者组</strong></p>
<ul>
<li><strong>消费者组：</strong>将多个消费者划分到一个组中，监听同一个队列。具备以下特点：<ul>
<li><strong>消息分流：</strong>队列中的消息会分流给组内的不同消费者，而不是重复的消费，从而加快消息处理的速度</li>
<li><strong>消息标识：</strong>消费者组会维护一个标识，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标识之后读取消息。确保每一个消息都会被消费</li>
<li><strong>消息确认：</strong>消费者获取消息后，消息处于pending状态，并存入一个pending-List。当处理完成后需要XACK来确认消息，标记消息已处理，才会从pendingList中移除。</li>
</ul>
</li>
<li><strong>Stream类型消息队列的XREADGROUP命令特点：</strong><ul>
<li>消息可回溯</li>
<li>可以多消费者争抢消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消息漏读的风险</li>
<li>有消息确认机制，保证消息至少被消费一次</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>基于Stream消息队列实现</strong></p>
<ul>
<li><p>流程变更如下：</p>
<ul>
<li>创建一个stream类型的消息队列，命名为stream.orders</li>
<li>修改之前的秒杀下单lua脚本，在认定有抢购资格后，直接向stream.order中添加消息，内容包含voucherID、user ID、orderID</li>
<li>项目启动时，开启一个线程任务，尝试获取stream.order中的信息，完成下单</li>
</ul>
</li>
<li><p>修改后的Lua脚本：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--参数列表</span></span><br><span class="line"><span class="comment">--优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">--用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">--订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">--数据key</span></span><br><span class="line"><span class="comment">--库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">--订单key(这里的orderKey代表的是：该优惠券下的所有订单，它是一个集合的key)</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">--3.脚本业务</span></span><br><span class="line"><span class="comment">--3.1判断库存是否充足 get stockkey</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>,stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">--3.2 库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--判断用户是否下单 sismember orderKey userId</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">--3.3 存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--3.4 扣减库存，</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>,stockKey,<span class="number">-1</span>)</span><br><span class="line"><span class="comment">--3.5 下单，保存用户(将用户id加入到以orderKey 为key的集合中)</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>,orderKey,userId)</span><br><span class="line"><span class="comment">--3.6 发送消息到消息队列中，XADD stream.orders * k1 v1 k2 v2....</span></span><br><span class="line">redis.call(<span class="string">&quot;XADD&quot;</span>,<span class="string">&quot;stream.orders&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;userId&quot;</span>,userId,<span class="string">&quot;voucherId&quot;</span>,voucherId,<span class="string">&quot;id&quot;</span>,orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改后的，使用stream的订单处理线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;stream.orders&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//1.获取消息队列中的订单信息</span></span><br><span class="line">                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                            Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                            StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                            StreamOffset.create(queueName, ReadOffset.lastConsumed())</span><br><span class="line">                    );</span><br><span class="line">                    <span class="comment">//2.判断消息获取是否成功</span></span><br><span class="line">                    <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                        <span class="comment">//2.1 如果消息获取失败，说明没有消息，继续进行下一次循环</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//2.2 如果消息获取成功，对消息进行处理</span></span><br><span class="line">                    <span class="comment">// 解析list中的订单信息</span></span><br><span class="line">                    MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                    Map&lt;Object, Object&gt; map = record.getValue();</span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                    <span class="comment">//对消息进行处理,即创建订单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                    <span class="comment">//3. ACK确认</span></span><br><span class="line">                    stringRedisTemplate.opsForStream().acknowledge(queueName, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;订单消息处理异常！&quot;</span>, e);</span><br><span class="line">                    <span class="comment">//4.消息处理异常，说明存在被读取但未被ack的订单消息</span></span><br><span class="line">                    handlePendingList();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="面试相关问题"><a href="#面试相关问题" class="headerlink" title="面试相关问题"></a>面试相关问题</h1><h2 id="1-项目里为什么要用消息队列："><a href="#1-项目里为什么要用消息队列：" class="headerlink" title="1. 项目里为什么要用消息队列："></a>1. 项目里为什么要用消息队列：</h2><h2 id="2-请求很多，消息堆积处理不过来了如何应对"><a href="#2-请求很多，消息堆积处理不过来了如何应对" class="headerlink" title="2. 请求很多，消息堆积处理不过来了如何应对"></a>2. 请求很多，消息堆积处理不过来了如何应对</h2><h2 id="3-用户在消息堆积时以为卡了，多次请求怎么处理"><a href="#3-用户在消息堆积时以为卡了，多次请求怎么处理" class="headerlink" title="3. 用户在消息堆积时以为卡了，多次请求怎么处理"></a>3. 用户在消息堆积时以为卡了，多次请求怎么处理</h2><h2 id="4-项目都有哪些表"><a href="#4-项目都有哪些表" class="headerlink" title="4. 项目都有哪些表"></a>4. 项目都有哪些表</h2><h2 id="5-超卖问题怎么解决？"><a href="#5-超卖问题怎么解决？" class="headerlink" title="5. 超卖问题怎么解决？"></a>5. 超卖问题怎么解决？</h2><h2 id="5-秒杀场景下扣减库存太慢了怎么解决"><a href="#5-秒杀场景下扣减库存太慢了怎么解决" class="headerlink" title="5. 秒杀场景下扣减库存太慢了怎么解决"></a>5. 秒杀场景下扣减库存太慢了怎么解决</h2><h2 id="7-Redis大key怎么解决？"><a href="#7-Redis大key怎么解决？" class="headerlink" title="7. Redis大key怎么解决？"></a>7. Redis大key怎么解决？</h2><h2 id="8-什么是热Key"><a href="#8-什么是热Key" class="headerlink" title="8. 什么是热Key"></a>8. 什么是热Key</h2><h2 id="9-如何解决热key问题"><a href="#9-如何解决热key问题" class="headerlink" title="9. 如何解决热key问题"></a>9. 如何解决热key问题</h2><h2 id="10-短信登录的短信怎么发送的"><a href="#10-短信登录的短信怎么发送的" class="headerlink" title="10.  短信登录的短信怎么发送的"></a>10.  短信登录的短信怎么发送的</h2><h2 id="11-项目的拦截器详细讲讲"><a href="#11-项目的拦截器详细讲讲" class="headerlink" title="11. 项目的拦截器详细讲讲"></a>11. 项目的拦截器详细讲讲</h2><h2 id="12-怎么保存验证码"><a href="#12-怎么保存验证码" class="headerlink" title="12. 怎么保存验证码"></a>12. 怎么保存验证码</h2><h2 id="13-项目里存在redis里的key的格式，存的什么"><a href="#13-项目里存在redis里的key的格式，存的什么" class="headerlink" title="13.项目里存在redis里的key的格式，存的什么"></a>13.项目里存在redis里的key的格式，存的什么</h2><h2 id="14-如何标识用户"><a href="#14-如何标识用户" class="headerlink" title="14. 如何标识用户"></a>14. 如何标识用户</h2><h2 id="15-项目的权限刷新什么意思"><a href="#15-项目的权限刷新什么意思" class="headerlink" title="15.项目的权限刷新什么意思"></a>15.项目的权限刷新什么意思</h2><h2 id="16-旁路缓存机制具体解决的什么场景"><a href="#16-旁路缓存机制具体解决的什么场景" class="headerlink" title="16. 旁路缓存机制具体解决的什么场景"></a>16. 旁路缓存机制具体解决的什么场景</h2><h2 id="17-更新缓存失败了怎么办"><a href="#17-更新缓存失败了怎么办" class="headerlink" title="17 更新缓存失败了怎么办"></a>17 更新缓存失败了怎么办</h2><h2 id="重试的时候，缓存中的错数据被访问多次了，怎么解决"><a href="#重试的时候，缓存中的错数据被访问多次了，怎么解决" class="headerlink" title="重试的时候，缓存中的错数据被访问多次了，怎么解决"></a>重试的时候，缓存中的错数据被访问多次了，怎么解决</h2><h2 id="项目为什么要加个消息队列"><a href="#项目为什么要加个消息队列" class="headerlink" title="项目为什么要加个消息队列"></a>项目为什么要加个消息队列</h2><h2 id="抢优惠券没有及时处理怎么办"><a href="#抢优惠券没有及时处理怎么办" class="headerlink" title="抢优惠券没有及时处理怎么办"></a>抢优惠券没有及时处理怎么办</h2><h2 id="抢优惠券处理完了如何通知用户"><a href="#抢优惠券处理完了如何通知用户" class="headerlink" title="抢优惠券处理完了如何通知用户"></a>抢优惠券处理完了如何通知用户</h2><h2 id="Redis的Zset"><a href="#Redis的Zset" class="headerlink" title="Redis的Zset"></a>Redis的Zset</h2><h2 id="Zset的范围查询的时间复杂度是多少"><a href="#Zset的范围查询的时间复杂度是多少" class="headerlink" title="Zset的范围查询的时间复杂度是多少"></a>Zset的范围查询的时间复杂度是多少</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://shadiaoyu.github.io/2024/02/27/%E5%85%AB%E8%82%A1%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/02/27/%E5%85%AB%E8%82%A1%E6%96%87/" class="post-title-link" itemprop="url">八股文</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-27 19:16:58" itemprop="dateCreated datePublished" datetime="2024-02-27T19:16:58+08:00">2024-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-08-31 21:43:27" itemprop="dateModified" datetime="2024-08-31T21:43:27+08:00">2024-08-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、java基础"><a href="#一、java基础" class="headerlink" title="一、java基础"></a>一、java基础</h1><h2 id="8种基本数据类型"><a href="#8种基本数据类型" class="headerlink" title="8种基本数据类型"></a>8种基本数据类型</h2><p>byte（8位，默认0B）、short（16位，默认0）、int（32位，默认0）、long（64位，默认0L）、float（32位，默认0.0f）、double（64位，默认0.0d）、char（16位，默认值\u0000）、boolean（jvm实现相关，一般情况下为1个字节，默认false）</p>
<h2 id="包装类型的常量池技术"><a href="#包装类型的常量池技术" class="headerlink" title="包装类型的常量池技术"></a><strong>包装类型的常量池技术</strong></h2><p>Byte、Short、Integer、Long这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据。Character 创建了数值在 [0,127] 范围的缓存数据，Boolean直接返回True或False。</p>
<p><strong>两种浮点类型的包装类Float、Double并没有实现包装类技术。</strong></p>
<p><strong>所有整型包装类对象之间值的比较，全部使用equals方法进行比较。</strong></p>
<p>我们以 <code>int与Integer</code> 作为例子，看下”&#x3D;&#x3D;”和”equal()”方法：</p>
<p>1）基本型和封装类型进行”&#x3D;&#x3D;”运算符的比较，封装类型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较。</p>
<p>2）两个Integer类型进行”&#x3D;&#x3D;”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，后面会说。</p>
<p>3）两个封装类型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true。</p>
<p>4）基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>
<h2 id="为什么要有包装类型？"><a href="#为什么要有包装类型？" class="headerlink" title="为什么要有包装类型？"></a>为什么要有包装类型？</h2><ul>
<li>Java是一种面向对象编程的语言，它要求所有的东西都是对象。然而，基本数据类型不是对象，它们是原始的数据类型，无法直接参与面向对象中的特性（比如继承、多态等）。因此引入了包装类型，使其能够像其它对象那样参与面向对象。</li>
<li><strong>泛型的支持</strong>，Java5引入了泛型，但是泛型要求类型参数必须是对象类型，不能是基本数据类型。因此，如果要在集合类中存储基本数据类型，就需要使用对应的包装类型。</li>
<li><strong>空值的支持</strong>，包装类型可以表示空值（null），而基本数据类型不行。</li>
<li>包装类型提供了一些额外的方法和功能，使得对基本数据类型的操作更加方便。</li>
</ul>
<h2 id="什么是自动拆装箱？原理？"><a href="#什么是自动拆装箱？原理？" class="headerlink" title="什么是自动拆装箱？原理？"></a><strong>什么是自动拆装箱？原理？</strong></h2><h2 id="遇到过自动拆箱引发的NPE（空指针）问题么？"><a href="#遇到过自动拆箱引发的NPE（空指针）问题么？" class="headerlink" title="遇到过自动拆箱引发的NPE（空指针）问题么？"></a>遇到过自动拆箱引发的NPE（空指针）问题么？</h2><ul>
<li>数据库的查询结果可能是null，因为自动拆箱，使用基本数据类型进行接受会有NPE风险。</li>
<li>在三目运算（b?x:y）中，当 x和y的类型不一致时，会发生自动拆箱，将x,y全部转换为基本类型，在自动拆箱的过程中有可能NPE。</li>
</ul>
<h2 id="String，StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？"><a href="#String，StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？" class="headerlink" title="String，StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？"></a>String，StringBuffer和StringBuilder的区别是什么？String为什么是不可变的？</h2><ul>
<li><p>可变性：String是不可变的，StringBuffer和StringBuilder是可变的；</p>
</li>
<li><p>线程安全性：String和StringBuffer是线程安全的，可以被多个线程安全的使用，StringBuilder不是线程安全的</p>
</li>
<li><p><strong>StringBuffer</strong>的性能相对较<strong>低</strong>，因为它的<strong>所有公共方法都是同步的</strong>，这意味着在多线程环境下会有性能开销。</p>
<p>StringBuilder的性能优于StringBuffer，但因为它的方法都不是同步的，因此在单线程环境下更有效。</p>
</li>
<li><p>String实现了serializable接口，可以被序列化。</p>
</li>
</ul>
<p>重载和重写的区别？**</p>
<ul>
<li><p>重载指的是在同一个类中，可以定义多个方法具有相同的名称但具有不同的参数列表（参数类型、参数个数、参数顺序）；</p>
<p>重写指的是子类重新定义（覆盖）了父类中具有相同名称、参数列表和返回类型的方法。</p>
</li>
<li><p>重载方法可以有不同的返回类型，但不能仅仅通过返回类型的不同来区分方法。</p>
</li>
<li><p>重写方法具有与被重写方法相同的方法签名，包括方法名、参数列表和返回类型。</p>
</li>
<li><p>重写方法不能降低访问权限，即子类中重写的方法的访问权限不能比父类中被重写的方法的访问权限更低。</p>
</li>
<li><p>重载是编译时多态，重写是运行时多态。</p>
</li>
<li><p>重写方法一定不能抛出新的检查异常，或者比被重写方法声明更加宽泛的检查型异常。</p>
</li>
</ul>
<p><strong>总结：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。</strong></p>
<h2 id="“-x3D-x3D-”和“equals-”的区别"><a href="#“-x3D-x3D-”和“equals-”的区别" class="headerlink" title="“&#x3D;&#x3D;”和“equals ()”的区别"></a>“&#x3D;&#x3D;”和“equals ()”的区别</h2><ul>
<li><p>对于<code>==</code>，比较的是值是否相等</p>
<ul>
<li>如果作用于基本数据类型的变量，则直接比较存储的值是否相等</li>
<li>如果作用于引用类型的变量，则比较的是所指向的对象的地址是否相等</li>
</ul>
<p>（其实&#x3D;&#x3D;比较的不管是基本数据类型还是引用类型，比较的都是值，只是引用类型变量存储的是对象的地址。）</p>
</li>
<li><p>对于<code>equals()</code>方法，根据是否重写equals方法，分为两种情况：</p>
<ul>
<li><strong>类没有重写equals方法：</strong>和&#x3D;&#x3D;的效果一样，都是比较引用类型的变量所指向的对象的地址。</li>
<li><strong>类重写了equals方法：</strong>比较两个对象的属性是否相等，如果它们的属性相等，则返回true（即，认为这两个对象相等。）</li>
<li><strong>特别注意的是，equals()方法不能作用于基本数据类型的变量。</strong></li>
</ul>
</li>
</ul>
<h2 id="Java反射？反射有什么优缺点？你是怎么理解反射的（为什么框架需要反射？）"><a href="#Java反射？反射有什么优缺点？你是怎么理解反射的（为什么框架需要反射？）" class="headerlink" title="Java反射？反射有什么优缺点？你是怎么理解反射的（为什么框架需要反射？）"></a>Java反射？反射有什么优缺点？你是怎么理解反射的（为什么框架需要反射？）</h2><ul>
<li>反射机制是在<strong>运行时</strong>，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意对象，都能调用它的任意一个方法。在Java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。这种动态获取的信息以及动态调用对象的方法的功能称为java的反射机制。</li>
<li>反射机制的优缺点：<ul>
<li>优点：能够运行时动态获取类的实例，提高灵活性和通用性；可以使用反射编写更加通用的代码，减少组件之间的耦合；反射是实现动态代理机制的基础。</li>
<li>缺点：使用反射基本是解释执行，对执行速度有影响。</li>
</ul>
</li>
<li>对于反射的理解（为什么框架需要反射）：<ul>
<li>通过反射，框架可以在不了解具体类结构的情况下，实现对用户代码的调用和管理，从而提高了框架的灵活性和可扩展性。</li>
<li>依赖注入：在依赖注入中，框架通常需要动态的创建和注入依赖对象，而这些对象的类型通常是在运行时才确定的。通过反射，框架可以实现自动化的依赖注入，无需显式地在代码中指定对象的类型。</li>
<li>AOP：框架通常使用动态代理和反射机制来实现AOP，以在运行时动态地植入切面逻辑。</li>
<li>框架通常需要处理大量的配置信息和元数据，以实现各种功能和行为。通过反射，框架可以动态地解析和处理配置文件和元数据，从而实现对各种不同情况的适应性。</li>
</ul>
</li>
</ul>
<h2 id="谈谈对Java注解的理解，解决了什么问题？"><a href="#谈谈对Java注解的理解，解决了什么问题？" class="headerlink" title="谈谈对Java注解的理解，解决了什么问题？"></a>谈谈对Java注解的理解，解决了什么问题？</h2><p>在写程序时，有时候想给一些特殊的地方加上标记，告诉编译器或者其他工具，这些地方有一些特殊的意义。Java注解就是一种在代码中添加特殊标记的方式，这些标记可以帮助编译器、工具或者其他程序理解你的代码，并可以触发一些额外的处理或行为。</p>
<ul>
<li>注解解决的问题：<ul>
<li>注解可以用于为代码提供更多的文档化信息，这样做可以增加代码的可读性和可维护性，使得代码更容易理解和使用。</li>
<li>注解可以用于在编译时对程序进行动态检查和验证，从而减少运行时错误。</li>
<li>注解可以用于驱动代码生成和自动化处理工具，从而减少重复性工作和提高开发效率（如通过编写自定义的注解，可以在编译时根据注解生成代码、配置文件或其他资源）</li>
<li>注解可以用于配置和扩展框架和库的行为，，使得它们更加灵活和可定制（如在类、方法或字段上添加注解配置框架的行为，以实现依赖注入，AOP等功能）</li>
</ul>
</li>
</ul>
<h2 id="Java泛型了解么？泛型的作用？什么是类型擦除？泛型有哪些限制？介绍一下常用的通配符？"><a href="#Java泛型了解么？泛型的作用？什么是类型擦除？泛型有哪些限制？介绍一下常用的通配符？" class="headerlink" title="Java泛型了解么？泛型的作用？什么是类型擦除？泛型有哪些限制？介绍一下常用的通配符？"></a>Java泛型了解么？泛型的作用？什么是类型擦除？泛型有哪些限制？介绍一下常用的通配符？</h2><ul>
<li>Java 泛型是一种在<strong>编译时</strong>进行类型检查和类型安全的机制，它允许程序员在编写代码时指定类、接口和方法可以支持任意类型（包括类、接口和原始类型）。Java 泛型提供了参数化类型的概念，使得代码可以更加通用和类型安全（可读性更好，更安全）。</li>
<li>Java 泛型的主要目的是<strong>在编译时捕获类型错误</strong>，并在编译时发现这些错误，从而避免在运行时抛出类型转换异常。它提供了编译时类型安全检查，使得代码更加健壮、可读性更高，并且减少了强制类型转换的需要。</li>
<li>Java 中的泛型是通过类型擦除实现的，这意味着在编译时会将泛型信息擦除掉，以确保与旧版 Java 代码的兼容性。这也导致了一些泛型相关的限制和局限性。（在运行时无法获取泛型类型的信息，在运行时，数组的元素类型必须是具体的非泛型类型）。</li>
<li>泛型的限制：<ul>
<li>类型擦除：这意味着在<strong>编译后，泛型信息会被擦除掉</strong>，因此在运行时无法获取泛型类型的具体信息，这限制了对泛型类型的操作和反射行为。</li>
<li>无法创建参数化类型的数组：例如<code>new ArrayList&lt;String&gt;[]  </code> 是非法的。这是因为在运行时无法获取泛型类型的信息。</li>
<li>在静态上下文（如静态方法或静态初始化块）中无法引用泛型类型的类型参数：因为类型参数是实例化时才确定的，而静态成员在类加载时就已经存在，此时无法确定类型参数的具体值。</li>
<li>不能使用基本类型作为类型参数。</li>
<li>无法实例化泛型类型的具体化对象。</li>
<li>无法创建泛型数组列表。</li>
<li>不能捕获泛型类型的异常：泛型类型不能用作catch块中的异常类型。</li>
<li>不能实例化泛型类型的数组。</li>
</ul>
</li>
</ul>
<ol start="12">
<li><h3 id="内部类了解么？匿名内部类了解么？"><a href="#内部类了解么？匿名内部类了解么？" class="headerlink" title="内部类了解么？匿名内部类了解么？"></a>内部类了解么？匿名内部类了解么？</h3><ul>
<li><p>内部类：如果A类需要直接访问B类中的成员，而B类又需要建立A类的对象，这时为了方便设计和访问，直接将A类定义在B类中就可以了。A类就称为内部类。</p>
</li>
<li><p><strong>内部类可以直接访问外部类的成员。但是外部类访问内部类时，必须先创建内部类对象</strong>。</p>
</li>
<li><p>内部类定义在外部类的成员位置上，可以使用一些成员修饰符如private，static。不同的修饰有不同的情况：</p>
<ul>
<li>默认修饰符default：直接访问内部类格式：<code>外部类名.内部类名 = 外部类对象.内部类对象(Outer.Inner in = new Outer.Inner())</code>。但这种方式不常见，因为定义内部类就是为了封装。想要获取内部类对象通常都需要通过外部类的方法来获取。这样可以对内部类对象进行控制。</li>
<li>私有修饰符private：通常内部类被封装，都会被私有化，因为封装性不让其他程序直接访问。</li>
<li>静态修饰符static：如果内部类被静态修饰，相当于外部类，会出现访问局限性，内部类只能访问外部类中的静态成员。<strong>注意：如果内部类中定义了静态成员，那么该内部类必须是静态的。</strong></li>
</ul>
</li>
<li><p>匿名内部类是内部类的简化写法。一般只使用一次就可以使用这种形式。匿名内部类其实就是一个匿名子类对象。想要定义匿名内部类，前提是<strong>内部类必须继承一个父类或者实现一个接口。</strong></p>
<p>匿名内部类的格式：<code>new 父类名&amp;接口名&#123;定义子类成员或者覆盖父类方法&#125;.方法</code>。</p>
</li>
<li><p>匿名内部类的使用场景：当函数的参数是接口类型引用的时候，如果接口中的方法不超过3个。可以通过匿名内部类来完成参数的传递。（换句话说就是，创建匿名内部类时，该类中封装的方法不要太多，最好两个或者两个以内）</p>
</li>
</ul>
</li>
<li><h3 id="BIO，NIO，AIO有什么区别？"><a href="#BIO，NIO，AIO有什么区别？" class="headerlink" title="BIO，NIO，AIO有什么区别？"></a>BIO，NIO，AIO有什么区别？</h3><ul>
<li><p>BIO（Blocking I&#x2F;O）：<strong>同步阻塞</strong>I&#x2F;O模式，数据的读取和写入必须阻塞在同一个线程内等待其完成。</p>
<ul>
<li>传统BIO（一请求一应答）：</li>
</ul>
  <img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240228203224835.png" alt="image-20240228203224835" style="zoom: 67%;" />

<p>  要使该IO模型能够同时处理多个客户端请求，就必须使用多线程，也就是说它在接收到客户端连接请求后为每一个客户端创建一个新的线程进行链路处理，处理完成后，通过输出流返回应答给客户端，线程销毁。<strong>这就是一请求一应答</strong>。但是这个连接如果不做任何事情的话就会造成不必要的线程浪费，这种情况可以通过使用<strong>线程池</strong>技术改善。</p>
<ul>
<li><p>伪异步I&#x2F;O：引入了线程池来缓解资源浪费问题，但本质上还是传统BIO同步阻塞那一套。无法从根本上解决问题。</p>
<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240228203836711.png" alt="image-20240228203836711" style="zoom: 67%;" /></li>
</ul>
</li>
<li><p>NIO（New I&#x2F;O）：NIO是一种<strong>同步非阻塞</strong>的IO模型，NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I&#x2F;O操作方法。 </p>
<ul>
<li>NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。</li>
<li>阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。</li>
<li>对于低负载、低并发的应用程序，可以使用同步阻塞I&#x2F;O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。</li>
</ul>
</li>
<li><p>NIO与IO的区别（<strong>阻塞与非阻塞，三大组件</strong>）：</p>
<ul>
<li><p>NIO是非阻塞的，IO是阻塞的</p>
</li>
<li><p><strong>Buffer</strong>：IO面向IO流（Stream oriented），而NIO面向缓冲区（Buffer oriented）。在面向流的IO中，可以将数据直接写入或者将数据直接读到Stream对象中。虽然Stream也有Buffer开头的扩展类，但是只是流的包装类，还是从流读到缓冲区，而NIO是直接读到Buffer中进行操作。</p>
<p>在NIO中，所有数据都是用缓冲区处理的，在读取数据时，它直接读缓冲区中的；在写数据时，它从缓冲区中读。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</p>
</li>
<li><p><strong>Channel</strong>：NIO通过Channel（通道）进行读写，通道是双向的，可读也可写。而流的读写是单向的。通道只能和Buffer交互。因为Buffer，通道可以异步的读写。</p>
</li>
<li><p><strong>Selectors</strong>： NIO有选择器，而IO没有。选择器用于使用单个线程处理多个通道，因此，他需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。因此，为了提高效率使用选择器是有效的。</p>
<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240228210012986.png" alt="image-20240228210012986" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>AIO（Asynchronous I&#x2F;O）：AIO也就是NIO 2。在Java7中引入了NIO 2，它是<strong>异步非阻塞</strong>的。异步IO是基于时间和回调机制实现的。AIO是异步IO的缩写，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。</p>
</li>
</ul>
</li>
</ol>
<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><h2 id="几种集合的数据结构："><a href="#几种集合的数据结构：" class="headerlink" title="几种集合的数据结构："></a>几种集合的数据结构：</h2><ul>
<li>HashMap：哈希表 + 链表 ，无序，允许键和值为null，线程不安全</li>
<li>LinkedHashMap： 哈希表 + 双向链表，保持插入顺序或访问顺序。</li>
<li>TreeMap： <strong>基于红黑树</strong>实现的<strong>有序</strong>Map</li>
<li>Hashtable：基于哈希表实现的map，线程安全</li>
<li>concurrentHashMap：基于哈希表实现的线程安全的 Map，支持高并发操作。</li>
<li>ArrayList：底层<strong>基于数组</strong></li>
<li>LinkedList：底层<strong>基于双向链表</strong></li>
</ul>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>1.7之前，数组 +链表</li>
<li>1.8之后，数组 + 链表 + 红黑树</li>
<li><strong>数组初始长度都为2的整数次幂</strong>，这是为了方便在进行取余时可以转化为位运算进而提升效率。</li>
</ul>
<h3 id="HashMap扩容机制"><a href="#HashMap扩容机制" class="headerlink" title="HashMap扩容机制"></a>HashMap扩容机制</h3><ul>
<li><p><strong>当元素个数大于容量 * 扩容因子（0.75）时，就会对数组进行扩容（扩容2倍）</strong>；</p>
<ul>
<li>假设原table长度为16，扩容后长度为32。hash值的每个二进制位用abcde来表示，那么，hash和新旧table按位与的结果，最<strong>后4位显然是相同的</strong>，<strong>唯一可能出现的区别就在第5位</strong>，也就是hash值的b所在的那一位，如果b所在的那一位是0，那么新table按位与的结果和旧table的结果就相同，反之如果b所在的那一位是1，则新table按位与的结果就比旧table的结果多了10000（二进制），而这个二进制10000就是旧table的长度16。<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240520213906849.png" alt="image-20240520213906849" style="zoom: 67%;" /></li>
<li>换言之，<strong>hash值的新散列下标是不是需要加上旧table长度，只需要看看hash值第5位是不是1就行了</strong>，位运算的方法就是hash值和10000（也就是旧table长度）来按位与，其结果只可能是10000或者00000。</li>
</ul>
</li>
<li><p><strong>当链表长度大于8时，就会将链表转换为红黑树</strong>；</p>
</li>
<li><p><strong>当链表长度小于6时，就会将红黑树退化为链表</strong>；</p>
<ul>
<li>之所以设置为6，是为了防止频繁进行链表和红黑树的转换。</li>
</ul>
</li>
</ul>
<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="volatile关键字："><a href="#volatile关键字：" class="headerlink" title="volatile关键字："></a>volatile关键字：</h2><p>volatile关键字保证了 <strong>可见性（一个线程对共享变量进行修改后，其他线程能立即看到这个修改）</strong> 和 <strong>有序性（程序执行的顺序与代码的顺序一致）</strong></p>
<p><strong>volatile如何保证可见性：</strong></p>
<ul>
<li>一个变量被声明为volatile时，<strong>线程在写入变量时</strong>， 不会立即把值缓存到寄存器或其他地方，而是<strong>会把值刷新回主内存。</strong></li>
<li>当其他线程<strong>读取到该共享变量</strong>，<strong>会从主存中获取最新值</strong>，而不是使用当前线程的本地内存中的值。</li>
</ul>
<p><strong>volatile如何保证有序性：</strong></p>
<ul>
<li><p>volatile通过<strong>限制指令重排序</strong>（编译器重排序 和 处理器重排序 这两种重排序）来保证有序性的。</p>
</li>
<li><p><strong>写操作</strong> 加的屏障是 阻止<strong>上方</strong>其它写操作越过屏障<strong>排到 volatile变量写之下</strong>；</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240507210723973.png" alt="image-20240507210723973"></p>
</li>
<li><p><strong>读操作</strong> 加的屏障是阻止 下方其它读操作越过屏障<strong>排到 volatile变量读之上</strong>；</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240507210744195.png" alt="image-20240507210744195"></p>
</li>
</ul>
<p><strong>volatile不能保证原子性，只能保证单次的读&#x2F;写操作具有原子性。</strong></p>
<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><h3 id="（1）synchronized的三种用法："><a href="#（1）synchronized的三种用法：" class="headerlink" title="（1）synchronized的三种用法："></a><strong>（1）synchronized的三种用法：</strong></h3><ul>
<li><strong>修饰实例方法</strong>：这种方式相当于 synchronized（this对象），进入同步代码块之前需要获得 当前对象实例的锁；</li>
<li><strong>修饰静态方法</strong>：这种用法会作用于类的所有对象实例，进入同步块之前要获得当前 class的锁；</li>
<li><strong>修饰代码块</strong>： synchronized(类.class) 表示进⼊同步 代码前要获得 当前 class 的锁；</li>
</ul>
<h3 id="（2）synchronized-怎么保持可见性的："><a href="#（2）synchronized-怎么保持可见性的：" class="headerlink" title="（2）synchronized 怎么保持可见性的："></a><strong>（2）synchronized 怎么保持可见性的：</strong></h3><ul>
<li>线程加锁前，清空工作内存中共享变量的值，从而从主存中读取最新的共享变量值；</li>
<li>线程加锁后，其他线程无法获取主存中的共享变量；</li>
<li>线程解锁前，会将最新的共享变量值刷新到主存中。</li>
</ul>
<h3 id="（3）synchronized-怎么保持有序性的："><a href="#（3）synchronized-怎么保持有序性的：" class="headerlink" title="（3）synchronized 怎么保持有序性的："></a><strong>（3）synchronized 怎么保持有序性的：</strong></h3><ul>
<li>synchronized同步的代码块，一次只能被一个线程拥有，所以synchronized保证<strong>同一时刻，代码是单线程执行的。</strong> <strong>因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不 会指令重排。</strong></li>
</ul>
<h3 id="（4）synchronized怎么实现可重入的："><a href="#（4）synchronized怎么实现可重入的：" class="headerlink" title="（4）synchronized怎么实现可重入的："></a><strong>（4）synchronized怎么实现可重入的：</strong></h3><ul>
<li>synchronized锁对象的时候有一个<strong>锁计数器，它会记录下线程获取锁的次数，在执行完代码块后，计数器 -1，直到计数器清零，就释放锁了。</strong></li>
</ul>
<h3 id="（5）synchronized的实现原理："><a href="#（5）synchronized的实现原理：" class="headerlink" title="（5）synchronized的实现原理："></a><strong>（5）synchronized的实现原理：</strong></h3><ul>
<li><p>synchronized<strong>修饰代码块</strong>的时候，JVM<strong>采用 monitor_enter 和 monitor_exit 两个指令来实现同步</strong>，<strong>monitor_enter 指向同步代码块的开始位置，monitor_exit指向同步代码块的结束位置</strong>。</p>
</li>
<li><p>synchronized<strong>修饰同步方法</strong>时，JVM<strong>采用 ACC_SYNCHRONIZED标记来实现同步</strong>，这个标识指明了该方法是一个同步方法。</p>
</li>
<li><p>monitor_enter、monitor_exit或者ACC_SYNCHRONIZED，其实<strong>都是基于对象的内置锁</strong> （Intrinsic Lock）或称为<strong>监视器锁</strong>（Monitor Lock）。<strong>每个对象都有一个内置锁，当一个线程获取了对象的内置锁时，其他线程必须等待该线程释放锁后才能获取锁</strong>。这样就保证了同一时间只有一个线程才能访问同步代码块或方法。</p>
</li>
<li><p>Java虚拟机是基于Monitor对象来实现重量级锁的。在hotspot虚拟机中，monitor是由ObjectMonitor实现的，其源码是C++语言编写的，ObjectMonitor的工作原理如下：</p>
<ul>
<li>ObjectMonitor有两个队列： waitset和 entryList。处于wait状态的线程，会被加入到waitSet；处于等待锁block状态的线程，会被加入到entryList中，等待被唤醒。</li>
<li>owner字段：其指向持有ObjectMonitor对象的线程。</li>
</ul>
<p><strong>具体过程如下</strong>：</p>
</li>
<li><p>当<strong>多个线程同时访问</strong>同步代码块时，首<strong>先会进入到EntryList中</strong>，然后通过<strong>CAS</strong>的方式尝试<strong>将Monitor中的owner字段设置为当前线程，同时count加一</strong>（锁计数器，获取锁时加1，释放锁时减1）。<strong>若</strong>发现<strong>之前owner的值就是指向当前线程的</strong>，<strong>recursions字段也需要加一</strong>（锁重入次数）。如果CAS尝试获取锁失败，则进入到<strong>EntryList</strong>中。</p>
</li>
<li><p>当<strong>获取锁的线程调用wait()<strong>方法，则会将owner设置为null，同时count减一，recursion减一，当前</strong>线程加入到waitSet</strong>中，等待被唤醒。</p>
</li>
<li><p>当前线程执行完同步代码块时，会释放锁，count减一，recursion减一。当recursions的值为0时，说明线程已经释放了锁。</p>
</li>
</ul>
<h3 id="（6）关于Synchronized关键字的一些其他内容："><a href="#（6）关于Synchronized关键字的一些其他内容：" class="headerlink" title="（6）关于Synchronized关键字的一些其他内容："></a>（6）关于Synchronized关键字的一些其他内容：</h3><ul>
<li>synchronized在发生<strong>异常的时候会自动释放占有的锁</strong>，因此<strong>不会发生死锁</strong>；</li>
<li>synchronized修饰的方法在抛出异常的时候，<strong>会自动释放锁</strong>。</li>
<li>synchronized实现的是<strong>非公平锁</strong>。</li>
</ul>
<h2 id="Synchronize-与-ReentrantLock之间的区别："><a href="#Synchronize-与-ReentrantLock之间的区别：" class="headerlink" title="Synchronize 与 ReentrantLock之间的区别："></a>Synchronize 与 ReentrantLock之间的区别：</h2><ul>
<li><strong>synchronized</strong> 是java语言的关键字，<strong>基于JVM实现</strong>；<strong>ReentrantLock</strong>是<strong>基于JDK</strong>的API层面实现的。</li>
<li><strong>性能差距</strong>：1.6锁优化之前，synchronized比不上reentrantLock，1.6开始，synchronized增加了适应性自旋、锁消除等，二者性能就差不多了。</li>
<li><strong>ReentrantLock实现了一些高级功能，比如等待可中断（当持有锁的线程长期不是放锁的时候，正在 等待的线程可以选择放弃等待，改为处理其他事情）、可实现公平锁、可实现选择性通知。</strong></li>
<li><strong>ReentrantLock需要手工声明来加锁和释放锁</strong>，一般跟finally配合释放锁。而 <strong>synchronized不用手动释放锁</strong>。</li>
<li><strong>ReentrantLock可以同时绑定多个Condition对象</strong></li>
<li><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240520214928221.png" alt="image-20240520214928221"></li>
</ul>
<h2 id="锁以及锁升级-无锁、偏向锁、轻量级锁、重量级锁"><a href="#锁以及锁升级-无锁、偏向锁、轻量级锁、重量级锁" class="headerlink" title="锁以及锁升级(无锁、偏向锁、轻量级锁、重量级锁)"></a>锁以及锁升级(无锁、偏向锁、轻量级锁、重量级锁)</h2><p>jdk1.6中，<strong>为了减少获取锁和释放锁带来的性能消耗</strong>，引入了偏向锁和轻量级锁，锁状态变为了四种。锁的状态会随着竞争激烈程度而升级。并且锁只能升级不能降级（为了提高获取&#x2F;释放锁的效率）。锁升级顺序如下:</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240518144521730.png" alt="image-20240518144521730"></p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>引入偏向锁的目的：<strong>减少只有一个线程执行同步代码块时的性能消耗</strong>。（没有其他线程竞争，只有1个线程获取到锁）</p>
<p>⭐一句话总结<strong>偏向锁原理：使用CAS操作将当前线程的ID记录到对象头的mark word中。</strong>具体流程如下：</p>
<p><strong>偏向锁的获取流程</strong>：</p>
<ul>
<li>检查对象头中的<strong>mark word是否为可偏向状态</strong>，如果<strong>不是则升级为轻量级锁</strong>（如果是可偏向状态，那不就说明只有一个线程争抢锁）；</li>
<li>如果是，<strong>判断mark word中的线程id是否指向当前线程</strong>，如果是，则执行同步代码块（即当前线程是否获得到锁了）；</li>
<li>如果<strong>不是，则进行CAS操作竞争锁</strong>，如果<strong>竞争到锁了，则将mark word中的线程id设为当前线程id，执行同步代码块；</strong></li>
<li>如果<strong>竞争失败，则升级为轻量级锁</strong>。</li>
</ul>
<p><strong>偏向锁的释放流程</strong>：</p>
<ul>
<li><strong>偏向锁的撤销需要到达全局安全点</strong>，全局安全点标识一种状态，<strong>该状态下所有线程都处于暂停状态</strong>（如果存在竞争，就没法安全的撤销偏向锁）。</li>
<li><strong>判断锁对象是否处于无锁状态</strong>，即获得偏向锁的线程已经退出了临界区。这时<strong>重新竞争的锁的线程会CAS操作替代原来线程的线程ID</strong>（其他线程来获取锁的时候，必须是无锁，因为偏向锁的定义就是只有一个线程竞争锁，如果存在竞争就得进行锁升级）；</li>
<li><strong>如果获取偏向锁的线程还没退出临界区，此时将偏向锁升级为轻量级锁。</strong></li>
</ul>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>引入轻量级锁的目的：<strong>在多线程交替执行同步代码块时（未发生竞争），避免使用互斥量（重量级锁）带来的性能消耗。但多个线程同时进入临界区（发生竞争）则会使得轻量级锁膨胀为重量级锁。</strong></p>
<p>⭐一句话总结<strong>轻量级锁的原理</strong>：<strong>将对象的mark word复制到当前现成的lock record中，并将对象的mark word变更为指向lock record的指针。</strong></p>
<p><strong>轻量级锁的获取：</strong></p>
<ul>
<li>进行<strong>加锁操作时</strong>，jvm会<strong>判断锁是否已经是重量级锁</strong>。<strong>如果不是</strong>，则会在<strong>当前线程栈帧</strong>之中<strong>划分出一块空间，作为该锁的锁记录lock record。并且将锁对象的mark word复制到该锁的lock record中；</strong></li>
<li><strong>复制成功后</strong>，jvm使用<strong>CAS操作</strong>将锁对象头mark word更改为指向lock record的<strong>指针</strong>。并且将<strong>lock record中的owner指针指向锁对象的mark word。</strong><ul>
<li><strong>如果更新成功，</strong>则当前线程持有该锁，并且锁对象<strong>mark word的锁标志置为“00”</strong>，即<strong>表示此对象正处于轻量级锁的状态。</strong></li>
<li>如果更新<strong>失败</strong>，需要<strong>判断当前对象的mark word是否指向了当前线程的栈帧</strong>。如果是，则表示该线程已经获取到了当前对象的锁，这是一次<strong>重入</strong>，直接执行同步代码块；如果<strong>不是</strong>，则<strong>表示存在竞争，当前线程通过自旋尝试获取锁，自旋超过一定次数，轻量级锁升级为重量级锁。</strong></li>
</ul>
</li>
</ul>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>如果创建了一个ThreadLocal变量，那么<strong>访问这个变量的每一个线程都会有这个变量的副本</strong>，多个线程操作这个变量的时候，实际是操作自己的本地内存中的变量，从而起到线程隔离的作用。</p>
<h3 id="Theadlocal的原理"><a href="#Theadlocal的原理" class="headerlink" title="Theadlocal的原理"></a>Theadlocal的原理</h3><p>Thread 类中有一个 <strong>ThreadLocal.ThreadLocalMap</strong> 的成员变量 threadLocals。<strong>ThreadLocalMap内部维护一个Entry&lt;k,v&gt;数组。</strong></p>
<p><strong>节点类Entry&lt;K,V&gt;<strong>，这个</strong>key不是ThreadLocal对象本身，而是它的一个弱引用</strong>，value就是存放的泛型值。</p>
<p>每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap中保存，取也是从这里取，从而实现了线程隔离。</p>
<p><strong>ThreadLocal本身不存储值，它只是作为一个key来让线程往ThreadLocalMap中存取值</strong>。</p>
<h3 id="ThreadLocal内存泄漏"><a href="#ThreadLocal内存泄漏" class="headerlink" title="ThreadLocal内存泄漏"></a>ThreadLocal内存泄漏</h3><p>因为<strong>TheadLocalMap</strong>中的<strong>key，是ThreadLocal对象的一个弱引用，而弱引用很容易被回收</strong> （弱引用的回收条件：不管内存够不够，都有可能回收），所以一旦key被jvm回收了，这个<strong>map只有value没有key了，就造成了内存泄露</strong>的问题。</p>
<p><strong>解决方法就是</strong>：在我们使用完ThreadLocal后，<strong>及时调用remove()方法释放内存空间</strong>。</p>
<p><strong>为什么key要设计成弱引用</strong>？那就是因为<strong>如果是强引用</strong>，即使线程不再使用某个ThreadLocal对象，该对象也没办法被回收，<strong>还是会造成内存泄漏</strong>。</p>
<h3 id="内存泄漏与内存溢出的区别"><a href="#内存泄漏与内存溢出的区别" class="headerlink" title="内存泄漏与内存溢出的区别"></a>内存泄漏与内存溢出的区别</h3><ul>
<li><strong>内存泄漏</strong>：指程序在申请完内存后，无法释放已申请的内存空间。结果导致申请到的那块内存自己也不能再次访问，而且系统也不能再次将它分配给需要的程序。一次内存泄漏危害可以忽略，但内存泄漏堆积后果很严重。</li>
<li><strong>内存溢出</strong>：指程序在申请内存时，没有足够的内存空间供其使用，出现了OOM。</li>
</ul>
<h3 id="ThreadLocalMap的结构"><a href="#ThreadLocalMap的结构" class="headerlink" title="ThreadLocalMap的结构"></a>ThreadLocalMap的结构</h3><p>虽然叫map，但是它没有实现Map接口。ThreadLcoal主要关注两个要素：元素数组 和 散列方法。</p>
<ul>
<li>元素数组：是一个table数组，存储Entry类型的元素（就是存放每一个节点），对于每个Entry，key是Thread对象的弱引用，value是存储的object对象。</li>
<li>散列方法：这里的散列方法就是将 <strong>key映射到 table数组的相应下标</strong>，其使用的是哈希取余法，取出key的threadlocalMapHashCode，然后对数组长度进行取余。<ul>
<li>每创建一个threadLocal对象，<strong>threadlocalMapHashCode就会新增一个 斐波那契数</strong>（黄金分割数），它可以<strong>让hash分布非常均匀</strong>。</li>
</ul>
</li>
</ul>
<h3 id="ThreadLocalMap如何解决哈希冲突"><a href="#ThreadLocalMap如何解决哈希冲突" class="headerlink" title="ThreadLocalMap如何解决哈希冲突"></a>ThreadLocalMap如何解决哈希冲突</h3><p>其使用 <strong>开放定址法</strong> 来解决哈希冲突，简单来说就是，进行哈希之后，发现当前位置已经存放了一个Entry，那么就<strong>从当前位置开始，向后寻找空闲位置</strong>并放入。</p>
<p>在查值时，也会先将目标key与当前 key是否一致，不一致就向后寻找直到找到为止。</p>
<h2 id="AQS（Abstract-Queued-Synchronizer-抽象同步队列）"><a href="#AQS（Abstract-Queued-Synchronizer-抽象同步队列）" class="headerlink" title="AQS（Abstract Queued Synchronizer 抽象同步队列）"></a>AQS（Abstract Queued Synchronizer 抽象同步队列）</h2><p>java并发包java.util.concurrent.locks中的锁就是基于AQS实现的。</p>
<ul>
<li>AQS是一个<strong>FIFO的双向队列</strong>，Node节点中的Thread变量用来存放进入AQS队列中的线程，此外还有当前节点在队列中的状态（waitStatus）、前驱节点（prev）、后继节点（next）。</li>
<li><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240520165516148.png" alt="image-20240520165516148"></li>
<li>AQS使用一个<strong>volatile修饰的int类型变量state来表示同步状态</strong>，state的初值为0，表示锁处于未锁定状态。volatile保证了变量在多线程之间的可见性，<strong>修改state值时通过CAS机制来保证修改的原子性</strong>。</li>
<li><strong>获取state的方式分为两种，（1）独占方式tryAcquire()（2）共享方式tryAcquireShared()：</strong><ul>
<li><strong>独占方式tryAcquire()<strong>：只有一个线程能够访问执行，又根据是否按队列的顺序</strong>分为公平锁和非公平锁</strong>。</li>
<li><strong>共享方式tryAcquireShared(</strong>)：多个线程可以同时访问执行，ReentrantReadWriteLock可以看成是组合模式，允许多个线程同时对某一资源进行读。</li>
<li><strong>tryAcquire()和tryAcquireShared()是抽象方法，需要子类自行实现</strong>。</li>
</ul>
</li>
<li>如果共享资源被占用，需要一定的阻塞等待唤醒机制来保证锁的分配，AQS中会将竞争共享资源失败的线程添加到队列中，线程进入队列后会进行自旋，自旋一定次数后，会使用LockSupport.park()进入阻塞状态。</li>
<li>可重入性的体现：假设线程 A 获取锁成功了，释放锁之前，A 线程自己是可以重复获取此锁的（<code>state</code> 会累加）。这就是可重入性的体现：一个线程可以多次获取同一个锁而不会被阻塞。</li>
<li>释放资源的时候，会使用CAS 操作将state修改为0，重入多少次，释放多少次，并使用LockSupport.unpark()唤醒 处于等待状态的线程</li>
</ul>
<h2 id="Thread-sleep-和Object-wait-的区别"><a href="#Thread-sleep-和Object-wait-的区别" class="headerlink" title="Thread.sleep()和Object.wait()的区别"></a>Thread.sleep()和Object.wait()的区别</h2><ul>
<li>sleep不会释放锁，wait()会释放占有的锁。</li>
<li>sleep必须传入时间，wait()可传可不传，不传表示一直阻塞下去；</li>
<li>sleep到时间了会自动唤醒，然后继续执行；</li>
<li>wait不带时间的，需要另一个线程使用Object.notify唤醒；</li>
<li>wait带时间的，假如没有被notify，到时间了会自动唤醒，这时又分好两种情况，一是立即获取到了锁，线程自然会继续执行；二是没有立即获取锁，线程进入同步队列等待获取锁。</li>
</ul>
<h2 id="什么是守护线程"><a href="#什么是守护线程" class="headerlink" title="什么是守护线程"></a>什么是守护线程</h2><p>Java中，<strong>线程分为两类：用户线程 和守护线程</strong>，默认情况下我们创建的线程或线程池都是用户线程，所以用户线程也成为普通线程。</p>
<p>想要查看线程到底是用户线程还是守护线程，可以通过 Thread.isDaemon() 方法来判断，如果返回的结果是 true 则为守护线程，反之则为用户线程。</p>
<p>守护线程（daemon线程）也称为后台线程或服务线程，<strong>守护线程是为用户线程服务的</strong>，当程序中的<strong>用户线程 全部执行结束后，守护线程也会跟随结束。不论守护线程是否还在工作</strong></p>
<h2 id="CAS会有哪些问题"><a href="#CAS会有哪些问题" class="headerlink" title="CAS会有哪些问题"></a>CAS会有哪些问题</h2><ul>
<li><strong>ABA问题</strong><ul>
<li>一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查的时候就会发现它的值没有发生变化，但实际上却变化了。</li>
<li>ABA问题的解决思路就是使用版本号。在变量前面使用版本号，每次变量更新的时候把版本号加1，那么A-&gt;B-&gt;A就会变成1A-&gt;2B-&gt;3A。</li>
</ul>
</li>
<li><strong>循环时间长开销大</strong><ul>
<li>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</li>
<li>如果JVM能够支持处理器提供pause指令，那么效率会有一定的提升。pause指令有两个作用：<ul>
<li>第一，可以延迟流水线执行命令，使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本；</li>
<li>第二，它可以避免在退出循环的时候因为内存顺序冲突而引起CPU流水线被清空，从而提高CPU的执行效率。</li>
</ul>
</li>
</ul>
</li>
<li><strong>只能保证一个共享变量的原子操作</strong><ul>
<li>当对一个共享变量的执行操作的时候，我们可以使用循环CAS的方式来保证原子操作。但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候<strong>就可以用锁</strong>。</li>
<li>还有一种方法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i&#x3D;2，j &#x3D; a，合并一下ij &#x3D; 2a，然后用CAS来操作ij。</li>
</ul>
</li>
</ul>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="使用线程池的好处："><a href="#使用线程池的好处：" class="headerlink" title="使用线程池的好处："></a>使用线程池的好处：</h3><ul>
<li>降低资源消耗。</li>
<li>提高响应速度。</li>
<li>提高线程的可管理性。</li>
</ul>
<p>线程池一般用于执行多个不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可以让多个不相关的任务同时执行。</p>
<h3 id="ThreadPoolExecutor类"><a href="#ThreadPoolExecutor类" class="headerlink" title="ThreadPoolExecutor类"></a>ThreadPoolExecutor类</h3><p>ThreadPoolExecutor类是<strong>Executor</strong>框架<strong>最核心的类</strong>。其中有<strong>最重要的三个参数</strong>：</p>
<ul>
<li><strong>corePoolSize</strong>：任务队列未达到最大容量时，最大可以同时运行线程的线程数量。</li>
<li><strong>maximumPoolSize</strong>：任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong>workQueue</strong>：新任务到达的时候，会先判断当前运行的线程数量是否到达核心线程数，如果达到的话，新任务会被放在队列中。</li>
</ul>
<p>以及其余<strong>4个非核心参数</strong>：</p>
<ul>
<li><strong>keepAliveTime</strong>：非核心线程 &#x3D; （maximumPoolSize - corePoolSize），<strong>非核心线程闲置下来不干活最多存活时间</strong>。</li>
<li><strong>unit：</strong>非核心线程存活时间的时间单位。</li>
<li><strong>threadFactory：</strong>创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程（守护线程）等等。</li>
<li><strong>handler：</strong>设置的拒绝策略。</li>
</ul>
<p><strong>ThreadPoolExecutor拒绝策略：</strong></p>
<ul>
<li><strong>AbortPolicy</strong>：<strong>抛出</strong>RejectedExecutionException <strong>异常</strong>来拒绝新任务的处理。</li>
<li><strong>CallerRunsPolicy</strong>：调用自己的线程运行任务，也就是<strong>直接在调用execute方法的线程中运行被拒绝的任务</strong>。这种策略会降低任务的提交速度，但是可以保证任务的执行。</li>
<li><strong>DiscardPolicy</strong>：不处理任务，<strong>直接丢弃掉</strong>。</li>
<li><strong>DiscardOldestPolicy</strong>：此策略将<strong>丢弃最早的未处理的任务请求</strong>。</li>
</ul>
<h3 id="线程池创建的两种方式（ThreadPoolExecutor-amp-Executors）："><a href="#线程池创建的两种方式（ThreadPoolExecutor-amp-Executors）：" class="headerlink" title="线程池创建的两种方式（ThreadPoolExecutor &amp; Executors）："></a>线程池创建的两种方式（ThreadPoolExecutor &amp; Executors）：</h3><p>第一种：通过<strong>ThreadPoolExecutor</strong>构造函数创建 （推荐）</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240521155821330.png" alt="image-20240521155821330"></p>
<p>第二种：通过Executor框架的工具类<strong>Executors</strong>来创建（<strong>都有OOM风险</strong>，不推荐。）</p>
<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240521155906126.png" alt="image-20240521155906126" style="zoom:67%;" />

<ul>
<li><strong>FixedThreadPool</strong>：<strong>固定线程数量的线程池</strong>。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。<ul>
<li>使用的是无界的任务队列（长度Integer.MaxValue），会导致OOM。</li>
</ul>
</li>
<li><strong>SingleThreadExecutor</strong>：<strong>只有一个线程的线程池</strong>。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。<ul>
<li>使用的是无界的任务队列（长度Integer.MaxValue），会导致OOM。</li>
</ul>
</li>
<li><strong>CachedThreadPool</strong>：可根据实际情况调整线程数量的线程池。线程池的线程<strong>数量不确定</strong>，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。<ul>
<li>如果任务数量过多且执行速度较慢，可能会创建大量的线程，从而导致 OOM。</li>
</ul>
</li>
<li><strong>ScheduledThreadPool</strong>：给定的<strong>延迟后运行任务或者定期执行任务的线程池</strong>。<ul>
<li>使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
</ul>
</li>
</ul>
<h1 id="二、Spring框架"><a href="#二、Spring框架" class="headerlink" title="二、Spring框架"></a>二、Spring框架</h1><h2 id="1-Bean生命周期"><a href="#1-Bean生命周期" class="headerlink" title="1.Bean生命周期"></a>1.Bean生命周期</h2><p>大致可分为四个阶段： <strong>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</strong></p>
<ul>
<li><strong>（实例化）</strong>首先，在Bean容器中找到SpringBean的定义BeanDefination。</li>
<li><strong>（实例化）</strong>Bean容器根据Java Reflection API创建一个Bean的实例（调用构造方法实例化bean）。</li>
<li><strong>（属性赋值）</strong>设置属性（为Bean设置相关属性和依赖、或者说依赖注入）</li>
<li><strong>（初始化）</strong>初始化Initialization：<ul>
<li>检查Aware的相关接口并设置相关依赖。如果实现了BeanAware接口，调用setBeanName()方法，传入Bean的名字。</li>
<li>BeanPostProcessor前置处理；如果实现了 BeanFactoryAware 接⼝，调⽤ setBeanFactory() ⽅法，传⼊ BeanFactory 对象的实例。 类似，如果实现了其他 *.Aware 接⼝，就调⽤相应的⽅法。</li>
<li>检查是否实现InitializationBean接口；如果 Bean 实现了 InitializingBean 接⼝，执⾏ afterPropertiesSet() ⽅法。</li>
<li>检查是否配置自定义的init-method；如果 Bean 在配置⽂件中的定义包含 init-method 属性，执⾏指定的⽅法。</li>
<li>BeanPostProcessor后置处理</li>
</ul>
</li>
<li><strong>使用</strong>中</li>
<li><strong>（销毁）</strong>销毁<ul>
<li>是否实现DisposableBean接口</li>
<li>是否配置自定义的destory-method</li>
</ul>
</li>
<li>结束。</li>
</ul>
<h2 id="2-SpringBoot启动流程"><a href="#2-SpringBoot启动流程" class="headerlink" title="2. SpringBoot启动流程"></a>2. SpringBoot启动流程</h2><ul>
<li><strong>第一步，加载启动类</strong>：<ul>
<li>SpringBoot项目启动时，会<strong>在当前工作目录下寻找有 @SpringBootApplication注解标识的类</strong>，并把这个类<strong>作为应用程序的入口点</strong>。如果<strong>找不到</strong>这样的主类，<strong>则会打印错误信息并退出</strong>。</li>
</ul>
</li>
<li><strong>第二步，加载配置文件</strong>：<ul>
<li>SpringBoot会自动<strong>扫描当前项目的resource目录</strong>，并<strong>加载其中</strong>的application.properties 或 application.yaml<strong>等配置文件</strong>。这些配置文件中包含了应用程序的各种参数，例如数据库连接信息、日志级别等。</li>
</ul>
</li>
<li><strong>第三步，初始化ApplicationContext</strong><ul>
<li>SpringBoot会<strong>创建一个SpringApplication对象</strong>，<strong>调用其run方法来初始化ApplicationContext</strong>。整个过程中，<strong>SpringBoot会读取配置文件中的参数，并将它们转换成Environment对象中的属性</strong>。同时，它还会<strong>扫描当前项目中所有的Bean，并将它们注册到ApplicationContext中</strong>。</li>
</ul>
</li>
<li><strong>第四步，启动内嵌的web服务器</strong><ul>
<li>SpringBoot内置Tomcat和Jetty等web服务器。当<strong>SpringBoot应用程序启动时，它会根据配置文件中的信息自动创建Tomcat或Jetty等web容器，并将Spring容器注册到web容器中</strong>，使得SpringBoot应用程序<strong>可以直接以web应用程序的形式运行</strong>。</li>
</ul>
</li>
<li><strong>第五步，启动应用程序：</strong><ul>
<li>根<strong>据之前创建好的Spring容器以及Web服务器，启动相应的线程进行服务处理</strong>。</li>
</ul>
</li>
<li><strong>第六步，监听应用程序的状态</strong>：<ul>
<li>SpringBoot会<strong>监听应用程序的状态，并根据需要进行相应的操作。</strong>例如，当应用程序退出时，它会打印出详细的日志信息，并将应用程序的上下文环境恢复到初始状态。</li>
</ul>
</li>
</ul>
<h2 id="2-Spring循环依赖"><a href="#2-Spring循环依赖" class="headerlink" title="2. Spring循环依赖"></a>2. Spring循环依赖</h2><ul>
<li><strong>只有单例Bean才会存在循环依赖</strong>。</li>
<li>当循环依赖的实例都采用setter方法注入，Spring可以解决；都采用构造器方法注入时，spring不可以解决；构造器注入和setter注入同时存在的时候，看天。</li>
</ul>
<p><strong>Spring通过三级缓存解决了循环依赖问题：</strong></p>
<ul>
<li>一级缓存：singletonObjects<strong>单例池</strong>，用于保存<strong>实例化、属性赋值（注入）、初始化完成的bean</strong>实例；</li>
<li>二级缓存：earlySingletonObjects<strong>早期曝光对象</strong>，用于保存<strong>实例化完成的bean</strong>实例</li>
<li>三级缓存：singletonFactories<strong>早期曝光对象工厂</strong>，用于保存<strong>Bean创建工厂</strong>，以便于后面扩展有机会创建代理对象。</li>
</ul>
<h2 id="3-Spring事务"><a href="#3-Spring事务" class="headerlink" title="3. Spring事务"></a>3. Spring事务</h2><h3 id="spring事务隔离级别："><a href="#spring事务隔离级别：" class="headerlink" title="spring事务隔离级别："></a>spring事务隔离级别：</h3><ul>
<li><strong>ISOLATION_DEFAULT： 使用后端数据库的默认隔离级别</strong>，mysql默认 可重复读 级别</li>
<li>ISOLATION_READ_UNCOMMITTED：即读未提交，最低的隔离级别，不能解决脏读，幻读，不可重复读</li>
<li>ISOLATION_READ_COMMITTED：即 读已提交，可以解决脏读，不能解决不可重复读 以及 幻读；</li>
<li>.ISOLATION_REPEATABLE_READ：即 可重复读，可解决脏读，不可重复读，不能解决幻读；</li>
<li>ISOLATION_SERIALIZABLE： 串行化，完全服从ACID，但是会严重影响性能。</li>
</ul>
<h3 id="Spring事务传播行为："><a href="#Spring事务传播行为：" class="headerlink" title="Spring事务传播行为："></a>Spring事务传播行为：</h3><p>事务传播行为是为了解决<strong>service层方法之间互相调用</strong>的事务问题（一个事务方法被另一个事务方法调用时，需要指定事务如何传播）。</p>
<p><strong>事务传播行为包括如下：</strong></p>
<ul>
<li>REQUIRED： 默认的事务传播行为，required表示当前方法必须在一个事务中运行，如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务；</li>
<li>SUPPORTS：当前方法支持在一个事务中运行，如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式执行；</li>
<li>MANDATORY：当前方法必须在一个事务中运行，如果当前存在事务，则加入该事务，如果当前没有事务，则抛出异常；</li>
<li>REQUIRES_NEW：当前方法必须在一个新的事务中运行，如果当前存在事务，就挂起该事务，并创建一个新的事务。</li>
<li>NOT_SUPPORTED：当前方法不应该在事务中运行，如果当前存在事务，就挂起该事务，以非事务的方式执行。</li>
<li>NEVER：表示当前方法不应在事务中运行，如果当前存在事务，则抛出异常。</li>
<li>NESTED：表示当前方法必须在一个嵌套的事务中运行，如果当前存在事务，则该在事务的嵌套事务中运行；如果当前没有事务，则创建一个新的嵌套事务。</li>
</ul>
<h3 id="事务失效场景"><a href="#事务失效场景" class="headerlink" title="事务失效场景"></a>事务失效场景</h3><ul>
<li><strong>@Transactional 应用在非 public 修饰的方法上</strong>：<strong>spring要求被代理方法必须是public的</strong>。在<code>AbstractFallbackTransactionAttributeSource</code>类的<code>computeTransactionAttribute</code>方法中有个判断，如果目标方法不是 public，则<code>TransactionAttribute</code>返回 null，即不支持事务。</li>
<li><strong>方法用 final修饰：</strong>如果将事务方法定义为final，这样会导致事务失效。原因是spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现事务的功能。<strong>如果某个方法被final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能</strong>。 同样的，如果某个<strong>方法是static的</strong>，同样<strong>无法</strong>通过动态代理，<strong>变成事务方法</strong>。</li>
<li><strong>同一个类中方法调用，导致事务失效：</strong>方法A调用本地的方法B，但<strong>A没有声明注解事务，但是B声明了</strong>，在<strong>外部调用方法A后，B的事务是不会起作用</strong>的。这还是由于SpringAOP代理造成的，因为只有当<strong>事务方法被当前类以外的代码调用的时候，才会由spring生成的代理对象</strong>来管理。</li>
<li><strong>方法所在的类没有被Spring管理：</strong>用spring事务的前提是，对象要被spring管理。</li>
</ul>
<h3 id="事务不回滚场景："><a href="#事务不回滚场景：" class="headerlink" title="事务不回滚场景："></a>事务不回滚场景：</h3><ul>
<li><strong>设置了错误的传播特性 propagation；</strong></li>
<li><strong>自己吞了异常：</strong>在事务方法中手动try catch了异常，这种情况下事务不会正常回滚。</li>
<li><strong>手动抛出了别的异常：</strong>即使开发者没有手动捕获异常，但是抛的异常不正确，spring事务也不会回滚。spring事务，默认情况下只会回滚 runtimeException和 error，对于普通的Exception（非运行时异常），它不会回滚。</li>
</ul>
<h2 id="4-IOC"><a href="#4-IOC" class="headerlink" title="4. IOC"></a>4. IOC</h2><p><strong>IOC，控制反转</strong>，是一种是设计思想，由容器负责控制对象的生命周期和对象之间的关系，IOC最重要的作用就是 <strong>解耦</strong>。</p>
<p><strong>有了IOC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松散耦合，这样也方便测试，利于功能复用。更重要的是使得程序的整个体系结构变得非常灵活。</strong></p>
<p><strong>IOC配置的三种方式：</strong></p>
<ul>
<li><strong>XML配置</strong>：就是将bean的信息配置在.xml文件里，通过spring加载文件为我们创建bean。早期的SSM项目出现的比较多。<ul>
<li>优点：可以使用于任何场景，结构清晰，通俗易懂。</li>
<li>缺点：配置繁琐，不易维护，扩展性差。</li>
</ul>
</li>
<li><strong>Java配置</strong>：将类的创建交给我们配置的JavcConfig类来完成，Spring只负责维护和管理，采用纯Java创建方式。<ul>
<li>优点：适用于任何场景，配置方便，因为是纯Java代码，扩展性高，十分灵活。</li>
<li>缺点：由于是采用Java类的方式，声明不明显，如果进行大量配置，可读性比较差。</li>
</ul>
</li>
<li><strong>注解配置</strong>：通过在类上加注解的方式，来声明一个类交给Spring管理，Spring会自动扫描带有@Component，@Controller，@Service，@Repository这四个注解的类，然后帮我们创建并管理，前提是需要先配置Spring的注解扫描器。<ul>
<li>优点：开发便捷，通俗易懂，方便维护。</li>
<li>缺点：具有局限性，对于一些第三方资源，无法添加注解。只能采用XML或JavaConfig的方式配置。</li>
</ul>
</li>
</ul>
<p><strong>DI，依赖注入</strong>，容器在实例化对象的时候把它依赖的类注入给它。<strong>DI可以理解为 IOC设计思想的实现</strong>。</p>
<h3 id="ApplicationContext-amp-BeanFactory"><a href="#ApplicationContext-amp-BeanFactory" class="headerlink" title="ApplicationContext &amp; BeanFactory"></a>ApplicationContext &amp; BeanFactory</h3><p><strong>SPring通过 ApplicationContext来设计容器，它是BeanFactory的子类，对它进行了补充实现。</strong></p>
<p><strong>BeanFactory</strong>可以理解为HashMap ,一般只有get，put两个功能，所以被称为 <strong>低级容器</strong>。</p>
<p>但是ApplicationContext多了很多功能，它继承了多个接口，那为何要定义这个多接口呢，其实每个接口都有他使用的场合，它主要是为了区分 spring内部在操作过程中对象的传递和转化的过程中，对对象的数据访问所做的限制：</p>
<ul>
<li>ListableBeanFactory 接口：表示这些 Bean 是可列表的。</li>
<li>HierarchicalBeanFactory 接口：表示的是这些 Bean 是有继承关系的，也就是每个Bean 有可能有父 Bean。</li>
<li>AutowireCapableBeanFactory 接口：定义 Bean 的<strong>自动装配规则</strong>。</li>
</ul>
<p><strong>这三个接口共同定义了 Bean 的集合、Bean 之间的关系、以及 Bean 行为。</strong></p>
<h3 id="BeanDefination"><a href="#BeanDefination" class="headerlink" title="BeanDefination"></a>BeanDefination</h3><p>在BeanFactory容器中，每个注入对象都对应一个BeanDefinition对象，该实例对象负责保存注入对象的所有必要信息，包括其所属的class类名，是否是抽象类，构造方法以及其他属性等。</p>
<p>当客户端向BeanFactory请求相应对象的时候，BeanFactory会通过这些信息向客户端返回一个完备可用的对象实例，BeanDefinition实例的信息是通过读取xml文件得到的。</p>
<h3 id="DI（依赖注入）"><a href="#DI（依赖注入）" class="headerlink" title="DI（依赖注入）"></a>DI（依赖注入）</h3><p><strong>依赖注入的三种方式：</strong></p>
<ul>
<li><strong>setter方式</strong>：<ul>
<li><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240527220340700.png" alt="image-20240527220340700"></li>
</ul>
</li>
<li><strong>构造器方式</strong>：<ul>
<li><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240527220525316.png" alt="image-20240527220525316"></li>
</ul>
</li>
<li><strong>注解注入</strong>（**@Autowired &amp; @Resource**）<ul>
<li>如果我们使用的是@Autowired 注入的时候，在单例池中查找，先byType进行查找，如果有多个结果不知道该注入哪个，就继续byName再做查找，如果byName还是找不到，如果我们声明了这个依赖是一个强制依赖，则会报错；否则不报错。</li>
<li>同样的，如果byType的时候，从单例池中只有一个bean，那么就使用该bean进行注入，不管beanName对不对的上。</li>
<li>如果我们使用的是@Resource注解（没有指定name），那么直接byName进行查找，如果查找不到就会byType查找。</li>
<li>如果我们使用的是@Resource注解（指定了name），那么直接byName进行查找，如果查找不到就直接报错。</li>
</ul>
</li>
</ul>
<h2 id="5-AOP"><a href="#5-AOP" class="headerlink" title="5. AOP"></a>5. AOP</h2><h3 id="什么是AOP？有没有用过AOP？"><a href="#什么是AOP？有没有用过AOP？" class="headerlink" title="什么是AOP？有没有用过AOP？"></a>什么是AOP？有没有用过AOP？</h3><p>AOP称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，这个模块被命名为”切面“Aspect，减少系统中的重复代码，降低了模块间的耦合度，同时提高了系统的可维护性。</p>
<p>AOP常见使用场景：</p>
<ul>
<li>记录操作日志</li>
<li>缓存数据</li>
<li><strong>Spring事务</strong></li>
</ul>
<h2 id="6-Spring-Bean"><a href="#6-Spring-Bean" class="headerlink" title="6. Spring Bean"></a>6. Spring Bean</h2><h3 id="spring-中-bean的作用域有哪些？"><a href="#spring-中-bean的作用域有哪些？" class="headerlink" title="spring 中 bean的作用域有哪些？"></a>spring 中 bean的作用域有哪些？</h3><ul>
<li><strong>singleton</strong>：唯一bean实例，<strong>Spring中的bean默认都是单例的</strong>。</li>
<li><strong>prototype</strong>：每次请求都会创建一个新的bean。</li>
<li><strong>request</strong>：每次Http请求都会产生一个新的bean，该bean尽在当前http request内有效。</li>
<li><strong>session</strong>：每一次Http请求都会产生一个新的bean，该bean仅在当前http session内有效。</li>
</ul>
<h3 id="Spring中的单例Bean的线程安全问题了解么？"><a href="#Spring中的单例Bean的线程安全问题了解么？" class="headerlink" title="Spring中的单例Bean的线程安全问题了解么？"></a>Spring中的单例Bean的线程安全问题了解么？</h3><p>单例bean存在线程安全问题，主要是因为当多个线程操作同一个对象时，对这个对象的非静态成员变量的写操作会存在线程安全问题。</p>
<p>两种常见的解决方案：</p>
<ul>
<li>在bean对象中尽量避免定义可变的成员变量（不太现实）；</li>
<li>在类中<strong>定义一个ThreadLocal成员变量，</strong>将需要的可变成员变量保存在ThreadLocal中（推荐的方式）</li>
</ul>
<h2 id="8-Spring中使用了哪些设计模式"><a href="#8-Spring中使用了哪些设计模式" class="headerlink" title="8. Spring中使用了哪些设计模式"></a>8. Spring中使用了哪些设计模式</h2><ul>
<li><p><strong>工厂模式（IOC用到的）</strong>：Spring使用工厂模式，通过<strong>BeanFactory</strong>和 <strong>ApplicationContext</strong> 创建bean对象。</p>
<ul>
<li><strong>BeanFactory</strong>：提供了最基本的依赖注入支持，延迟注入（使用到某个Bean的时候才会进行注入），相比于另一个，占用了更少的内存，启动速度更快。</li>
<li><strong>ApplicationContext</strong>：提供了一些额外功能。容器启动的时候，不管用没用到，一次性创建所有bean。</li>
</ul>
</li>
<li><p><strong>单例模式</strong>：在系统中，有一些对象我们只需要一个，如线程池、缓存、日志对象、对话框等。如果制造出多个实例就可能会导致一些问题的产生。<strong>Spring中 bean的默认作用域就是singleton的</strong>。</p>
<ul>
<li>Spring通过<strong>ConcurrentHashMap</strong>实现<strong>单例注册表</strong>的特殊方式实现单例模式。</li>
</ul>
<p><strong>使用单例模式有以下好处</strong>：</p>
<ul>
<li><strong>对于频繁使用的对象，可以省略创建对象所花费的时间</strong>，这对于那些重量级对象而言，是非常可观的一笔开销。</li>
<li><strong>由于new操作的次数减少，因而对系统内存的使用频率也会降低</strong>，这将减轻GC压力，缩短GC停顿时间。</li>
</ul>
</li>
<li><p><strong>代理模式（AOP用到的）</strong>：如果要代理的对象，<strong>实现了某个接口</strong>，那么springAOP会使用<strong>JDK Proxy</strong>，去创建代理对象；对于<strong>没有实现接口</strong>的对象，会使用<strong>cglib生成一个被代理对象的子类</strong>来作为代理。当然也可以使用<strong>AspectJ</strong>，AspectJ可以算得上Java生态系统中最完整的AOP框架了。<strong>SpringAOP 已经集成了 AspectJ AOP了</strong></p>
<p><strong>SpringAOP 和 AspectJ AOP 有什么区别？</strong></p>
<ul>
<li>SpringAOP 属于运行时增强，而Aspect J属于编译时增强；</li>
<li>SpringAOP 基于代理，而AspectJ 基于字节码操作；</li>
<li>如果切面较少，那么两者性能差异不大。如果较多的话，最好选择AspectJ，它更快一点。</li>
</ul>
</li>
<li><p><strong>模板模式：</strong>一种行为设计模式，它<strong>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中</strong>。模板方法使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤的实现方式。</p>
<p>jdbcTemplate，hibernateTemplate等以Template结尾的对数据库操作的类，使用到了模板模式。</p>
<p><strong>一般情况下，都是使用继承方式</strong>来实现模板模式，但是<strong>Spring使用了callback模式与模板方法模式配合</strong>，既达到了代码复用的结果，同时增加了灵活性。</p>
</li>
<li><p><strong>观察者模式：</strong>一种对象行为模式。表示的是一种<strong>对象与对象之间具有依赖关系，当一个对象发生改变的时候，这个对象所依赖的对象也会做出反应</strong>。<strong>Spring事件驱动模式</strong>就是观察者模式很经典的一个应用。</p>
</li>
<li><p><strong>适配器模式（AOP &amp; SpringMVC用到的）</strong>：我们知道SpringAOP的实现是基于代理模式，但是SpringAOP 的增强或通知（Advice）使用到了适配器模式，与之相关的接口是AdvisorAdapter。</p>
<p><strong>spring MVC中的适配器模式</strong></p>
<p>在spring MVC 中，dispatcherServlet 根据请求信息调用HandlerMapping，解析请求对应的Handler。解析到对应的Handler（也就是Controller控制器）后，开始由HandlerAdapter适配器处理。HandlerAdapter作为期望接口，具体的适配器实现类用于对目标类进行适配，controller作为需要适配的类。</p>
<p><strong>为什么要在springMVC 中使用适配器模式？</strong></p>
<p>springMVC 中的 controller种类众多，不同类型的controller通过不同的方法来对请求进行处理。如果<strong>不利用适配器模式，DispatcherServlet直接获取对应类型的Controller，需要其自行判断</strong>。这就会使得程序难以维护，也违反了设计模式中的开闭原则—对扩展开放，对修改关闭。</p>
</li>
<li><p><strong>装饰器模式：</strong>装饰器模式可以<strong>动态地给对象添加一些额外的属性或行为。相比于使用继承，装饰器模式更加灵活。</strong>JDK中<strong>InputStream类下</strong>有FileInputStream（读文件）、BufferedInputStream（缓存读）都在不修改Input代码的情况下扩展了它的功能。</p>
<p><strong>Spring中配置DataSource</strong>的时候，DataSource可能是不同的数据库或者数据源。为了在尽量少修改原始类代码的情况下，动态切换不同的数据源，这个时候就要使用装饰器模式。动态地给一个对象添加一些额外的职责。</p>
</li>
</ul>
<h2 id="9-SpringBoot核心配置文件"><a href="#9-SpringBoot核心配置文件" class="headerlink" title="9. SpringBoot核心配置文件"></a>9. SpringBoot核心配置文件</h2><p>springBoot核心配置文件主要有两种：</p>
<ul>
<li>bootstrap文件（格式为.properties或者.yaml）；</li>
<li>application文件（格式为.properties或者.yaml）；</li>
</ul>
<h3 id="bootstrap配置文件和application-配置文件的区别："><a href="#bootstrap配置文件和application-配置文件的区别：" class="headerlink" title="bootstrap配置文件和application 配置文件的区别："></a>bootstrap配置文件和application 配置文件的区别：</h3><ul>
<li>bootstrap由ApplicationContext加载，比application优先加载；</li>
<li>bootstrap 中的属性不能被覆盖；</li>
</ul>
<h3 id="二者的使用场景区别："><a href="#二者的使用场景区别：" class="headerlink" title="二者的使用场景区别："></a>二者的使用场景区别：</h3><ul>
<li>application主要用于spring Boot项目的自动化配置；</li>
<li>bootstrap配置文件有以下的应用场景：<ul>
<li>使用spring cloud config配置中心时，这时需要在bootstrap配置文件中添加连接到配置中心的配置属性来加载外置配置中心的配置信息。</li>
<li>一些固定的不能被覆盖的属性。</li>
<li>一些加密&#x2F;解密的场景。</li>
</ul>
</li>
</ul>
<h1 id="三、计算机网络"><a href="#三、计算机网络" class="headerlink" title="三、计算机网络"></a>三、计算机网络</h1><h2 id="1-TCP三次握手-amp-四次挥手"><a href="#1-TCP三次握手-amp-四次挥手" class="headerlink" title="1. TCP三次握手 &amp; 四次挥手"></a>1. TCP三次握手 &amp; 四次挥手</h2><p><strong>三次握手建立连接</strong>。从client的视角来看：</p>
<ul>
<li><strong>第一次握手</strong>： client发送一个带有<code>syn（seq = x）</code>标志的数据包到server端，然后标识自己的状态为<strong>syn_send</strong>已发送状态；</li>
<li><strong>第二次握手</strong>：server收到了client发来的消息，于是向client发送 <code>syn (seq = y) + ack（ack=x+1） </code>确认信息。client接收到确认信息后，这时候client知道自己的发送和接收都能正常进行，对方的发送和接收都正常；server知道自己能正常接收，对方能正常发送（<strong>但不知道对方能否正常接收，自己能不能正常发送</strong>）；在server发送确认信息后表示自己状态为<strong>syn_recv</strong>已接收状态。</li>
<li><strong>第三次握手</strong>：client发送一个<code>ack (ack = y+1)</code>标志的数据包，然后client和server端都进入 <strong>establish</strong>链接建立状态。完成三次握手。</li>
</ul>
<p><strong>三次握手最重要的目的就是双方确认自己与对方的发送与接收都是正常的。</strong></p>
<ul>
<li><strong>第一次握手</strong>：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li><strong>第二次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li><strong>第三次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ul>
<p><strong>第二次握手传回了ack，为什么 还要传回syn?</strong></p>
<p>传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。</p>
<p><strong>四次挥手断开连接</strong>：</p>
<ul>
<li><strong>第一次挥手：</strong> client发送一个<code>FIN（seq = x）</code>的数据包到服务端，用来关闭客户端到服务端的数据传送，然后client进入<strong>FIN-Wait-1</strong>状态；</li>
<li><strong>第二次挥手</strong>：server收到这个<code>FIN（seq=x）</code>的数据包，然后发送一个<code>ACK（ack = x+1）</code>的数据包到client，随后server进入<strong>Close-wait</strong>状态，client收到这个数据包后进入<strong>FIN-Wait-2</strong>状态；</li>
<li><strong>第三次挥手</strong>：server发送一个<code>FIN （seq = y）</code>的数据包到client，请求关闭连接，随后server进入<strong>LAST-ACK</strong>状态；</li>
<li><strong>第四次挥手</strong>：client发送一个<code>ACK (ack=y+1)</code> 的数据包到server，然后client进入到<strong>TIME-Wait</strong>状态，server端在接收到这个数据包后进入<strong>CLOSE</strong>状态。此时如果<strong>client</strong>等待 <strong>2*MSL</strong>（一个片段在网络中的最大存活时间）没有收到回复，说明server已经正常关闭，随后client也可以关闭连接了。</li>
</ul>
<h2 id="TCP与UDP的区别："><a href="#TCP与UDP的区别：" class="headerlink" title="TCP与UDP的区别："></a>TCP与UDP的区别：</h2><ul>
<li><strong>是否面向连接：</strong> TCP是面向连接的，传送数据前必须先建立连接，结束后释放连接；UDP传送数据前不需要建立连接。</li>
<li><strong>是否可靠传输</strong>：UDP不是可靠传输，不保证数据不丢失、不保证数据按顺序到达；TCP是可靠传输，有一系列的机制，包括创建连接时三次握手，传递时有消息确认、滑动窗口、超时重传、拥塞控制，取消连接时有四次挥手。保证有序、不丢失、不重复。</li>
<li><strong>是否有状态</strong>：TCP是有状态的，TCP会记录自己发送消息的状态。而UDP是无状态的，消息发出去就不管了。</li>
<li><strong>传输效率：</strong>UDP的效率高，因为它发出去啥都不管了。TCP效率低。</li>
<li><strong>传输形式：</strong>TCP是面向字节流的，UDP是面向报文的。</li>
<li><strong>首部开销：</strong>TCP首部（20~60字节），UDP首部（8字节）。</li>
<li><strong>是否提供广播或多播：</strong>UDP能广播或多播，TCP只支持点对点通信。</li>
</ul>
<h2 id="浏览器输入URL到显示主页的过程："><a href="#浏览器输入URL到显示主页的过程：" class="headerlink" title="浏览器输入URL到显示主页的过程："></a>浏览器输入URL到显示主页的过程：</h2><ul>
<li><strong>DNS解析：</strong>将域名解析为对应的IP地址。<ul>
<li>DNS解析过程：（1）首先查看浏览器缓存，看看是否能找到<a target="_blank" rel="noopener" href="http://www.xxx.com域名对应的ip地址,找到就直接返回.否则进行下一步.(2)将请求发给本地dns服务器,如果能查到则返回,否则进行下一步.(3)本地dns服务器向/">www.XXX.com域名对应的IP地址，找到就直接返回。否则进行下一步。（2）将请求发给本地DNS服务器，如果能查到则返回，否则进行下一步。（3）本地DNS服务器向</a> 根域名服务器发送请求，根域名服务器负责返回com的顶级域名服务器的IP地址列表。（4）本地DNS服务器向IP地址列表中负责com的顶级域名服务器发送请求，返回一个xxx.com的权限域名服务器。（5）本地DNS服务器再向这个负责xxx.com的权限域名服务器发送请求，返回<a target="_blank" rel="noopener" href="http://www.xxx.com对应的ip地址./">www.xxx.com对应的IP地址。</a></li>
</ul>
</li>
<li><strong>TCP连接：</strong>经过三次握手，与服务器建立TCP连接。</li>
<li><strong>向服务器发送HTTP请求。</strong></li>
<li><strong>服务器处理请求，并返回HTTP响应。</strong></li>
<li><strong>浏览器解析并渲染页面。</strong></li>
<li><strong>断开连接</strong>：四次挥手，连接结束。</li>
</ul>
<h2 id="HTTP-和HTTPS-有什么区别："><a href="#HTTP-和HTTPS-有什么区别：" class="headerlink" title="HTTP 和HTTPS 有什么区别："></a>HTTP 和HTTPS 有什么区别：</h2><ul>
<li>安全性：HTTP是明文传输协议，数据传输过程中不加密；HTTPS通过SSL 或者 TSL 协议对数据进行加密，确保传输的数据在网络是安全的。</li>
<li>加密方式：HTTP没有加密，明文传输；HTTPS使用SSL 或TSL协议加密传输的数据，使用公钥加密和私钥解密的方式确保机密性和完整性。</li>
<li>端口号：HTTP默认80端口；HTTPS默认443端口。</li>
<li>证书：HTTP不需要证书验证；HTTPS需要使用SSL证书，由可信的第三方机构签发。</li>
</ul>
<h2 id="HTTP常见字段有哪些？"><a href="#HTTP常见字段有哪些？" class="headerlink" title="HTTP常见字段有哪些？"></a>HTTP常见字段有哪些？</h2><ul>
<li><p>Host字段：客户端发送请求时，用来指定服务器的域名。</p>
</li>
<li><p>Content-Length：服务器在返回数据时，会有Content-length字段，表示本次响应的数据长度。</p>
</li>
<li><p>Connection字段：Connection字段常用于客户端要求服务器使用 HTTP长连接 机制，以便其他请求复用（HTTP长连接的特点是：只要任意一端没有明确提出断开连接，则保持TCP连接状态）。</p>
</li>
<li><p>Content-Type字段：用于服务器响应时，告诉客户端本次数据是什么形式。</p>
<ul>
<li>Accept字段：客户端在请求的时候，可以使用该字段表明自己可以接受哪些数据格式。</li>
</ul>
<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240531161621185.png" alt="image-20240531161621185" style="zoom:67%;" />
</li>
<li><p>Content-Encoding字段：该字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。</p>
<ul>
<li>Accept-Encoding字段：用Accept-Encoding字段说明自己可以接收哪些压缩方法。</li>
<li><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240531161658176.png" alt="image-20240531161658176" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<h2 id="HTTP1-0，1-1，2-0，3的区别"><a href="#HTTP1-0，1-1，2-0，3的区别" class="headerlink" title="HTTP1.0，1.1，2.0，3的区别"></a>HTTP1.0，1.1，2.0，3的区别</h2><p><strong>1.0默认短连接</strong>，可以强制开启；<strong>1.1默认长连接</strong>；<strong>2.0采用多路复用</strong>。<strong>http3主要有两大变化，传输层基于UDP、使用QUIC保障UDP的可靠性。</strong></p>
<ul>
<li><strong>http1.0</strong>：<ul>
<li>默认使用短连接，每次请求都需要建立一次tcp连接。可以设置Connection：Keep-Alive字段，强制开启长连接。</li>
</ul>
</li>
<li><strong>http1.1：</strong><ul>
<li>引入了<strong>持久连接</strong>，tcp连接可以被多个请求复用。</li>
<li><strong>分块传输编码</strong>，即服务端每产生一块数据，就发送一块。</li>
<li><strong>管道机制</strong>：即在同一个tcp连接里，客户端可以同时发送多个请求。</li>
</ul>
</li>
<li><strong>http2.0：</strong><ul>
<li><strong>二进制协议</strong>，1.1版本的头信息是文本（ASCII编码），数据体可以为文本也可以为二进制；<strong>2.0中，头信息和数据体都是二进制</strong>。</li>
<li><strong>完全的多路复</strong>用，在一个连接里，客户端和浏览器都<strong>可以同时发送多个请求或回应</strong>，而且<strong>不用按照顺序一一对应</strong>。</li>
<li><strong>报头压缩</strong>，HTTP协议不带有状态，每次请求都必须附带上所有信息。<strong>http2.0引入了头信息压缩机制，使用gzip或compress压缩后再发送</strong>。</li>
<li>服务端推送，<strong>允许服务器未经请求，主动向客户端发送资源</strong>。</li>
</ul>
</li>
<li><strong>http3:</strong><ul>
<li><strong>使用UDP作为传输层进行通信</strong>；</li>
<li><strong>在UDP的基础上QUIC协议保证了HTTP3的安全性，在传输的过程就完成了TLS加密握手</strong>；<ul>
<li>https要建立一个连接，要进行6次交互，先是建立三次握手，然后是TSL的三次握手。<strong>QUIC直接将以往的TCP和TLS的6次交互合并成了3次，减少了交互次数</strong>；</li>
<li><strong>QUIC有自己的一套机制可以保证传输的可靠</strong>。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="GET和POST方法都是安全和幂等的么？"><a href="#GET和POST方法都是安全和幂等的么？" class="headerlink" title="GET和POST方法都是安全和幂等的么？"></a>GET和POST方法都是安全和幂等的么？</h2><p><strong>先说明什么是安全和幂等：</strong></p>
<ul>
<li>安全性：请求方法不会破坏服务器的资源。</li>
<li>幂等性：多次执行相同的操作，结果都是相同的。</li>
</ul>
<p><strong>GET是安全和幂等的</strong>，因为是<strong>只读</strong>操作，无论操作多少次，服务器上的数据都是安全的。所以<strong>可以对GET请求的结果做缓存</strong>，这个缓存可以做到浏览器本身上，也可以做到代理上（如Nginx），而且<strong>GET请求可以作为书签</strong>。</p>
<p><strong>POST不是安全和幂等的</strong>，因为是<strong>新增或提交数据</strong>的操作，会修改服务器上的资源。且多次提交数据就会创建多个资源，所以不是幂等的。浏览器<strong>一般不会缓存POST请求</strong>，也<strong>不能把POST请求保存在书签里</strong>。</p>
<p><strong>那么GET请求可以带body么？</strong></p>
<p>RFC规范并没有规定GET请求不能带body。实际上任何请求都可以带body。</p>
<p>另外，RFC中的查询参数也不是GET所独有的，POST请求的URL中也可以有参数的。</p>
<h2 id="HTTP和RPC的区别："><a href="#HTTP和RPC的区别：" class="headerlink" title="HTTP和RPC的区别："></a>HTTP和RPC的区别：</h2><ul>
<li><p><strong>HTTP是一种应用层协议，主要强调的是网络通信；RPC是一种用于分布式系统之间通信的协议，强调的是服务间的远程调用。</strong></p>
</li>
<li><p><strong>通信方式</strong>：HTTP基于请求-响应模型，客户端发送请求，服务端返回响应；基于方法调用模型，客户端调用远程方法并等待结果。</p>
</li>
<li><p><strong>传输协议</strong>：HTTP基于TCP协议，可使用TLS&#x2F;SSL等进行加密；RPC可以使用多种传输协议，如TCP、UDP等。</p>
</li>
<li><p><strong>数据格式</strong>：HTTP基于文本，常用的数据格式包括json，xml等；RPC可以使用各种数据格式，如二进制、json、protocol buffers等。</p>
</li>
<li><p><strong>接口定义：</strong>HTTP使用restful风格的接口进行定义；RPC使用IDL（接口定义语言）进行接口定义，如protocol buffers、thrift等。</p>
</li>
<li><p><strong>跨语言能力</strong>：都支持跨语言通信。可以使用HTTP作为通信协议实现不同语言之间的通信；RPC可以使用IDL生成不同语言的客户端和服务端代码。</p>
</li>
<li><p><strong>灵活性</strong>：<strong>HTTP更加灵活</strong>，适用于不同类型的应用场景；<strong>RPC更加高效</strong>，适用于需要高性能和低延迟的分布式系统。</p>
<h3 id="为什么RPC性能比Http服务性能好："><a href="#为什么RPC性能比Http服务性能好：" class="headerlink" title="为什么RPC性能比Http服务性能好："></a>为什么RPC性能比Http服务性能好：</h3><ul>
<li><strong>RPC服务序列化是针对二进制协议来做序列化和反序列化，所以性能高。</strong>而HTTP服务是基于文本的序列化和反序列化，需要读一行一行的文本，进行序列化和反序列化，所以性能低。</li>
<li>RPC服务是自定义的传输协议，传输的报文都是干货。而HTTP服务中包含很多没用的报文内容。</li>
</ul>
</li>
</ul>
<h1 id="四、操作系统："><a href="#四、操作系统：" class="headerlink" title="四、操作系统："></a>四、操作系统：</h1><h2 id="1-硬件结构："><a href="#1-硬件结构：" class="headerlink" title="1. 硬件结构："></a>1. 硬件结构：</h2><h3 id="冯诺依曼模型-计算机基本结构-："><a href="#冯诺依曼模型-计算机基本结构-：" class="headerlink" title="冯诺依曼模型(计算机基本结构)："></a>冯诺依曼模型(计算机基本结构)：</h3><p>计算机基本结构分为5个部分，分别是 <strong>运算器、控制器、存储器、输入设备、输出设备</strong>。</p>
<p>运算器、控制器是在中央处理器中的，存储器就是我们常见的内存，输入输出设备则是计算机外界的设备。</p>
<p>存储单元与输入输出设备通过 <strong>总线</strong> 与CPU相连。</p>
<h2 id="2-进程管理"><a href="#2-进程管理" class="headerlink" title="2. 进程管理"></a>2. 进程管理</h2><h3 id="进程间通信方式："><a href="#进程间通信方式：" class="headerlink" title="进程间通信方式："></a>进程间通信方式：</h3><ul>
<li><p><strong>管道：半双工通信</strong>，只能单向传输。分为<strong>无名管道（pipe）</strong>和<strong>有名管道（FIFO）</strong>。无名管道只能用于具有亲缘关系的进程之间通信；有名管道可以用于任意进程之间的通信。</p>
<ul>
<li>缺点：通信效率低，不适合频繁交换数据。</li>
</ul>
</li>
<li><p><strong>消息队列：</strong>它是保存在内核中的消息链表。消息被存储在消息队列中，并按照一定的规则进行发送和接收。可以频繁交换数据。</p>
<ul>
<li>缺点：消息队列不适合比较大消息的传输；并且消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销。</li>
</ul>
</li>
<li><p><strong>共享内存：</strong>其机制就是，拿出一块虚拟地址空间来，映射到相同的物理内存中。</p>
</li>
<li><p><strong>信号量（PV操作）：</strong>如果使用共享内存通信方式，带来新的问题，那就<strong>是如果多个进程同时修改同一个共享内存，很有可能就冲突了</strong>。为了防止多线程竞争导致数据错乱，因此需要保护机制，使得<strong>共享的资源，在任意时刻只能被一个进程访问</strong>。由此引入信号量机制。</p>
<ul>
<li><strong>信号量其实是一个整形的计数器</strong>，<strong>主要用于实现进程之间的互斥与同步</strong>，而不是用于缓存进程之间通信的数据。</li>
</ul>
</li>
<li><p><strong>信号：</strong>对于异常情况下的工作模式，就需要用 信号 的方式来通知进程。</p>
</li>
<li><p><strong>Socket：</strong>套接字是一种通用的进程间通信机制，不仅可以用于网络通信，还可以用于本地进程之间通信。套接字通信基于网络协议，提供了可靠、灵活的数据传输方式。在本地通信中，套接字可以用于不同进程之间通信，实现进程间数据交换和协作。</p>
</li>
</ul>
<h1 id="四、JVM"><a href="#四、JVM" class="headerlink" title="四、JVM"></a>四、JVM</h1><h2 id="1-JVM内存"><a href="#1-JVM内存" class="headerlink" title="1. JVM内存"></a>1. JVM内存</h2><h3 id="jvm内存组成："><a href="#jvm内存组成：" class="headerlink" title="jvm内存组成："></a>jvm内存组成：</h3><ul>
<li><strong>方法区</strong>（线程共享区）<ul>
<li>也称为永久代，JDK8后改为<strong>元空间</strong>；</li>
<li>存储<strong>已加载的类</strong>的类信息、常量、静态变量、即时编译器编译后的代码等；</li>
</ul>
</li>
<li><strong>堆</strong>（线程共享区）<ul>
<li>存储<strong>对象实例</strong>和<strong>数组</strong>；</li>
<li>JVM管理的最大一块内存区域（垃圾回收）</li>
<li>在JVM启动时被创建，并且在运 行时进行动态扩展或收缩；</li>
</ul>
</li>
<li><strong>本地方法栈</strong>（线程私有区）<ul>
<li>与虚拟机栈类似，但它是为了<strong>本地方法</strong>服务</li>
<li>本地方法使用其他语言写的一些方法，需要特殊的栈支持。</li>
</ul>
</li>
<li><strong>虚拟机栈（</strong>线程私有区）<ul>
<li>每个线程在执行Java方法时，都会创建一个对应的<strong>栈帧</strong></li>
<li><strong>栈帧</strong>用来存储<strong>局部变量、方法参数、操作数栈、动态链接</strong>等信息</li>
</ul>
</li>
<li><strong>程序计数器</strong>（线程私有区）<ul>
<li>每个线程都有自己的程序计数器，用来记录当前线程执行的位置。</li>
</ul>
</li>
</ul>
<h3 id="对象创建过程："><a href="#对象创建过程：" class="headerlink" title="对象创建过程："></a>对象创建过程：</h3><ul>
<li><strong>遇到new字节码指令</strong>的时候，检查<strong>指令的参数</strong>能否找到一个<strong>类的符号引用</strong></li>
<li>如果这个符号引用对应的类还没有被加载、解析、初始化过，那么先执行类加载过程。</li>
<li>类加载完成后，为新对象分配内存，分配内存的方法包括<strong>指针碰撞、空闲列表</strong>方法。</li>
<li>分配完内存，对分配好的内存（除了对象头）进行初始化工作，都初始化为0值。</li>
<li>接下来设置对象头，对象头包括所属的类、哈希码、GC分代年龄等。</li>
<li>最后，JVM<strong>执行对象的构造函数</strong>，对对象的实例变量进行<strong>初始化</strong>或其他必要操作。</li>
</ul>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><ul>
<li><strong>对象头</strong><ul>
<li>对象运行时数据：<ul>
<li>哈希码</li>
<li>GC分代年龄</li>
<li>锁状态标识</li>
<li>线程持有的锁</li>
<li>偏向线程ID</li>
<li>偏向时间戳</li>
</ul>
</li>
<li>类型指针（自己代表哪个类）。</li>
<li>如果是数组，还有一个保存自己长度信息的数据</li>
</ul>
</li>
<li><strong>实例化数据，</strong>存储对象真正的有效信息。</li>
<li><strong>对齐填充padding</strong>，无实际意义。</li>
</ul>
<h3 id="对象有哪几种引用类型"><a href="#对象有哪几种引用类型" class="headerlink" title="对象有哪几种引用类型"></a>对象有哪几种引用类型</h3><ul>
<li>强引用<ul>
<li>当一个对象被强引用时，不会被垃圾回收</li>
<li>没有任何强引用指向一个对象时，可以被垃圾回收</li>
</ul>
</li>
<li>软引用<ul>
<li>相对弱化的强引用，当内存不足时，可能会回收软引用关联的对象</li>
</ul>
</li>
<li>弱引用<ul>
<li>相对弱化的强引用，无论内存是否充足，都会回收被弱引用关联的对象</li>
</ul>
</li>
<li>虚引用<ul>
<li>最弱化的强引用，任何时候都可能会被回收，不会通过虚引用获取到对象实例。</li>
</ul>
</li>
</ul>
<h3 id="堆内存分区"><a href="#堆内存分区" class="headerlink" title="堆内存分区"></a>堆内存分区</h3><ul>
<li>新生代<ul>
<li>Eden区（较大）</li>
<li>survivor区 （较小）<ul>
<li>from区</li>
<li>to区</li>
</ul>
</li>
</ul>
</li>
<li>老年代</li>
</ul>
<p>对象被创建时，会被放至Eden区，垃圾回收后，Eden中的存活对象会被转入survivor区，经过多次垃圾回收后会转入老年代。老年代的回收频率较低。</p>
<p>每次分配内存只是用Eden和其中一块survivor，发生垃圾收集时，eden和survivor中存活的对象一次性复制到另一块survivor上。然后直接清理掉 Eden和已用过的那块Survivor空间。</p>
<h3 id="JVM内存分配策略"><a href="#JVM内存分配策略" class="headerlink" title="JVM内存分配策略"></a>JVM内存分配策略</h3><ul>
<li><strong>对象优先在Eden分配</strong><ul>
<li>大多数情况下，对象在新生代Eden区分配，<strong>当Eden区空间不够时，发起Minor GC</strong>。</li>
</ul>
</li>
<li><strong>大对象直接进入老年代</strong><ul>
<li>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</li>
<li>如果经常出现大对象，会导致提前进行垃圾回收以获取足够的连续空间分配给大对象。</li>
<li><strong>大于PretenureSizeThreshold的对象会直接在老年代分配，避免在Eden区和Survivor区之间的大量内存复制</strong></li>
</ul>
</li>
<li><strong>长期存活的对象直接进入老年代</strong><ul>
<li>为对象定义年龄计数器，对象<strong>在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁</strong>，<strong>增加到一定年龄则移动到老年代中</strong></li>
</ul>
</li>
<li><strong>动态对象年龄判定</strong><ul>
<li>JVM并不总是根据年龄超过阈值才将对象晋升到老年代中，<strong>如果Survivor区中相同年龄的对象超过了Survivor区的一半，则年龄大于等于该年龄的对象可以直接进入老年代。</strong></li>
</ul>
</li>
<li><strong>空间分配担保</strong><ul>
<li>在<strong>发生Minor GC之前</strong>，JVM会先检查<strong>老年代最大可用的连续空间是否大于新生代所有对象的总空间</strong>，如果大于，则说明这一次的Minor GC是安全的，可以进行。</li>
<li>如果不安全，则要判断 JVM<strong>是否允许担保失败</strong>。<strong>如果允许</strong>，那么如果<strong>老年代最大可用连续空间大于 过往历次晋升到老年代对象的平均大小，如果大于则可以进行Minor GC</strong> ，<strong>如果小于，或者设置了不允许担保失败，则进行 Full GC</strong></li>
</ul>
</li>
</ul>
<h3 id="怎么判断一个对象是不是垃圾："><a href="#怎么判断一个对象是不是垃圾：" class="headerlink" title="怎么判断一个对象是不是垃圾："></a><strong>怎么判断一个对象是不是垃圾：</strong></h3><ul>
<li><strong>引用计数法</strong>：早期的方法，一个对象被引用了计数器就加一，否则减一。如果为0就可以进行回收，<strong>缺点是无法回收相互引用的对象</strong>，造成内存泄漏。</li>
<li><strong>根可达算法</strong>：在内存中，<strong>从引用根对象向下一直寻找引用</strong>， 。<ul>
<li><strong>GC Roots一般包含以下</strong>内容：<ul>
<li><strong>虚拟机栈</strong>中引用的对象；</li>
<li><strong>本地方法栈</strong>中引用的对象；</li>
<li>方法区中<strong>类静态属性引用</strong>的对象；</li>
<li>方法区中的<strong>常量引用</strong>的对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul>
<li><strong>标记-清除法（MarkSweep）</strong>：标记出要回收的对象，然后回收所有被标记的对象。<ul>
<li>缺点：执行效率不稳定，标记和清除两个过程的执行效率都随对象数量增长而降低；并且会造成内存空间的碎片化问题</li>
</ul>
</li>
<li><strong>标记-复制法（copying）</strong>：划分为大小相等的两块，每次只用一块，当这一块的内存用完了，将存活的内存复制到另一块，这一块的内存直接回收<ul>
<li>缺点：始终有一半的内存是空闲的，造成了空间的浪费</li>
<li>所以新生代垃圾回收一般使用这个方法，因为新生代<strong>存活对象</strong>较少</li>
</ul>
</li>
<li><strong>标记-整理法（Mark Compack）</strong>： 让所有存活的对象都向内存空间一端移动，然后直接清理掉边界之外的内存。<ul>
<li>缺点：移动存活对象是个极为负重的工作，并且还要stop the word</li>
<li>因此老年代主要用这种方法。</li>
</ul>
</li>
</ul>
<h3 id="什么是STW-（stop-the-world）："><a href="#什么是STW-（stop-the-world）：" class="headerlink" title="什么是STW （stop the world）："></a>什么是STW （stop the world）：</h3><p><strong>STW：</strong> stop the world。是<strong>在垃圾回收算法执行过程中，需要将JVM内存冻结的一种状态</strong>。</p>
<p><strong>在STW状态下，JAVA的所有线程都是停止执行的 （GC线程除外）</strong>，native方法可以执行，但是不能与JVM交互。</p>
<p>GC各种算法优化的重点，就是减少STW，</p>
<h3 id="JVM垃圾回收器"><a href="#JVM垃圾回收器" class="headerlink" title="JVM垃圾回收器"></a>JVM垃圾回收器</h3><ul>
<li><strong>Serial串行</strong>：只有一个线程进行垃圾回收，进行垃圾收集时，必须暂停其他所有工作线程。比较古早。</li>
<li><strong>Parallel并行</strong>：在串行基础上，使用多个线程进行GC。</li>
<li>⭐<strong>CMS（concurrent Mark sweep）</strong>：核心思想，就是<strong>将STW打散，让一部分GC线程与用户线程并发执行</strong>。整个GC过程分为四个阶段：<ul>
<li><strong>初始标记</strong>阶段：进行<strong>短暂的STW</strong>，<strong>只标记出根对象直接引用的对象</strong>。</li>
<li><strong>并发标记</strong>阶段：继续标记其他对象，从GC Root开始，在整个堆中，<strong>标记所有可达的对象</strong>。与用户线程<strong>并发执行</strong>。</li>
<li><strong>重新标记</strong>阶段：<strong>短暂的STW</strong>，这一步的目的是，<strong>标记那些在并发标记阶段中产生变动的对象</strong>。</li>
<li><strong>并发清除</strong>：<strong>并发执行</strong>，将未标记的对象进行清除。清除过程中，应用程序又会产生新的垃圾，这些垃圾叫做<strong>浮动垃圾。浮动垃圾会留到下一次GC过程中被清除</strong>。</li>
</ul>
</li>
<li>⭐<strong>G1（Garbarage First）</strong>：它的内存模型实际上是不分代的（逻辑上分代）。在内存中，不在分为新生代和老年代，而是<strong>划分成一个个的region，每个region可以隶属于不同的分代</strong>。同时<strong>维护一个优先级列表</strong>，跟踪各个region回收的价值，<strong>优先收集价值高的region</strong>。G1回收器回收过程分为下面的阶段：<ul>
<li><strong>初始标记阶段</strong>：<strong>STW</strong>，标记从GCRoot直接可达的对象；</li>
<li><strong>并发标记</strong>：和用户并发执行，从GC Root开始对堆中对象进行可达性分析，标记所有可达的对象。</li>
<li><strong>筛选回收</strong>：<strong>STW</strong>，选择多个region作为回收集，把回收集中region中的存活对象移动至空的region中，再清理掉旧Region中的整个空间。</li>
<li><strong>并发清除</strong>：并发地清除未被标记的对象。不会STW。</li>
</ul>
</li>
</ul>
<h3 id="什么是Minor-GC、Major-GC、FullGC"><a href="#什么是Minor-GC、Major-GC、FullGC" class="headerlink" title="什么是Minor GC、Major GC、FullGC"></a>什么是Minor GC、Major GC、FullGC</h3><p>jvm进行垃圾回收时，并不是每次都对新生代、老年代和方法区的内存进行回收的，<strong>大部分时候回收的都是新生代</strong>。</p>
<p>针对hotpot虚拟机的实现，它里面的GC按照回收区域又分为两大类：<strong>部分收集（Partial GC），整堆收集 （Full GC ）</strong></p>
<ul>
<li><strong>部分收集</strong>（partial GC），指不是完整收集整个Java堆的垃圾收集。其中又分为：<ul>
<li>新生代收集（<strong>Minor GC&#x2F;Young GC</strong>）：只是新生代的垃圾收集；</li>
<li>老年代收集（<strong>Major GC&#x2F;Old GC</strong>）：只是老年代的垃圾收集；<ul>
<li><strong>只有CMS垃圾收集器会单独收集老年代</strong></li>
<li>很多时候 Major GC 和 Full GC混合使用，需要具体分辨是老年代回收还是整堆回收。</li>
</ul>
</li>
<li>混合收集（<strong>Mixed GC</strong>）：收集<strong>整个新生代</strong> 以及 <strong>部分老年代</strong>的垃圾；<ul>
<li>目前<strong>只有G1垃圾收集器会Mixed GC 。</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>整堆收集（Full GC）</strong>：收集整个<strong>Java堆</strong>和<strong>方法区</strong>的垃圾。</li>
</ul>
<h2 id="什么时候会触发Full-GC"><a href="#什么时候会触发Full-GC" class="headerlink" title="什么时候会触发Full GC"></a>什么时候会触发Full GC</h2><p><strong>当Eden区满了，就会触发Minor GC</strong>。但是Full GC相对复杂，有以下条件：</p>
<ul>
<li>**调用System.gc()**：这种方式只是建议进行full gc，JVM不一定真去执行。</li>
<li><strong>老年代空间不足</strong>：引起老年代空间不足的情况主要发生在<strong>大对象直接进入老年代、长期存活的对象进入老年代</strong>的时候。<ul>
<li>因此为了避免Full GC，可以尽量不去创建大的对象。同时也可以扩大新生代区域，让对象尽量在新生代就被回收掉。或者提升新生代对象晋升到老年代的阈值，让对象在新生代多存活一段时间。</li>
</ul>
</li>
<li><strong>空间担保失败</strong>：这种情况发生在Minor GC前，老年代最大连续内存空间小于新生代中的对象大小总和的情况下。<strong>如果空间担保失败(指最大连续空间小于历次晋升老年代的对象的平均值，或者不允许空间担保)则会进行Full GC 。</strong></li>
<li><strong>Concurrent Mode Failure</strong>：执行 <strong>CMS GC</strong> 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。</li>
</ul>
<h3 id="类生命周期"><a href="#类生命周期" class="headerlink" title="类生命周期"></a>类生命周期</h3><ol>
<li>加载： 将类的字节码文件加载到内存中，并创建该类的.Class对象</li>
<li>验证： 验证字节码文件是否符合JVM规范</li>
<li>准备： 为类的静态变量分配内存空间，并设置初始值</li>
<li>解析：这一阶段主要是<strong>将符号引用转换为直接引用</strong>。</li>
<li>初始化：执行构造器方法的过程，这一阶段是类主动使用的阶段。</li>
<li>使用： 在该类被加载和初始化后，就可以使用该类创建对象，调用类的方法。</li>
<li>卸载：当一个类不再被引用，并且也没有活跃的实例时，JVM会卸载该类。</li>
</ol>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><ol>
<li>通过类的<strong>全限定名</strong> 来获取<strong>此类的二进制字节流</strong></li>
<li>将这个<strong>字节流代表</strong>的 <strong>静态数据结构</strong> 转变为 <strong>方法区的运行时数据结构</strong></li>
<li>在内存区<strong>生成</strong>一个 代表这个类的 java.lang**.Class 对象**，作为 <strong>方法区这个类的各种数据的访问入口</strong>。</li>
</ol>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li><strong>启动类加载器</strong>：又称为根类加载器，是<strong>JVM的一部分</strong>，<strong>负责加载java的核心类库</strong>。</li>
<li><strong>扩展类加载器</strong>：用来<strong>加载java的扩展库</strong>，<strong>JVM的实现</strong>会提供一个<strong>扩展库目录</strong>，该类加载器在该目录里查找并加载扩展类。</li>
<li><strong>系统类加载器</strong>：根据<strong>java应用的类路径</strong>来加载类，一般java应用的类都是它加载的。可以通过ClassLoader.getSystemClasssLoader() 来获取</li>
<li><strong>用户类加载器：</strong>用户可以通过继承java.lang.classLoader的方式自行实现类加载器。</li>
</ul>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>当一个类加载器收到加载类的请求时，会首先请求父类加载器进行类加载，如果加载成功则类加载结束。否则由子类类加载器进行加载。</p>
<h3 id="使用双亲委派机制的好处"><a href="#使用双亲委派机制的好处" class="headerlink" title="使用双亲委派机制的好处"></a>使用双亲委派机制的好处</h3><ul>
<li><strong>避免类的重复加载</strong>：如果父类加载器已经加载了一个类，那么子类不会再次加载。<strong>节省了内存</strong>。</li>
<li><strong>确保类的安全性和一致性</strong>：Java核心类库由 启动类加载器 加载，可以<strong>防止恶意代码替换核心类库</strong>，保证核心类库的安全性和一致性。</li>
<li><strong>防止类的篡改</strong>： 父类加载器加载的类不会被子类加载器替换，防止了类的篡改。</li>
<li><strong>方便类加载器的扩展和自定义</strong>： 可以通过扩展classLoader类来实现类加载器的自定义，通过双亲委派机制，可以<strong>方便的扩展和自定义类加载器的功能，满足不同的加载需求。</strong></li>
</ul>
<h3 id="如何破坏类加载机制"><a href="#如何破坏类加载机制" class="headerlink" title="如何破坏类加载机制"></a>如何破坏类加载机制</h3><ul>
<li><strong>自定义类加载器</strong>： 可以<strong>重写LoadClass方法</strong>，实现自己的类加载逻辑，不再委托给父类加载器。但是自定义类加载器需要遵循一定的类加载规则，以确保类加载的一致性和正确性。</li>
<li><strong>使用Thread.currentThread.setContextClassLoader方法</strong>：通过该方法<strong>设置当前线程的上下文类加载器</strong>，将类加载的<strong>委派顺序改变</strong>，这样可以绕过双亲委派机制，直接指定类加载器进行加载。</li>
</ul>
<h1 id="五、MySQL"><a href="#五、MySQL" class="headerlink" title="五、MySQL"></a>五、MySQL</h1><h2 id="0-基础"><a href="#0-基础" class="headerlink" title="0.基础"></a>0.基础</h2><h3 id="一条SQL执行的步骤："><a href="#一条SQL执行的步骤：" class="headerlink" title="一条SQL执行的步骤："></a>一条SQL执行的步骤：</h3><ul>
<li><strong>权限检查：</strong>检查用户是否有执行该语句的权限。</li>
<li><strong>查询缓存（仅适用于8.0版本之前）：</strong>如果缓存中有该语句的结果，就从缓存中返回结果。</li>
<li><strong>语法分析和语义检查：</strong>由MySQL<strong>解析器</strong>验证语句的合法性。</li>
<li><strong>查询优化</strong>：MySQL的<strong>查询优化器</strong>根据查询的复杂度、索引情况、统计信息等因素选择最佳的查询计划。</li>
<li><strong>执行查询计划：</strong>涉及表扫描、索引的匹配、数据的过滤和排序等操作。</li>
<li><strong>数据检索和返回：</strong> <strong>执行器</strong>根据查询计划获取数据，并将结果返回客户端。如果涉及查询大量数据，MySQL可能会使用临时表来存储中间结果，并进行排序和分页操作。</li>
</ul>
<h2 id="1-索引"><a href="#1-索引" class="headerlink" title="1. 索引"></a>1. 索引</h2><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类:"></a>索引分类:</h3><ul>
<li>按<strong>数据结构</strong>分类：B+树索引、Hash索引、Full-text索引</li>
<li>按<strong>物理存储</strong>分类：聚簇索引（主键索引）、二级索引</li>
<li>按<strong>字段特性</strong>分类：主键索引、普通索引、唯一索引、前缀索引</li>
<li>按<strong>字段个数</strong>分类：唯一索引、联合索引。</li>
</ul>
<h3 id="B-树索引（主键索引-or-二级索引）"><a href="#B-树索引（主键索引-or-二级索引）" class="headerlink" title="B+树索引（主键索引 or 二级索引）"></a>B+树索引（主键索引 or 二级索引）</h3><ul>
<li>多叉树、<strong>叶子节点才存放数据、非叶子节点只存放索引</strong></li>
<li>每个节点中的数据是按照主键顺序存放的。</li>
<li>叶子节点之间通过<strong>双向链表</strong>连接。</li>
<li>对<strong>主键索引</strong>来说，<strong>叶子节点存放的就是实际数据</strong>。</li>
<li>对<strong>二级索引</strong>来说，<strong>叶子节点存放的是主键值</strong>，而不是实际数据。<strong>回表就是指</strong>需要查询二级索引树和主键索引树两个B+树才能查到数据。</li>
<li>当查到的数据在二级索引的叶子节点就能找到时，此时就<strong>不用再回表查询</strong>了。<strong>这被称为覆盖索引</strong></li>
<li>相比于B树，<strong>B+树更适合于范围查询</strong>，因为其<strong>叶子节点用双向链表相连</strong>；而且<strong>B树的非叶子节点也要存储数据</strong>，B+树单节点数据量更小。</li>
<li>相比于二叉树，<strong>B+树能保证高度始终在3-4层左右，对IO更友好</strong>。</li>
<li>相比于Hash，查询复杂度o(1)优于B+树，但<strong>hash不适合范围查询</strong>。</li>
</ul>
<p><strong>B+树索引的优势</strong>：相比于B树和二叉树来说，最大的优势在于查询效率高，即使在数据量很大的情况下，<strong>磁盘的IO次数依然维持在3-4次</strong>。</p>
<h3 id="联合索引-amp-索引下推优化"><a href="#联合索引-amp-索引下推优化" class="headerlink" title="联合索引 &amp; 索引下推优化"></a>联合索引 &amp; 索引下推优化</h3><ul>
<li><strong>联合索引的最左匹配原则：在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配</strong></li>
<li><strong>索引下推优化：</strong><ul>
<li>对于联合索引（a, b），在执行 <code>select * from table where a &gt; 1 and b = 2</code> 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？</li>
<li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li>
<li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</li>
</ul>
</li>
<li><strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。</li>
<li>MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是”30%”）很高的时候，它一般会忽略索引，进行全表扫描。</li>
</ul>
<h3 id="⭐索引失效的情况"><a href="#⭐索引失效的情况" class="headerlink" title="⭐索引失效的情况"></a>⭐索引失效的情况</h3><ul>
<li>使用<strong>左或者左右模糊匹配</strong>的时候，会造成索引失效；</li>
<li>当在<strong>查询条件中对索引做了计算、函数、类型转换操作</strong>，这些情况下都会造成索引失效；</li>
<li>在<strong>联合索引</strong>中，没有遵循<strong>最左匹配原则</strong>，导致索引失效；</li>
<li>在 <strong>WHERE 子句</strong>中，如果在 <strong>OR 前</strong>的条件列是<strong>索引列</strong>，而在 <strong>OR 后</strong>的条件列<strong>不是索引列</strong>，那么索引会失效。</li>
<li><strong>使用like “%xxx”,索引一定会失效么？</strong>：<ul>
<li>如果数据表中的字段<strong>只有主键+二级索引</strong>，那么即使使用了左模糊匹配，也不会走全表扫描，而是<strong>走全扫描二级索引树</strong>。</li>
<li>我们都知道联合索引要遵循最左匹配才能走索引，但是<strong>如果数据表中的字段都是索引</strong>的话，即使查询过程中，<strong>没有遵循</strong>最左匹配原则，也是会<strong>走全扫描二级索引树</strong>。</li>
</ul>
</li>
</ul>
<h3 id="优化索引的方法"><a href="#优化索引的方法" class="headerlink" title="优化索引的方法"></a>优化索引的方法</h3><ul>
<li><strong>前缀索引优化</strong><ul>
<li>顾名思义，就是使用某个字段的字符串的前几个字符建立索引。</li>
<li><strong>使用前缀索引是为了减少索引字段大小，可以增加一个索引页中存储的索引值</strong>，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助减少索引项的大小。</li>
<li>前缀索引有一定的<strong>局限性</strong>：<ul>
<li><strong>order By 无法使用前缀索引</strong>；</li>
<li><strong>无法把前缀索引作为覆盖索引</strong>；</li>
</ul>
</li>
</ul>
</li>
<li><strong>覆盖索引优化</strong><ul>
<li>建立覆盖索引，从二级索引中查询得到记录，可以<strong>避免回表</strong>的操作。</li>
<li>同时，使用覆盖索引，不需要查询出包含整条记录的所有信息，大大<strong>减少了IO操作</strong>。</li>
</ul>
</li>
<li><strong>主键索引最好是自增的</strong><ul>
<li>如果我们使用自增主键，每次插入一条记录，都是追加操作，<strong>不需要重新移动数据</strong>，因此效率很高。</li>
<li>如果使用非自增主键，可能会导致出现<strong>页分裂</strong>的问题，<strong>页分裂 还有可能导致大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</strong></li>
<li>另外，主键字段的长度不要过大，<strong>主键字段长度越小，意味着二级索引的叶子节点越小</strong>（二级索引叶子节点存放的是主键值），这样二级索引占用的空间也就越小。</li>
</ul>
</li>
<li><strong>防止索引失效</strong></li>
</ul>
<h3 id="索引存储结构"><a href="#索引存储结构" class="headerlink" title="索引存储结构"></a>索引存储结构</h3><ul>
<li>根据物理存储分类，索引分为<strong>聚簇索引和二级索引</strong>。<ul>
<li>对于<strong>InnoDB</strong>引擎，聚簇索引的叶子节点存放的是实际数据，而二级节点存放的是主键值，而不是实际数据。</li>
<li>对于<strong>MyISAM</strong>引擎，聚簇索引的叶子节点存放的是具体数据的地址。</li>
</ul>
</li>
<li>MySQL的<strong>默认存储引擎</strong>是<strong>InnoDB</strong>，它采用<strong>B+树</strong>作为索引数据结构。</li>
<li><strong>MyISAM 存储引擎</strong>支持多种索引数据结构，比如 B+ 树索引、R 树索引、Full-Text 索引。MyISAM 存储引擎在创建表时，创建的主键索引默认使用的是 <strong>B+ 树索引</strong>。</li>
<li>虽然，I<strong>nnoDB 和 MyISAM 都支持 B+ 树索引</strong>，但是它们数据的存储结构实现方式<strong>不同</strong>:<ul>
<li><strong>InnoDB</strong> 存储引擎：B+ 树索引的叶子节点保存<strong>数据本身</strong>；</li>
<li><strong>MyISAM 存</strong>储引擎：B+ 树索引的叶子节点保存数据的<strong>物理地址；</strong></li>
</ul>
</li>
<li>对聚簇索引的理解：<ul>
<li><strong>聚簇索引具有唯一性</strong>：由于聚簇索引是将索引和数据放在一块，所以一个表仅有一个聚簇索引。</li>
<li>⭐（1）聚簇索引<strong>默认是主键</strong>。（2）如果表中没有定义主键，InnoDB会<strong>选择第一个唯一的非空索引</strong>代替。（3）如果没有这样的索引，InnoDB 会<strong>隐式定义一个主键作为聚簇索引。</strong></li>
</ul>
</li>
</ul>
<h3 id="MySQL-表的物理结构"><a href="#MySQL-表的物理结构" class="headerlink" title="MySQL 表的物理结构"></a>MySQL 表的物理结构</h3><ul>
<li>MySQL的<strong>表数据</strong>是以<strong>页</strong>的形式存放的，页在磁盘中<strong>不一定是连续的</strong>。</li>
<li>页空间是16K，并不是所有的空间都是用来存放数据的，会有一些固定的信息，如页头、页尾、页码、校验码等。</li>
<li>在B+树中，叶子节点和非叶子节点的数据结构是一样的，区别在于，<strong>叶子节点</strong>存放的是<strong>实际的行数据</strong>，而<strong>非叶子节点</strong>存放的是<strong>主键和页号。</strong></li>
</ul>
<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240429195215797.png" alt="image-20240429195215797" style="zoom: 67%;" />



<ul>
<li>索引结构不会影响单表最大行数，2000W也只是推荐值，<strong>超过了这个值可能会导致B+树层级更高，影响查询性能</strong>。</li>
</ul>
<h2 id="2-事务"><a href="#2-事务" class="headerlink" title="2.  事务"></a>2.  事务</h2><h3 id="2-0-什么是-事务-amp-事务四大特性ACID"><a href="#2-0-什么是-事务-amp-事务四大特性ACID" class="headerlink" title="2.0 什么是 事务 &amp; 事务四大特性ACID"></a>2.0 什么是 事务 &amp; 事务四大特性ACID</h3><h4 id="什么是事务："><a href="#什么是事务：" class="headerlink" title="什么是事务："></a><strong>什么是事务：</strong></h4><p>事务是指程序中一系列严密的逻辑操作，而且所有的操作必须全部成功完成，否则在每个操作中所做的所有更改都会被撤销。</p>
<h4 id="事务的四大特性ACID："><a href="#事务的四大特性ACID：" class="headerlink" title="事务的四大特性ACID："></a><strong>事务的四大特性ACID：</strong></h4><ul>
<li><strong>原子性：</strong>事务的所有操作要么都执行，要么不执行；</li>
<li><strong>一致性：</strong>事务在执行前后，数据库必须满足一致性约束。只能使数据库从一个一致性状态转变为一致性状态；</li>
<li><strong>隔离性：</strong>一个事务所进行的修改操作在提交事务时，对其他事务是不可见的；</li>
<li><strong>持久性：</strong>一旦事务提交，则所做的修改会永久保存到数据库；</li>
</ul>
<h4 id="ACID如何保证的："><a href="#ACID如何保证的：" class="headerlink" title="ACID如何保证的："></a>ACID如何保证的：</h4><ul>
<li><strong>原子性：通过事务日志 或 undo log 来实现。</strong>事务日志记录了事务的所有操作。在事务提交之前，所有的修改操作被写入事务日志，如果失败或回滚，DBMS可以使用事务日志将数据库恢复到事务开始前的状态。</li>
<li><strong>隔离性：通过 锁机制 或 多版本并发控制MVCC 实现。</strong>锁机制保证一个事务在执行期间，被修改的数据不会被其他事务修改或读取。 MVCC使用版本号或时间戳跟踪事务对数据的修改，在读取操作中可以避免锁的使用，提高并发性能。</li>
<li><strong>持久性：通过将事务的修改操作持久化到磁盘上来实现的。</strong>在事务提交之后，DBMS会将事务的修改写入数据库的数据文件或日志文件，并确保这些修改在系统故障或崩溃后仍然可以恢复。</li>
<li><strong>一致性：一致性可以说是原子性、隔离性、持久性的最终目标，也是通过它们来进行保证的。</strong></li>
</ul>
<h3 id="2-1-事务隔离级别"><a href="#2-1-事务隔离级别" class="headerlink" title="2.1 事务隔离级别"></a>2.1 事务隔离级别</h3><h4 id="四个隔离级别："><a href="#四个隔离级别：" class="headerlink" title="四个隔离级别："></a><strong>四个隔离级别：</strong></h4><ul>
<li><p>读未提交（啥都解决不了）</p>
</li>
<li><p>读已提交 （解决了脏读）</p>
</li>
<li><p>可重复读 （解决了脏读，不可重复读，InnoDB默认的隔离级别）</p>
</li>
<li><p>串行化 （解决了脏读，不可重复读以及幻读，但是效率最低，不轻易使用。）</p>
</li>
<li><p>InnoDB 引擎的<strong>默认隔离级别是 可重复读</strong>，但是它很大程度上避免了幻读现象。解决的方案有两种：</p>
<ul>
<li>针对<strong>快照读（普通select）</strong>，是通过<strong>MVCC</strong>方式解决了幻读。因为可重复读隔离级别下，事务执行<strong>过程中看到的数据</strong>，一直<strong>跟</strong>这个<strong>事务启动时看到的数据是一致的</strong>，即使中途有其他事务插入了一条数据，是查询不出来的。</li>
<li>针对<strong>当前读（select … for update等语句）</strong>，是通过<strong>next-key lock(记录锁 + 间隙锁)<strong>方式解决了幻读。因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被</strong>阻塞</strong>，无法成功插入，所以就很好了避免幻读问题。</li>
</ul>
</li>
<li><p>InnoDB引擎为了解决 <strong>可重复读</strong> 隔离级别使用 <strong>当前读</strong> 而造成的<strong>幻读</strong>问题，引出了<strong>间隙锁</strong>（<strong>即使这样也只是最大程度避免幻读，没有完全解决幻读</strong>）</p>
<ul>
<li><p>表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发生。</p>
</li>
<li><p>事务 A 执行了这面这条锁定读（for update）语句后，就在对表中的记录加上 id 范围为 (2, +∞] 的 next-key lock（next-key lock 是间隙锁+记录锁的组合）。<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240430153508438.png" alt="image-20240430153508438"></p>
<p>然后，事务 B 在执行插入语句的时候，判断到插入的位置被事务 A 加了 next-key lock，于是<strong>事物 B 会生成一个插入意向锁</strong>，同时<strong>进入等待</strong>状态，<strong>直到</strong>事务 <strong>A 提交了事务</strong>。这就<strong>避免了由于事务 B 插入新记录而导致事务 A 发生幻读</strong>的现象。</p>
</li>
</ul>
</li>
</ul>
<h4 id="四个隔离级别是如何实现的"><a href="#四个隔离级别是如何实现的" class="headerlink" title="四个隔离级别是如何实现的"></a>四个隔离级别是如何实现的</h4><ul>
<li>对于 <strong>读未提交</strong> 级别，实现方式相对简单，因为可以读到未提交事务修改的数据，所以<strong>直接读取最新的数据就好</strong>了。</li>
<li>对于 <strong>读已提交</strong> 和 <strong>可重复读</strong> 级别来说，他们是<strong>通过read view来实现</strong>的，它们的区别在于：<strong>读已提交</strong>是在 <strong>每个语句执行前</strong> 都会重新生成 read view，而<strong>可重复读</strong> 是在 <strong>启动事务时</strong> 生成一个read view，然后整个事务期间都在使用这个read view</li>
<li>对于 <strong>串行化</strong> 级别，通过添加<strong>读写锁（排他锁）</strong>的方式实现。</li>
</ul>
<h2 id="3-MySQL锁"><a href="#3-MySQL锁" class="headerlink" title="3.  MySQL锁"></a>3.  MySQL锁</h2><h3 id="全局锁："><a href="#全局锁：" class="headerlink" title="全局锁："></a><strong>全局锁</strong>：</h3><ul>
<li><p>使用全局锁后，整个数据库就处于只读状态了。这时其他线程执行以下操作，都会被阻塞：</p>
<ul>
<li>对<strong>数据的增删改</strong>操作，比如 insert、delete、update等语句；</li>
<li>对<strong>表结构的更改</strong>操作，比如 alter table、drop table 等语句。</li>
</ul>
</li>
<li><p>全局锁主要用于做<strong>全库逻辑备份</strong>，这样在备份期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
</li>
<li><p>如果备份花费很长时间，在这个时间段内业务只能读数据，造成业务的停滞。</p>
</li>
<li><p>如果数据库的引擎支持 <strong>可重复读</strong> 的隔离级别，那么在<strong>备份数据库之前先开启事务</strong>，会先创建read view ,然后整个事务执行期间都在使用这个read view，而且由于MVCC的支持，<strong>备份期间业务依然可以对数据进行更新操作</strong>。（<strong>InnoDB引</strong>擎默认的隔离级别正是可重复读，<strong>因此可采用这种方式备份库</strong>，而 <strong>MyISAM不支持事务</strong>，备份库时就<strong>只能使用全局锁</strong>）</p>
</li>
</ul>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p><strong>表级锁有这几种：</strong></p>
<ul>
<li>表锁</li>
<li>元数据锁 （MDL）</li>
<li>意向锁</li>
<li>Auto-INC 锁</li>
</ul>
<p><strong>（1） 表锁</strong></p>
<ul>
<li>表锁除了会限制别的线程读写之外，也<strong>会限制本线程接下来的读写操作</strong>。</li>
<li>尽量<strong>避免在使用InnoDB 引擎的表使用表锁</strong>，因为表锁的颗粒度太大，影响并发性能，<strong>InnoDB 实现了粒度更细的行级锁，更牛逼。</strong></li>
</ul>
<p><strong>（2）元数据锁</strong></p>
<ul>
<li><p><strong>不用显式</strong>的使用，因为我们在对数据库表进行操作时，会自动给这个表加上MDL；</p>
<ul>
<li>对<strong>表进行crud</strong>的时候，添加的时<strong>MDL读锁；</strong></li>
<li>对<strong>表结构</strong>进行变更的时候，添加的是<strong>MDL写锁</strong>；</li>
</ul>
</li>
<li><p>MDL在事务提交之后才会释放，这意味着<strong>事务执行期间，MDL是一直持有的。</strong></p>
</li>
<li><p>申请MDL锁的操作会形成一个队列，队列中，<strong>写锁的优先级高于读锁</strong>，一旦出现MDL写锁等待，<strong>会阻塞后续该表中所有的CRUD操作</strong>（因为拿不到读锁了）。</p>
</li>
</ul>
<p><strong>（3）意向锁</strong></p>
<ul>
<li>在使用 InnoDB 引擎的表里对某些记录加上<strong>「共享锁」</strong>之前，需要先在表级别加上一个「<strong>意向共享锁」</strong>；</li>
<li>在使用 InnoDB 引擎的表里对某些纪录加上<strong>「独占锁」</strong>之前，需要先在表级别加上一个<strong>「意向独占锁</strong>」；</li>
</ul>
<p><strong>意向锁是表级锁</strong>，<strong>不会和行级</strong>的共享锁和独占锁发生<strong>冲突</strong>，而且<strong>意向锁之间也不会发生冲突</strong>，只会和共享<strong>表锁</strong>和独占<strong>表锁</strong>发生冲突</p>
<p><strong>意向锁的目的是为了快速判断表里是否有记录被加锁，</strong>如果表被上了意向独占锁，表明表内有数据被加了独占锁，这样其他线程就不用再去逐条看是哪一条记录被添加了独占锁。</p>
<p><strong>（4）Auto-INC 锁</strong></p>
<ul>
<li>设置主键自增时，再插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是<strong>通过Auto_INC锁实现</strong>的。</li>
<li><strong>auto-inc是一种特殊的表锁机制</strong>，<strong>锁不再是一个事务提交之后才释放，而是在执行完插入语句之后就会立即释放。</strong></li>
<li>在插入数据时，会添加一个<strong>表级别</strong>的Auto-INC锁，然后给自增的字段赋值，等<strong>插入语句执行完</strong>后，才会把Auto-Inc<strong>释放。</strong></li>
<li><strong>InnoDB 提供了一个轻量级锁</strong>，插入时，会给自增字段加上轻量级锁，然后给该字段赋值自增，之后就释放了，<strong>不用再等插入语句结束后再释放。</strong></li>
</ul>
<h3 id="行级锁（只有InnoDB-支持）"><a href="#行级锁（只有InnoDB-支持）" class="headerlink" title="行级锁（只有InnoDB 支持）"></a>行级锁（只有InnoDB 支持）</h3><p><strong>普通的select语句是不会对记录进行加锁的</strong>，因为它属于快照读。如果要在查询时对记录加锁，可以使用下面这种方式，查询加锁的方式称为<strong>锁定读</strong>：</p>
<ul>
<li><code>select ... lock in share mode (加共享锁)</code></li>
<li><code>select ... for update（加独占锁）</code></li>
</ul>
<p><strong>行级锁有四类：</strong></p>
<ul>
<li><strong>Record lock</strong>，记录锁，也就是仅锁一条记录。<ul>
<li>记录锁有 <strong>共享锁</strong> 和 <strong>独占锁</strong> 之分。如果一个事务对当前记录加了共享锁，那么其他事务可以加共享锁但是不能加独占锁；如果是加了独占锁，那么其他事务既不能加独占锁也不能加共享锁。</li>
</ul>
</li>
<li><strong>Gap Lock</strong>， 间隙锁，锁定一个范围，但是不包含记录本身，<strong>只存在于可重复读隔离级别</strong>；目的是为了解决该级别下 <strong>幻读</strong>的现象。<ul>
<li><strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong></li>
</ul>
</li>
<li><strong>Next-Key Lock</strong> , 是上面两种锁的组合，<strong>锁定一个范围，并且锁定记录本身。</strong></li>
<li><strong>插入意向锁：</strong> 名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级锁。</strong><ul>
<li>当一个事务想插入一条记录，但是发现插入位置有其他事务设置的间隙锁，那么当前插入操作会阻塞，直到拥有这些间隙锁的事务提交为止。</li>
<li>在此期间，该事务会生成一个插入意向锁，表明有业务向再这个区间插入新纪录，但是现在在等待。</li>
</ul>
</li>
</ul>
<h2 id="4-日志"><a href="#4-日志" class="headerlink" title="4. 日志"></a>4. 日志</h2><h3 id="MySQL的三个日志："><a href="#MySQL的三个日志：" class="headerlink" title="MySQL的三个日志："></a>MySQL的三个日志：</h3><ul>
<li>undo log：回滚日志，是InnoDB<strong>存储引擎层</strong>生成的日志，实现事务的<strong>原子性</strong>。主要用于<strong>事务回滚和MVCC</strong>。</li>
<li>redo log：重做日志，是InnoDB<strong>存储引擎层</strong>生成的日志，实现事务的<strong>持久性</strong>，主要用于<strong>掉电等故障恢复</strong>。</li>
<li>binlog：二进制日志，是<strong>server层</strong>生成的日志，主要用于<strong>数据备份和主从复制</strong>（可以认为是为了实现事务的<strong>一致性</strong>）。</li>
</ul>
<h3 id="关于undo-log"><a href="#关于undo-log" class="headerlink" title="关于undo log:"></a>关于undo log:</h3><ul>
<li><strong>（作用1）</strong>undo log即回滚日志，用于在事务提交失败的时候进行回滚操作时使用，用于实现<strong>原子性</strong>。</li>
<li>每当InnoDB引擎对一条记录进行 <strong>增删改</strong> 的时候（这时候会<strong>自动隐式的开启事务</strong>），需要把回滚时需要的信息记录到 undo log 中：<ul>
<li>插入时，记录插入记录的主键值，回滚时删除就好；</li>
<li>删除时，记录该记录的所有内容，回滚时插入到表内就好；</li>
<li>更新时，记录被更新列的旧值，回滚时恢复就好。</li>
</ul>
</li>
<li><strong>（作用2）</strong>undo log的另一个作用是：<strong>通过readview + undo log来实现MVCC</strong>（多版本并发控制）：<ul>
<li>首先引入<strong>版本链</strong>：每条记录有两个隐藏列 <strong>trx_id（该记录是被哪个事务修改的）</strong> 和 <strong>roll-pointer （一个指针，可以将这些undo log 串成一个链表，这个链表称为版本链）</strong></li>
<li><strong>读已提交</strong> 和 <strong>可重复读</strong> <strong>两个隔离级别</strong>，他们的<strong>快照读</strong>都是通过read view + undo log来实现的，区别在与<strong>创建readview的时机不同：</strong><ul>
<li>读已提交是在每个select都会生成一个read view；</li>
<li>可重复读是在启动事务时生成一个read view，整个事务期间都在使用这个read view;</li>
</ul>
</li>
<li>两个隔离级别是通过 <strong>事务的read view里的字段</strong> 和 <strong>记录中的两个隐藏列</strong> 进行比对，如果不满足可见，就会顺着 undo log版本链找到满足其可见性的记录，从而控制并发事务访问同一个记录的行为。这就叫<strong>MVCC</strong></li>
</ul>
</li>
</ul>
<h3 id="关于buffer-pool"><a href="#关于buffer-pool" class="headerlink" title="关于buffer pool:"></a>关于buffer pool:</h3><p>引入buffer pool是为了提升读写性能，<strong>buffer pool中缓存的是数据页</strong>（默认16kb）：</p>
<ul>
<li>如果读记录时，该记录在缓冲池中，那么就从缓冲池中读，否则去磁盘中读；</li>
<li>修改记录时，如果记录存在于缓冲池中，那么直接修改该记录在缓冲池中的页，并将其标志为脏页。<strong>脏页不会立即写入磁盘，后台线程会挑选一个合适的时机将其写入磁盘</strong>。</li>
</ul>
<p>MySQL<strong>启动的时候</strong>，InnoDB会为 buffer pool中申请<strong>一片空闲空间，随着程序运行，磁盘上的页会逐渐放进这些空闲空间中。</strong></p>
<p>当<strong>查询</strong>一条记录的时候，InnoDB是会把<strong>整个页的数据加载到buffer pool</strong>中，页加载后，<strong>再通过页中的 页目录 去定位到某条具体的记录</strong>。</p>
<h3 id="关于redo-log"><a href="#关于redo-log" class="headerlink" title="关于redo log:"></a>关于redo log:</h3><p>引入redo log，是因为<strong>buffer pool是基于内存</strong>的，在断电重启时，<strong>没来得及落盘的脏页数据会丢失</strong>。为了解决这个问题，<strong>当有一条记录需要修改的时候，InnoDB首先更新内存（标记为脏页），然后将本次对这个页的修改以 redo log的形式记录下来。</strong></p>
<p>随后，后台线程会在合适的时机将脏页写到磁盘中。</p>
<ul>
<li>redo log 是<strong>物理日志</strong>，记录了<strong>某个数据页做了什么修改</strong>，比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志。</li>
<li>事务提交时，只用<strong>先将redo log持久化到磁盘</strong>中就行，（内存中的脏页是在合适的时机进行落盘的）。<strong>哪怕系统崩溃发生内存掉电重启，根据磁盘中redo log中的记录进行恢复即可</strong>。</li>
</ul>
<h3 id="redo-log-和-undo-log的区别"><a href="#redo-log-和-undo-log的区别" class="headerlink" title="redo log 和 undo log的区别"></a>redo log 和 undo log的区别</h3><ul>
<li>这俩日志都是<strong>InnoDB引擎</strong>的日志；</li>
<li><strong>redo log是重做日志</strong>，记录了此次事务<strong>完成后</strong>的状态，记录的是更新后的值；</li>
<li><strong>undo log是回滚日志</strong>，记录了此次事务<strong>开始前</strong>的状态，记录的是更新前的值；</li>
<li>如果事务提交之前发生崩溃，会通过undo log回滚事务；如果事务提交之后发生崩溃，会通过redo log恢复事务。</li>
<li><strong>redo log保证了持久性；而undo log保证了原子性</strong>；</li>
</ul>
<h3 id="bin-log与-redo-log的区别"><a href="#bin-log与-redo-log的区别" class="headerlink" title="bin log与 redo log的区别"></a>bin log与 redo log的区别</h3><ol>
<li><strong>适用对象不同：</strong></li>
</ol>
<ul>
<li>bin log是<strong>server层</strong>实现的日志，<strong>所有存储引擎都能用</strong>。</li>
<li>redo log和 undo log都是<strong>InnoDB引擎</strong>实现的日志。</li>
</ul>
<ol start="2">
<li><strong>文件格式不同：</strong></li>
</ol>
<ul>
<li>（<strong>记录逻辑操作</strong>）bin log 有3种格式类型，分别是<strong>statement(默认的格式)、row、mixed</strong>，区别如下：<ul>
<li>StateMent：每一条修改数据的sql都会记录到bin log中（相当于记下了逻辑操作，可以称为逻辑日志）。主从复制中 slave 根据sql语句重现。但是<strong>有动态函数的问题</strong>，比如UUID或now，在主库中执行的结果并不是从库中执行的结果。<strong>这会导致复制的数据不一致。</strong></li>
<li>Row： 记录行数据最终被变成什么样了，不会出现动态函数的问题。但它的<strong>缺点是每行数据的变化结果都会被记录</strong>，比如批量执行update , statement模式就只会记录一个update语句，而 row模式下，有多少次update 就产生多少update语句，使得binlog文件过大。</li>
<li>mixed: 包含了上面的 statement 和 row 模式，他会根据不同的情况自动使用row模式和statement模式。</li>
</ul>
</li>
<li><strong>redo log是物理日志</strong>，记录某个记录在某个数据页做了什么修改。</li>
</ul>
<ol start="3">
<li><strong>写入方式不同</strong>：</li>
</ol>
<ul>
<li><strong>bin log是追加写</strong>，写满一个文件就创建一个新的文件接着写，不会覆盖旧日志，<strong>保留的是全量日志</strong>；</li>
<li><strong>redo log是循环写</strong>，日志空间大小是固定的，全部写满就从头开始，保<strong>存未被刷入磁盘的脏页日志</strong>；</li>
</ul>
<ol start="4">
<li><strong>用途不同:</strong></li>
</ol>
<ul>
<li>bin log用于备份恢复，主从复制（一致性）；</li>
<li>redo log用于掉电等故障恢复 （持久性）；</li>
</ul>
<ol start="5">
<li><strong>写入时机不同</strong>：</li>
</ol>
<ul>
<li>bin log在<strong>事务提交之后</strong>才会被写入磁盘，因此可能会有一定的延迟；</li>
<li>redo log在<strong>事务提交之前</strong>就会被写入磁盘，确保了事务的持久性；</li>
</ul>
<p><strong>如果不小心把整个数据库的数据删除了，那么需要使用bin log来进行恢复，因为bin log保留了全量日志，这也是为什么redo log不行。</strong></p>
<h3 id="主从复制如何实现（依赖bin-log）："><a href="#主从复制如何实现（依赖bin-log）：" class="headerlink" title="主从复制如何实现（依赖bin log）："></a>主从复制如何实现（依赖bin log）：</h3><p>复制的过程就是将<strong>bin log中的数据从主库传输到从库上</strong>。这个过程一般是<strong>异步</strong>的。</p>
<p><strong>MySQL 集群的主从复制过程</strong>分为三个阶段：</p>
<ul>
<li><strong>写入 bin log</strong>： 主库写 bin log，提交事务，并更新本地存储的数据；</li>
<li><strong>同步 bin log</strong>：把bin log复制到所有从库上，每个从库把bin log写到<strong>relay log暂存日志</strong>中，返回给主库一个 复制成功 的响应；</li>
<li><strong>回放 bin log</strong>：回放 bin log，并更新存储引擎中的数据：从库创建一个用于回放 bin log的线程，去读<strong>relay log中继日志</strong>，然后回放bin log更新数据，最终实现主从的数据一致性。</li>
</ul>
<p><strong>主从复制模型</strong>：</p>
<ul>
<li>同步复制：很烂，主库要所有从库都完成复制才能返回客户端的结果，性能很差。</li>
<li><strong>异步复制</strong>：默认的模型，这种模式下，<strong>一旦主库发生宕机，数据就会发生丢失</strong>。</li>
<li><strong>半同步复制</strong>：5.7版本后增加的一种方式，事务线程不用等待所有从库复制成功响应，只<strong>要一部分复制成功响应回来就行。</strong>这种方式兼顾了同步复制和异步复制的有点，<strong>即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险。</strong></li>
</ul>
<h3 id="为什么需要进行两阶段提交？"><a href="#为什么需要进行两阶段提交？" class="headerlink" title="为什么需要进行两阶段提交？"></a>为什么需要进行两阶段提交？</h3><p>在<strong>持久化</strong>redo log和bin log这两份日志的时候，<strong>如果出现半成功的状态</strong>（两个log有一个持久化成功了，一个没成功），就<strong>会造成主从库内容的不一致性。</strong>这是因为<strong>redo log影响主库的内容，bin log影响从库的内容，所以redo log和bin log必须保持一致才能保证主从一致性。</strong></p>
<p><strong>半成功就是下面两种情况：</strong></p>
<ul>
<li><strong>redo log持久化成功了（事务成功提交了），但是bin log没有持久化成功</strong>：这导致主库恢复后根据redo log 有最新的数据，但是bin log会丢失更新，导致主从复制后，从库里保存的也不是最新的数据。</li>
<li><strong>bin log持久化成功了，但是redo log没有持久化成功（redo log没持久化成功，那么恢复时会认为该事务无效）</strong>：因为恢复后MySQL认为该事务失效，所以恢复后直接回滚，主库保留的还是旧值。但是bin log里有最新的数据，在主从复制后又会导致不一致问题。</li>
</ul>
<p><strong>&#x3D;&#x3D;两阶段提交的内容&#x3D;&#x3D;</strong></p>
<p>两阶段提交把单个事务的提交分为两个阶段： <strong>准备阶段（prepare）和 提交阶段（commit）</strong>阶段：</p>
<ul>
<li>在准备阶段，  协调者 询问两个 参与者（也就是这两个日志）有没有准备好。参与者 会做出应答，表示自己准备好了，或者没有准备好。</li>
<li>在提交阶段，如果都准备好了，那么协调者 就可以执行 两个日志的持久化过程；如果有任何一个参与者没有准备好，协调者会宣布事务失效，执行事务的回滚操作。</li>
</ul>
<p><strong>具体内容概括如下：</strong></p>
<ul>
<li><strong>准备阶段：将redo log对应的事务提交状态设置为prepare，然后将redo log刷新到硬盘；</strong></li>
<li><strong>提交阶段：将bin log刷新到磁盘，接着调用引擎的提交事务接口，将redo log状态设置为commit</strong>（将事务设置为commit状态后，把该状态刷入到磁盘 redo log文件）；</li>
</ul>
<h2 id="5-存储引擎（MyISAM-amp-InnoDB）"><a href="#5-存储引擎（MyISAM-amp-InnoDB）" class="headerlink" title="5. 存储引擎（MyISAM &amp; InnoDB）"></a>5. 存储引擎（MyISAM &amp; InnoDB）</h2><h3 id="InnoDB-和-MyISAM-主要区别："><a href="#InnoDB-和-MyISAM-主要区别：" class="headerlink" title="InnoDB  和 MyISAM 主要区别："></a>InnoDB  和 MyISAM 主要区别：</h3><ul>
<li><strong>存储结构</strong>：每个MyISAM在磁盘上存储成三个文件；InnoDB 所有的表保存在同一个数据文件中，其大小只限制于操作系统文件的大小；</li>
<li><strong>事务支持</strong>：InnoDB支持事务，MyISAM不支持；</li>
<li><strong>锁粒度</strong>：MyISAM只支持表级锁，InnoDB支持行级锁；</li>
<li><strong>索引类型</strong>：<strong>MyISAM</strong>的索引为<strong>非聚簇索引</strong>，数据结构是<strong>B树</strong>；<strong>InnoDB</strong> 的索引是<strong>聚簇索引</strong>，数据结构是<strong>B+树</strong>；</li>
<li><strong>主键必须</strong>：<strong>MyISAM允许没有任何索引和主键的表存在</strong>；InnoDB如果没有指定主键或唯一非空索引时，会自动生成一个6字节的主键（用户不可见）；</li>
<li><strong>表的具体行数</strong>：MyISAM保存了表的总行数，InnoDB没有；</li>
<li><strong>外键支持</strong>：MyISAM不支持外键，InnoDB支持；</li>
</ul>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis渐进式rehash（与HashMap进行对比）"><a href="#Redis渐进式rehash（与HashMap进行对比）" class="headerlink" title="Redis渐进式rehash（与HashMap进行对比）"></a>Redis渐进式rehash（与HashMap进行对比）</h2><ul>
<li>在redis中，rehash是为了在进行哈希表扩容时，保持对原有哈希表的读写操作的可用性。</li>
<li>渐进式rehash将<strong>rehash操作分为了多个小步骤</strong>，<strong>每次只迁移少量的键值对</strong>。这样可以将rehash的成本分摊到多次操作中，减少单词操作的耗时。</li>
<li>在渐进式rehash中，<strong>会维护两个哈希表</strong>，一个是原有的<strong>旧哈希表</strong>，另一个是<strong>新的哈希表</strong>。新的键值对会直接添加到新的哈希表中，而旧哈希表中的键值对则会在后续的操作中逐步迁移到新的哈希表中。</li>
<li>在迁移完成之前，Redis会同时维护两个哈希表，并在执行读写操作时，根据需要在两个哈希表中进行操作。</li>
</ul>
<p><strong>与HashMap扩容过程的对比：</strong></p>
<ul>
<li>在HashMap中，当负载因子超过阈值（默认为0.75）时，会触发扩容操作；</li>
<li>扩容过程涉及重新计算哈希码，重新分配元素等操作。具体来说，HashMap会创建一个新的更大的数组（2倍），将所有元素重新分配到新的数据中，并根据哈希表的结构。</li>
<li><strong>扩容是一次性完成的</strong>，即将所有元素重新分配到新数组中。</li>
</ul>
<h2 id="快表quickList-List的数据结构-："><a href="#快表quickList-List的数据结构-：" class="headerlink" title="快表quickList (List的数据结构)："></a>快表quickList (List的数据结构)：</h2><p>快表其实就是 <strong>双向链表 + 压缩列表</strong> 的组合，<strong>一个快表就是一个链表，链表中的每个节点又是一个压缩列表</strong>。所以要先明白压缩列表是啥样的。</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240517145008423.png" alt="image-20240517145008423"></p>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表是为了<strong>减少内存</strong>而开发的。它是由连续内存块组成的顺序型数据结构（类似数组），具体长这样：</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240517145304062.png" alt="image-20240517145304062"></p>
<p>压缩列表<strong>表头有三个字段，表尾有一个字段</strong>：</p>
<ul>
<li><em><strong>zlbytes</strong></em>，记录整个压缩列表<strong>占用对内存字节数</strong>；</li>
<li><em><strong>zltail</strong></em>，记录压缩列表<strong>「尾部」节点距离起始地址有多少字节</strong>，也就是列表尾的偏移量；</li>
<li><em><strong>zllen</strong></em>，记录压缩列表包含的<strong>节点数量</strong>；</li>
<li><em><strong>zlend</strong></em>，标记压缩列表的<strong>结束点</strong>，固定值 0xFF（十进制255）。</li>
</ul>
<p><strong>如果查表头和表尾</strong>，可以通过表头三个字段直接解决，<strong>复杂度o(1)<strong>；如果</strong>查询中间元素</strong>，复杂度就是<strong>o(N)<strong>了，所以</strong>压缩列表不适合存储过多元素。</strong></p>
<p><strong>压缩列表的节点构成</strong>如下：</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240517145901465.png" alt="image-20240517145901465"></p>
<ul>
<li><em><strong>prevlen</strong></em>，<strong>记录了「前一个节点」的长度</strong>，目的是为了实现<strong>从后向前</strong>遍历；</li>
<li><em><strong>encoding</strong></em>，记录了<strong>当前节点实际数据的「类型和长度」</strong>，类型主要有两种：字符串和整数（由此可知，<strong>节点长度并不固定，这与数组不同</strong>）。</li>
<li><em><strong>data</strong></em>，记录了<strong>当前节点的实际数据</strong>，类型和长度都由 <code>encoding</code> 决定；</li>
</ul>
<p><strong>压缩列表的连锁更新问题：</strong></p>
<p>压缩列表<strong>新增某个元素或修改某个元素</strong>时，如果<strong>空间不够</strong>，压缩列表<strong>占用的内存空间就需要重新分配</strong>。而当<strong>新插入的元素较大</strong>时，可能会<strong>导致后续元素的prevlen占用空间都发生变化</strong>（多米诺骨牌似的），从而<strong>引起连锁更新</strong>问题，导致<strong>每个元素空间都要重新分配，造成访问压缩列表性能的下降</strong>。</p>
<ul>
<li>具体是指，如果前一个节点的长度小于254B，那么prevlen用1B空间来保存长度值；如果前一个节点长度大于254字节，那么prevlen属性需要用5B的空间来保存（没有为什么用5字节而不是其他字节，就是这样子设计的）</li>
<li>假如压缩列表中有连续的好多250~253B大小的节点，假如头结点后插入一个长度大于254B的新节点，会导致后面节点因为prevLen字节变为5字节导致整体字节大于254字节，而纷纷重新分配内存空间，成了一个多米诺效应。</li>
</ul>
<p><strong>连锁更新会导致压缩列表的访问性能急剧下降</strong>。</p>
<p>回到快表这个数据结构上来。</p>
<p>向<strong>快表新添加一个元素</strong>的时候，不会像普通的链表那样直接新建一个节点插入，而是<strong>先检查插入位置的压缩列表能不能容纳该元素，如果能容纳就直接保存到压缩列表，否则就新建一个节点完成插入。</strong></p>
<p><strong>快表会控制节点里压缩列表的长度或元素个数，来规避潜在的连锁更新风险。但是并没有解决连锁更新问题（</strong>压缩列表自己都没解决这个问题，快表就更不会解决了，只会尽可能的减少发生连锁更新的可能性。）</p>
<h2 id="跳表（ZSet的数据结构）："><a href="#跳表（ZSet的数据结构）：" class="headerlink" title="跳表（ZSet的数据结构）："></a>跳表（ZSet的数据结构）：</h2><p><strong>Zset对象的底层使用了跳表</strong>。跳表的优势在于支持平均**时间复杂度o(log n)**复杂度的节点查找。</p>
<h3 id="跳表的数据结构"><a href="#跳表的数据结构" class="headerlink" title="跳表的数据结构"></a>跳表的数据结构</h3><p>Zset结构体里面有两个数据结构：跳表 &amp; 哈希表，执行数据插入或者数据更新的时候，会依次在跳表和哈希表中插入或更新相应的数据，从而保证了跳表和哈希表中记录的信息一致。</p>
<p>那么为什么说<strong>Zset的底层是 跳表 而不是 跳表 + 哈希表</strong> 呢？其实<strong>哈希表只是为了在常数时间内获取score权重</strong>，<strong>大部分操作都是跳表实现的。</strong></p>
<p>跳表可以理解为使用<strong>链表形式实现的一种二分查找</strong>。为了提升查找效率，对有序链表建立一级级索引，<strong>每两个节点提取一个节点到索引</strong>层。索引层的每个节点都包含两个指针，一个指向下一个节点；</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240516210648052.png" alt="image-20240516210648052"></p>
<p>与建立一级索引的方式类似，在第一级索引的基础上，每两个节点抽出一个节点到第二级索引，如下：</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240516211658772.png" alt="image-20240516211658772"></p>
<h3 id="跳表的查询过程"><a href="#跳表的查询过程" class="headerlink" title="跳表的查询过程"></a><strong>跳表的查询过程</strong></h3><p>按照上面建立的跳表，假如我们想查找18对应的这个节点，首先遍历二级索引1、7、14三个节点，然后向一级索引查找14这个节点（14的下一个节点是23，发现18&lt;23，然后就去下一级原始链表中查找）、原始列表14、18两个节点。</p>
<h3 id="跳表的插入和删除"><a href="#跳表的插入和删除" class="headerlink" title="跳表的插入和删除"></a><strong>跳表的插入和删除</strong></h3><p>跳表支持数据的插入和删除，并且**插入和删除的操作时间复杂度都是o(log n)**。</p>
<p><strong>插入和删除操作</strong>需要先找到插入位置。得益于多级索引，<strong>o(log n)查找到插入&#x2F;删除位置</strong>。然后进行插入&#x2F;删除。</p>
<p><strong>删除操作需要用到 删除节点 的 前驱节点</strong>。可以像插入操作一样，通过索引逐层向下遍历到原始链表中要删除的节点，并记录其前驱节点，从而实现删除操作。</p>
<h3 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h3><p>当频繁插入数据时，如果插入时不进行索引更新，就有可能导致某2个节点之间的数据非常多，极端情况下会退化成单链表。</p>
<p>为了避免性能下降，需要在插入、删除的过程中，<strong>动态的更新跳表的索引结构</strong>。而这一操作是借助<strong>随机函数</strong>实现的。</p>
<p>当向跳表中<strong>插入数据</strong>时，我们选择同时将这个数据插入到部分索引层中。如何决定插入到哪些索引层中呢？<strong>通过一个随机函数来指定</strong>，比如通过 <strong>随机函数得到某个值K，那么就将这个节点添加到第一级到第K级的索引中去</strong>。</p>
<h3 id="小林coding中关于跳表节点层数设置的内容："><a href="#小林coding中关于跳表节点层数设置的内容：" class="headerlink" title="小林coding中关于跳表节点层数设置的内容："></a>小林coding中关于跳表节点层数设置的内容：</h3><p>小林中将跳表抽象成了如下结构（实际上都是一回事）：</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240517141414135.png" alt="image-20240517141414135"></p>
<ul>
<li>跳表的<strong>相邻两层的节点数量最理想的比例是2：1</strong>（上面的内容也说了，每两个节点取一个作为索引，意思差不多）。</li>
<li><strong>如果在新增或删除节点时，调整链表以维持比例的话，会带来额外的开销。</strong>于是Redis在创建节点的时候，<strong>随机生成每个节点的层数</strong>，并没有严格维持相邻两层节点数量比例为2：1的情况（简单来说就是，<strong>抛硬币来决定为新节点创建几个索引</strong>）。<ul>
<li>具体来说，<strong>跳表在创建节点的时候，会生成一个范围【0-1】的随机数，如果随机数小于0.25，那么层数就增加一层，然后继续生成下一个随机数，直到随机数的结果大于0.25结束，最终确定该节点的层数。</strong>（层数越高，概率越低）</li>
<li>如果层高最大限制是64，那么<strong>在创建跳表 头结点 的时候，就会直接创建64层高度的头节点</strong>（这里头结点就是上面图里的头结点）</li>
</ul>
</li>
</ul>
<h3 id="为什么选择使用跳表而不是平衡树-红黑树-？"><a href="#为什么选择使用跳表而不是平衡树-红黑树-？" class="headerlink" title="为什么选择使用跳表而不是平衡树(红黑树)？"></a>为什么选择使用跳表而不是平衡树(红黑树)？</h3><ul>
<li><strong>从内存占用上来比较，跳表比平衡树更灵活一点。</strong> 平衡树每个节点都有两个指针，而跳表每个节点包含的指针平均数目为1&#x2F;（1-p），具体取决于p（比如上面的p&#x3D;0.25，每四个节点才有有一个节点来建立上层索引）。相比之下跳表有优势。</li>
<li><strong>做范围查找的时候，跳表比平衡树操作要简单</strong>。在平衡树上，找到指定范围的最小值之后，还需要以中序遍历的方式继续寻找其他不超过大值的节点，讲真这里的中序遍历并不好实现（个人理解，是因为涉及一些剪枝）。而跳表就非常好实现，只要找到最小值，在原始链表上遍历若干步就可以实现。</li>
<li><strong>从算法实现复杂程度上来说，跳表比平衡树要好实现的多。</strong>平衡树需要顾及各种调整操作，逻辑复杂。而跳表的插入和删除只需要修改相邻结点的指针，简单快速。</li>
</ul>
<h2 id="如何保证缓存和数据库的一致性："><a href="#如何保证缓存和数据库的一致性：" class="headerlink" title="如何保证缓存和数据库的一致性："></a>如何保证缓存和数据库的一致性：</h2><p>首先确定一点，在保证可用性和分区容错性的前提下，<strong>无法保证缓存和数据库的绝对一致</strong>。</p>
<h3 id="产生不一致的两种原因如下："><a href="#产生不一致的两种原因如下：" class="headerlink" title="产生不一致的两种原因如下："></a><strong>产生不一致的两种原因</strong>如下：</h3><ul>
<li>缓存key删除失败：没删除成功，但是数据库确实更新了，然后就不一致了；</li>
<li>并发写入了脏数据：如果我们先删除缓存，再更新数据库。那么并发过程中，一部分线程会读到还没更新好的数据库中的旧数据，之后用这个旧数据重建缓存，就导致了缓存和数据库的不一致性。</li>
</ul>
<p>关于缓存更新策略，这里选用 删除缓存而不是更新缓存 的方式，因为删除缓存比更新缓存快得多。</p>
<p>整体的缓存更新策略就是：<strong>先删缓存，再更新数据库。</strong>但是这里除了这两步，还会有其他的策略尽可能保证一致性。</p>
<h3 id="缓存更新策略："><a href="#缓存更新策略：" class="headerlink" title="缓存更新策略："></a>缓存更新策略：</h3><ol>
<li><strong>消息队列保证key被删除</strong>：</li>
</ol>
<p>通过引入消息队列，<strong>把要删除的key 或者 删除失败的key 丢进消息队列</strong>，<strong>利用消息队列的重试机制，重试删除对应的key</strong>；</p>
<p>这个方法的缺点在于，对业务代码有一定的侵入性。</p>
<ol start="2">
<li><strong>数据库订阅+消息队列保证key被删除：</strong></li>
</ol>
<p>可以<strong>用一个服务（canal）去监听数据库的 binlog，获取需要操作的数据。然后用一个公共的服务获取订阅程序传来的信息，进行缓存删除</strong>操作。</p>
<p>这种方式降低了对业务的侵入，但是提升了系统的复杂度。</p>
<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240624220648247.png" alt="image-20240624220648247" style="zoom:50%;" />

<ol start="3">
<li><strong>⭐延迟双删防止脏数据</strong></li>
</ol>
<p>在第二条产生不一致的原因中，缓存可能读到没更新的旧数据然后进行缓存重建，这就导致了脏数据的出现。这种情况的解决方式就是延迟双删。</p>
<p><strong>先删除缓存 —&gt; 更新数据库 —&gt; 隔一段时间再次删除缓存</strong></p>
<p>这种方式下，<strong>延时时间需要仔细考量和测试</strong>。</p>
<ol start="4">
<li><strong>设置缓存过期时间兜底</strong></li>
</ol>
<p>朴素但有用的方法，给缓存设置一个合理的过期时间，即使发生了不一致，也不会永远不一致下去。</p>
<h2 id="怎么处理热key："><a href="#怎么处理热key：" class="headerlink" title="怎么处理热key："></a>怎么处理热key：</h2><p><strong>热key就是 redis中被频繁访问的key</strong>。当某个key被大量的读取或写入操作访问时，就会导致这个key成为热key。</p>
<h3 id="如何对热key进行监控："><a href="#如何对热key进行监控：" class="headerlink" title="如何对热key进行监控："></a>如何对热key进行监控：</h3><ul>
<li><strong>客户端监控</strong>：例如，可以在客户端（指Redis客户端）设置全局字典，每次调用redis命令时，使用这个字典进行记录。</li>
<li><strong>代理端监控：</strong>像Twemproxy、Codis这些基于代理的redis分布式架构，所有客户端的请求都是通过代理端完成的，可以在代理端进行收集统计。</li>
<li><strong>Redis服务端监控：</strong>monitor命令可以监控到Redis执行的所有命令，因此可以用这个指令统计热点key。</li>
</ul>
<h3 id="热key处理方法："><a href="#热key处理方法：" class="headerlink" title="热key处理方法："></a>热key处理方法：</h3><ul>
<li><strong>数据分片</strong>：<strong>将热key分散到不同的redis节点</strong>上，以避免某个节点的负载过高，提高整个系统的性能。</li>
<li><strong>使用二级缓存：</strong>在热key的处理中，可以引入二级缓存，将热key的数据提前加载到内存中。当<strong>redis宕机时，可以直接从内存中查询数据</strong>。</li>
</ul>
<h3 id="热key重建（联系缓存击穿）："><a href="#热key重建（联系缓存击穿）：" class="headerlink" title="热key重建（联系缓存击穿）："></a>热key重建（联系缓存击穿）：</h3><p>缓存重建需要耗费比较长的时间，可能涉及sql查询、IO、复杂的计算等。<strong>在缓存失效的瞬间，大量线程会同时发起缓存重建的请求，导致后端压力增大甚至崩溃</strong>。</p>
<p>针对热点key重建问题，采用以下方案来优化：</p>
<ul>
<li>使用互斥锁：用锁来保证只有一个线程能够缓存重建，其他线程等待重建缓存的线程执行完毕，再从缓存中读取数据即可。</li>
<li>设置永不过期：热点key在缓存中不设置过期时间，同时为每个value设置一个逻辑过期时间，当发现逻辑时间过期后，用一个单独的线程来进行重建缓存。这种方式可以在保证一致性的情况下，减少重建缓存的次数。</li>
</ul>
<h2 id="过期数据回收策略："><a href="#过期数据回收策略：" class="headerlink" title="过期数据回收策略："></a>过期数据回收策略：</h2><ul>
<li><strong>惰性删除</strong>：当访问到一个过期的key的时候，redis会立即删除该key。<ul>
<li>优点：如果过期键经常被访问，能及时删除过期键。</li>
<li>缺点：如果过期键很少被访问，会占用大量内存。</li>
</ul>
</li>
<li>定时删除： 在设置key的过期时间时，同时创建一个定时事件，当事件到达时，由事件处理器自动执行key的删除操作。</li>
<li><strong>定期删除</strong>：redis默认每10秒执行一次定时任务，随机抽取一部分键进行检查，删除过期的键。<ul>
<li>这种策略通过定期删除过期键来释放内存，相比于惰性删除，可以更及时的删除过期键，但也有可能会有一些过期键没被删除。</li>
</ul>
</li>
</ul>
<h2 id="内存溢出控制-x2F-内存淘汰策略："><a href="#内存溢出控制-x2F-内存淘汰策略：" class="headerlink" title="内存溢出控制&#x2F;内存淘汰策略："></a>内存溢出控制&#x2F;内存淘汰策略：</h2><p>redis所用内存达到<strong>maxmemory</strong>上限时会触发相应的溢出控制策略。</p>
<h3 id="溢出控制策略："><a href="#溢出控制策略：" class="headerlink" title="溢出控制策略："></a>溢出控制策略：</h3><ol>
<li><strong>不进行数据淘汰的策略：</strong></li>
</ol>
<ul>
<li>noeviction：当内存不足，不会淘汰任何数据，而是直接报错。<ul>
<li>适用于对数据丢失要求比较高的场景，但有可能OOM或者redis进程被杀死。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><p><strong>进行数据淘汰的策略</strong> （又分为 <strong>在设置了过期时间的数据中淘汰</strong> 和 <strong>在所有数据范围内淘汰</strong>）：</p>
<p>2.1<strong>在设置了过期时间的数据中淘汰的：</strong></p>
<ul>
<li>volatile-LRU：淘汰<strong>最近最少使用的、带有过期时间</strong> 的数据。适用于缓存一些热点数据的场景，但可能导致一些长期未使用的数据被误删。</li>
<li>volatile-random：随机淘汰设置了过期时间的任意键值。</li>
<li>volatile-ttl：优先淘汰更早过期的值。</li>
<li>volatile-LFU：淘汰所有设置了过期时间的键值中，最少使用的键。</li>
</ul>
<p>2.2<strong>在所有数据范围内进行淘汰的策略：</strong></p>
<ul>
<li>allkeys-LRU：淘汰最近最少使用的数据，<strong>不管这些数据是否过期</strong>。会导致有用的数据被误删。</li>
<li>allkeys-random：随即淘汰任意键值。</li>
<li>allkeys-LFU：淘汰整个键范围中最少使用的键。</li>
</ul>
</li>
<li><p><strong>LFU 和 LRU的区别：</strong></p>
<ul>
<li>LRU是最近最少使用，redis在对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间。进行内存淘汰时，redis随机选取5个值，然后淘汰最久未被使用的那个。</li>
<li>LFU是最近最不常用的意思，LFU会记录数据的访问次数，然后根据访问次数来淘汰数据。</li>
</ul>
</li>
</ol>
<h2 id="为什么Redis快"><a href="#为什么Redis快" class="headerlink" title="为什么Redis快"></a>为什么Redis快</h2><ul>
<li><strong>完全基于内存操作</strong>：redis基于内存，能实现更快速的读写。</li>
<li><strong>单线程操作</strong>：redis单线程处理客户端请求，可以避免多线程之间上下文的切换开销，提高了效率。<ul>
<li>6.0的<strong>多线程是用来处理数据的读写和协议解析</strong>，但是它<strong>执行命令的时候还是单线程的</strong>。</li>
</ul>
</li>
<li><strong>非阻塞的IO多路复用机制</strong>：这里的IO是网络IO，redis采用了IO多路复用模型，通过<strong>一个线程来监听多个客户端连接</strong>，<strong>当有事件发生时才进行处理</strong>，这种机制避免了阻塞和线程切换，提高了并发能力。<ul>
<li>阻塞IO模型：逐个检查，有一个没完成就得阻塞等待其完成。</li>
<li>非阻塞IO模型：谁完成了谁就发出通知，老师收到通知后进行处理，然后继续回讲台等。</li>
</ul>
</li>
</ul>
<h2 id="Redis持久化："><a href="#Redis持久化：" class="headerlink" title="Redis持久化："></a>Redis持久化：</h2><p>因为数据都在内存中，易发生丢失，所以需要持久化机制来将数据保存到磁盘中，在恢复时就能从磁盘进行恢复。</p>
<p>redis主要有三种持久化方式：</p>
<ul>
<li>AOF日志：每执行一次写命令，就把该命令追加到AOF日志里。</li>
<li>RDB快照：保存某一时刻内存数据的快照。RDB文件是一个二进制压缩文件。</li>
<li>混合持久化： 4.0新增的方式，集合了上面两种优点。</li>
</ul>
<h3 id="AOF日志："><a href="#AOF日志：" class="headerlink" title="AOF日志："></a>AOF日志：</h3><p>每有写操作就追加到AOF日志中，恢复也是从AOF日志中<strong>逐条执行命令</strong>进行恢复</p>
<p><strong>redis写入AOF日志的流程如下：</strong></p>
<ul>
<li>所有的写入命令会追加到<strong>aof缓冲区</strong>中。</li>
<li>通过<strong>write系统调用</strong>，将aof缓冲区的数据写入AOF文件，此时<strong>数据并没有写入硬盘，而是拷贝到了内核缓冲区</strong>，等待内核将数据写回硬盘。内核缓冲区的数据何时将内容写入硬盘，由写盘策略决定。<strong>写盘策略</strong>有以下几种：<ul>
<li><strong>always：</strong>每次写操作执行后，就把AOF同步到硬盘。</li>
<li><strong>EverySec：</strong>写入命令先放到<strong>内核缓冲区</strong>内，然后<strong>每隔1秒将内核缓冲区内的内容写到硬盘</strong>。<strong>宕机恢复会丢失1秒的数据。</strong></li>
<li><strong>No：</strong>写入命令放到内核缓冲区内，但是<strong>写回硬盘的时机由系统控制</strong>，因此<strong>宕机恢复可能丢失很多数据。</strong></li>
</ul>
</li>
<li>随着AOF文件越来越大，<strong>需要定期对AOF文件进行重写</strong>，以此来压缩AOF文件大小。<ul>
<li><strong>AOF压缩过程</strong>简单来说，就是压缩时会读取所有键值对，把每一个键值对变成记录，保存到新的AOF文件并进行替换。（<strong>相当于剔除了历史记录，只保留最新的结果</strong>）</li>
<li><strong>AOF重写过程是由后台子进程来进行的</strong></li>
</ul>
</li>
</ul>
<h3 id="RDB快照："><a href="#RDB快照：" class="headerlink" title="RDB快照："></a>RDB快照：</h3><p>rdb快照就是把当前数据生成快照（<strong>全量快照</strong>）保存在硬盘中。出发RDB持久化的过程分为 <strong>手动触发 和 自动触发</strong>。</p>
<ul>
<li><strong>手动触发分为save和bgsave</strong>：save会阻塞当前线程，bgsave是fork一个子线程来持久化，fork的时候会阻塞当前线程。</li>
<li><strong>自动触发</strong>是，我们可以设置save条件，比如它XX秒内执行了超过XXX条修改，就<strong>进行bgsave</strong>来持久化。当然，还有其他条件会自动触发RDB持久化：<ul>
<li><strong>从节点进行全量复制</strong>（涉及主从复制问题）：从节点第一次复制内容，会请求获取主节点的所有信息，这个时候主节点自动会生成一个RDB发给从节点。</li>
<li>执行<strong>debug reload命令</strong>重新加载Redis时，也会自动触发save。</li>
</ul>
</li>
</ul>
<h3 id="RDB与AOF的优缺点对比："><a href="#RDB与AOF的优缺点对比：" class="headerlink" title="RDB与AOF的优缺点对比："></a>RDB与AOF的优缺点对比：</h3><ul>
<li>RDB是全量快照，但他是压缩的二进制文件；而AOF记录了所有的写记录，就空间占用情况来说，AOF &gt; RDB；</li>
<li>RDB恢复速度比AOF快。</li>
<li>RDB实时性低，它是每隔一段时间进行持久化，故障恢复后数据会丢失；AOF实时性高（当然也要看是哪种写盘策略，如果是Always，实时性就很高）。</li>
<li>RDB容灾性好，可以把RDB文件拷贝到远程机器或者文件系统，用于容灾恢复。</li>
</ul>
<h3 id="混合持久化："><a href="#混合持久化：" class="headerlink" title="混合持久化："></a>混合持久化：</h3><p><strong>RDB优点是恢复快，缺点是会丢失数据；AOF优点是丢失数据少，缺点是恢复速度不快。</strong>混合持久化结合了二者的优点。</p>
<p>混合持久化<strong>在AOF重写阶段进行</strong>（上面说了，AOF文件大小达到一定的阈值，就会触发AOF重写）。</p>
<p>在该阶段，<strong>首先进行RDB持久化，然后将RDB文件的内容 和 AOF日志文件</strong>放在一起，这里的<strong>AOF日志</strong>不再是全量的日志，而<strong>是RDB持久化开始到RDB持久化结束期间产生的AOF</strong>（这部分AOF通常很小）。</p>
<p><strong>优点就是</strong>：在提升恢复速度的同时，大大减少了数据丢失的风险。</p>
<p><strong>缺点很明显：</strong>可读性差，并且混合日志老版本的redis用不了。</p>
<h2 id="Redisson分布式锁"><a href="#Redisson分布式锁" class="headerlink" title="Redisson分布式锁"></a>Redisson分布式锁</h2><h3 id="Redisson如何实现分布式锁的？（set指令-lua脚本）"><a href="#Redisson如何实现分布式锁的？（set指令-lua脚本）" class="headerlink" title="Redisson如何实现分布式锁的？（set指令 + lua脚本）"></a>Redisson如何实现分布式锁的？（set指令 + lua脚本）</h3><ul>
<li><strong>第一步，使用lua脚本执行加锁操作</strong>：lua脚本会<strong>判断锁是否存在</strong>，<strong>如果不存在</strong>，使用<strong>hset</strong>命令<strong>设置锁的值</strong>，使用<strong>pexpire</strong>命令<strong>设置锁的过期时间</strong>。<strong>如果锁已经被当前线程持有，则将锁的值加一，并设置锁的过期时间为指定的时间</strong>。</li>
<li><strong>第二步，续约锁的时间：</strong>获取锁成功后，Redisson会<strong>开启一个定时任务</strong>（<strong>就是watch dog</strong>），定期延长锁的过期时间（续约）。这个<strong>定时任务也是通过lua脚本实现</strong>的。</li>
<li><strong>第三步，释放锁：</strong>当锁的持有者完成任务后，Redission会<strong>调用redis的DEL指令来删除锁的键</strong>，释放锁。</li>
</ul>
<h3 id="关于Watch-Dog看门狗机制："><a href="#关于Watch-Dog看门狗机制：" class="headerlink" title="关于Watch Dog看门狗机制："></a>关于Watch Dog看门狗机制：</h3><p>watch dog定期检查和维护分布式锁的状态，可以保证分布式锁有有效性和可靠性。看门狗机制主要有两个作用：</p>
<ul>
<li><strong>续约</strong>：watch dog会<strong>定期</strong>（release Time&#x2F;3）<strong>发送续约命令给持有锁的客户端</strong>，更新锁的时间。这样保证锁不会因为过期被其他客户端获取。</li>
<li><strong>释放</strong>：如果watch dog发现<strong>持有锁的客户端不再存活或者发生故障，会自动触发锁的释放</strong>动作。可以避免客户端占着茅坑不拉屎。</li>
</ul>
<h3 id="Red-Lock红锁，Redission是怎样实现的？"><a href="#Red-Lock红锁，Redission是怎样实现的？" class="headerlink" title="Red Lock红锁，Redission是怎样实现的？"></a>Red Lock红锁，Redission是怎样实现的？</h3><p>红锁旨在解决<strong>redis单点故障或网络分区</strong>的情况下，分布式锁的可用性和可靠性问题。</p>
<p>红锁的实现思路如下：</p>
<ul>
<li>获取<strong>当前时间戳和一个随机的唯一标识符</strong>；</li>
<li><strong>尝试在多个独立的Redis实例上获取锁</strong>，<strong>每个实例</strong>都是用<strong>相同的唯一标识符和过期时间</strong>。</li>
<li>统计成功获取锁的实例数量，如果<strong>大部分实例</strong>（例如大于半数）<strong>成功获取到锁</strong>，则认为获取锁成功。</li>
<li>如果获取锁<strong>成功，则执行业务逻辑操作，完成后释放锁</strong>。</li>
<li>如果获取锁<strong>失败，尝试在获取锁失败的实例上主动释放锁</strong>，以防止锁被永久持有。</li>
</ul>
<h2 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h2><h3 id="如何实现服务高可用："><a href="#如何实现服务高可用：" class="headerlink" title="如何实现服务高可用："></a>如何实现服务高可用：</h3><p>如果说<strong>高可用</strong>，那么必须得<strong>使用集群</strong>，并且进行<strong>读写分离</strong>。如果使用了集群，就涉及<strong>主从复制、哨兵模式、切片集群</strong>等问题。</p>
<h4 id="高可用之主从复制："><a href="#高可用之主从复制：" class="headerlink" title="高可用之主从复制："></a>高可用之主从复制：</h4><p><strong>主从复制是redis高可用的最基本保证</strong>，并且主从服务器之间进行读写分离。<strong>主服务器可以进行读写操作</strong>，当发生写操作的时候，自动将写操作同步给 从服务器。<strong>从服务器一般是 只读</strong>，并接收主服务器同步过来的写命令。</p>
<p><strong>⭐主从第一次同步⭐（第一次同步的时候，主服务器有数据，从服务器空荡荡，所以第一次是全量复制</strong>），主从第一次同步可以包括以下几个阶段：</p>
<ul>
<li><strong>第一阶段：建立连接、协商同步。</strong><ul>
<li>从服务器与主服务器建立连接后，<strong>从服务器发送一个PSYNC命令</strong>，该命令包括自己的服务器标识，以及一个值为-1的offset偏移量（-1表示从服务器是第一次复制，offset表示当前复制进度）。</li>
<li>主服务器收到从服务器发来的消息后，会返回一个FULLRESYNC响应，这个响应用来表示<strong>主服务器</strong>会采用<strong>全量复制</strong>的方式把数据 传送给从服务器。</li>
</ul>
</li>
<li><strong>第二阶段：主服务器同步数据给从服务器。</strong><ul>
<li>主服务器执行bgsave生成RDB快照，然后把这个快照发给从服务器。</li>
<li>从服务器收到RDB快照后，先清空自己的所有数据，然后载入RDB快照。</li>
<li>由于是bgsave，主服务器不会阻塞，因此<strong>主服务器在这三个阶段中收到的写命令会存到 replication buffer缓冲区里</strong>：<ul>
<li>主服务器生成RDB快照期间；</li>
<li>RDB快照传送到从服务器期间；</li>
<li>从服务器加载RDB快照期间；</li>
</ul>
</li>
</ul>
</li>
<li><strong>第三阶段：主服务器发送新写命令给从服务器。</strong><ul>
<li>从服务器加载完RDB快照后会发送一个确认给主服务器。</li>
<li>主服务器将replication buffer缓冲区中的操作命令发给从服务器，从服务器进行执行，然后主从服务器的数据就一致了。</li>
</ul>
</li>
</ul>
<p><strong>⭐命令传播⭐</strong></p>
<p><strong>主从服务器完成第一次同步后，双方之间就会维护一个TCP链接</strong>。</p>
<p>后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得主从数据一致。</p>
<p><strong>这个TCP连接是长连接的</strong>，这意味着不用频繁的TCP连接带来不必要的开销。因此这个过程也成为<strong>基于长连接的命令传播。</strong></p>
<p><strong>⭐增量复制⭐</strong></p>
<p>主从第一次同步后，就会基于长连接进行命令传播。如果主从服务器在命令同步时发生了断开又恢复的情况，主从服务器会采用增量复制的方式进行同步。主要有三个步骤：</p>
<ul>
<li>从服务器回复网络后，会发送<strong>psync命令</strong>给主服务器，此时psync里面的offset不是-1；</li>
<li>主服务器接收到该命令后，会发送一个响应，告诉从服务器接下来将会以 <strong>增量复制</strong> 的方式进行同步；</li>
<li>然后，主服务器将<strong>主从断线期间</strong>，<strong>主服务器接收到的写命令发送给从服务器</strong>，然后<strong>从服务器执行</strong>这些命令。</li>
</ul>
<p><strong>Redis是异步复制，主节点每次收到写命令后，先写到内部的缓冲区，然后异步发送给从节点。</strong></p>
<p><strong>⭐关于replication_buffer⭐</strong></p>
<p>replication_buffer是一个<strong>环形缓冲区</strong>，用于主从服务器断开连接后，从中找到差异的数据。</p>
<p>它有两个偏移量：<strong>master_repl_offset是主服务器用来记录自己写到的位置；slave_repl_offset是从服务器用来记录自己读到的位置。</strong></p>
<p>一般来说，master_repl_offset是大于等于slave_offset的。这个时候直接把差值中的数据<strong>增量复制</strong>给从服务器；如果小于的话，只能采用<strong>全量复制</strong>了。</p>
<h5 id="如何判断Redis某个节点是否正常工作"><a href="#如何判断Redis某个节点是否正常工作" class="headerlink" title="如何判断Redis某个节点是否正常工作"></a>如何判断Redis某个节点是否正常工作</h5><p>节点之间，通过互相检测心跳来判断节点是否正常工作。如果有一半以上的节点没有收到一个节点的心跳，集群就认为该节点挂了。会断开与该节点的连接。</p>
<p>Redis主从节点之间发送的心跳频率是不一样的，而且作用也有区别：</p>
<ul>
<li>Redis<strong>主节点每10秒</strong>向从节点发送一次 ping指令，用于判断从节点的存活状态。</li>
<li><strong>从节点每1秒</strong>就向主节点汇报一次，汇报的内容就是自己同步的偏移量offset。汇报的目的有两个：<ul>
<li>检测主节点状态。</li>
<li>上报偏移量用来检查从节点数据有没有丢失，如果从节点数据丢失，再从主节点的复制缓冲区中拉取丢失数据。</li>
</ul>
</li>
</ul>
<h5 id="如何应对主从数据的不一致性："><a href="#如何应对主从数据的不一致性：" class="headerlink" title="如何应对主从数据的不一致性："></a>如何应对主从数据的不一致性：</h5><p>主从数据不一致因为主从数据同步是异步进行的，无法实现强一致性。</p>
<ul>
<li>保证主从节点之间网络通信良好，避免主从节点在不同的机房。</li>
<li>INFO replication 命令可以查看主节点写的偏移量 master_repl_offset和从节点的偏移量 slave_repl_offset。因此可以开发一个程序监控二者的差值，以进行主从复制进度的监控。如果两个偏移量的差值大于我们设定的阈值，可以不让客户端从这个节点读取，这样可以减少读到不一致数据的情况。</li>
</ul>
<h5 id="如何应对主从切换导致的数据丢失："><a href="#如何应对主从切换导致的数据丢失：" class="headerlink" title="如何应对主从切换导致的数据丢失："></a>如何应对主从切换导致的数据丢失：</h5><p><strong>异步复制导致的数据丢失：</strong></p>
<ul>
<li>从节点还没来得及同步主节点，主节点就挂了。这种情况会导致数据的丢失。</li>
<li>redis有一个配置参数 min-slaves-max-lag，表示一旦所有的从节点数据复制和同步的延迟都超过了 定义的值，那么主节点就会拒绝接受任何请求。</li>
<li>假设我们给min-slave-max-lag 设置为10s，根据目前主从复制的速度，如果数据同步完成所需要的时间超过10s，<strong>就会认为master未来宕机损失的数据要更多，那么master就会拒绝写请求。</strong></li>
</ul>
<p><strong>集群脑裂带来的数据丢失：</strong></p>
<p>1.<strong>脑裂是怎么一回事？</strong></p>
<ul>
<li>在<strong>一主多从</strong>的集群中，主节点负责写操作，从节点负责读。假如这时候，<strong>主节点与所有从节点都失联了，但是客户端与主节点连接没事</strong>（等于客户端不知道这回事，继续往主节点里写数据）。显然从节点们要选举出一个新的主节点，选举完成后，现在的集群中相当于出现了两个主节点（一个原来的，一个新选举出来的），这就是脑裂。</li>
<li>假设过了一段时间，原来的主节点恢复连接了，但由于新主节点已经选出来了，所以<strong>原主节点要降级为 从节点（</strong>即使它有最新的数据），并且向新的主节点发送同步请求，而第一次复制 是全量复制，所以<strong>全量复制后，发生了数据丢失</strong>。</li>
</ul>
<p>2.<strong>那么如何减少脑裂带来的数据丢失？</strong></p>
<p>当<strong>主节点</strong>发现 <strong>从节点下线的数量太多</strong>，或者<strong>网络延迟太大</strong>的时候，那么<strong>主节点会禁止写操作</strong>，直到把错误返回给客户端。</p>
<p>Redis中有两个参数可以配置：</p>
<ul>
<li>min-slaves-to-write x：主节点必须要有至少x个从节点连接，否则禁止写入主节点。</li>
<li>min-slave-max-lag x：主从复制的延迟不能超过x秒，否则禁止写入主节点。</li>
</ul>
<p>这两个配置配合使用的效果就是：<strong>与主节点连接的从节点个数必须大于N个，并且主从之间同步的延迟不能超过Y秒。否则主节点不接受客户端的写请求了。</strong></p>
<p><strong>等到新主节点上线时，就只有新主节点能够接受和处理客户端请求，此时，新的数据会写入新主节点。而原主节点会被哨兵降级为从节点，即使它的数据被清空了，也不会有新的数据丢失。</strong></p>
<h4 id="高可用之哨兵机制："><a href="#高可用之哨兵机制：" class="headerlink" title="高可用之哨兵机制："></a>高可用之哨兵机制：</h4><p>哨兵机制的主要作用就是<strong>实现主从节点故障转移</strong>。哨兵节点主要负责<strong>三件事情：监控、选主、通知</strong>。</p>
<h5 id="如何判断主节点真的故障了（主管下线-amp-客观下线）："><a href="#如何判断主节点真的故障了（主管下线-amp-客观下线）：" class="headerlink" title="如何判断主节点真的故障了（主管下线&amp;客观下线）："></a>如何判断主节点真的故障了（主管下线&amp;客观下线）：</h5><ul>
<li><strong>哨兵每隔一秒ping主节点和从节点</strong>，以确定主节点和从节点能正常运行。<strong>如果主从节点没有在规定时间内响应哨兵</strong>，哨兵就会将他们标记为 <strong>主观下线</strong>。</li>
<li><strong>客观下线只适用于主节点。</strong>当一个哨兵判断主节点为 主管下线后，会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的连接状况，做出赞成投票 和 反对投票。</li>
<li>一旦这个哨兵的赞成票数大于 <strong>哨兵配置文件的 <quorum> 配置设定的值</strong>后，这时主节点就会被该哨兵（指第一个主观下线主节点的哨兵）标记为 <strong>客观下线</strong>。</li>
<li><strong>主节点被客观下线后，就需要哨兵们选取新的主节点了</strong>。</li>
</ul>
<h5 id="由哪个哨兵进行故障转移？"><a href="#由哪个哨兵进行故障转移？" class="headerlink" title="由哪个哨兵进行故障转移？"></a>由哪个哨兵进行故障转移？</h5><p>哨兵是以哨兵集群的方式存在的，当<strong>主节点发生客观下线</strong>的时候，<strong>哨兵们同样会投票选出一个leader</strong>，由leader执行故障转移。<strong>既然是投票，肯定有候选者。</strong></p>
<ul>
<li><p><strong>哪个哨兵判断了主节点客观下线（指这个哨兵，而且到他投票数刚好大于quorum），哪个节点就是候选者。</strong></p>
</li>
<li><p>在得到候选者之后，哨兵们会给候选者投票，来决定候选者是否能转正为leader。</p>
</li>
<li><p><strong>每个哨兵只能投一票，除了候选者可以投给自己一票外，其余的哨兵只能投给其他哨兵</strong>。一旦候选者投票数满足下面两个要求，就可以转为leader:</p>
<ul>
<li>候选者拿到半数以上的票；</li>
<li>候选者的票数还必须大于等于 哨兵配置文件中的 quorum值；</li>
</ul>
</li>
<li><p>之后<strong>候选者转正为leader，进行主从故障转移</strong></p>
</li>
</ul>
<h5 id="主从状态转移的过程是怎样的："><a href="#主从状态转移的过程是怎样的：" class="headerlink" title="主从状态转移的过程是怎样的："></a>主从状态转移的过程是怎样的：</h5><ul>
<li>第一步，<strong>从 旧主节点 的从节点中</strong>（因为这些从节点的数据肯定比较新），选取一个节点，并将其转换为主节点。当然，从节点个数有很多，具体选择哪一个作为 新主节点 需要经过一系列的筛选：<ul>
<li>首先把<strong>网络连接状况不好</strong>的从节点给<strong>排除掉</strong>；</li>
<li>然后，在剩下的这些从节点中，继续从<strong>优先级、复制进度、ID号</strong>三个维度依次进行考察（如果某一项考察已经得出结论，就不再往下继续考察了）：<ul>
<li><strong>优先级高的节点胜出</strong>：这个优先级可以是服务器性能等，看具体配置。</li>
<li><strong>复制进度最靠前的节点胜出</strong>：这个好理解，谁的数据最新就胜出。</li>
<li><strong>ID号小的从节点胜出</strong>：每个节点都有一个ID，小的胜出。</li>
</ul>
</li>
</ul>
</li>
<li>第二步：让 <strong>已下线主节点（旧主节点）的 从节点们修改复制目标</strong>，修改为 <strong>新主节点</strong>。这一操作可以通过向从节点发送 slaveof 指令来实现。</li>
<li>第三步：将 <strong>新主节点 的IP 和信息</strong>，通过 <strong>发布&#x2F;订阅</strong> 机制通知给<strong>客户端</strong>。<ul>
<li>主从切换完成后，<strong>哨兵就会向</strong> switch-master <strong>频道</strong>发送一个 <strong>发布新主节点IP地址和信息 的消息</strong>，这个时候<strong>客户端就可以收到</strong>这条消息，<strong>然后跟 新主节点 通信了</strong>。</li>
</ul>
</li>
<li>第四步：继续<strong>监视旧主节点</strong>，当这个<strong>旧主节点重新上线</strong>的时候，将它<strong>设置为新主节点的从节点</strong>。</li>
</ul>
<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h2 id="如何保证消息不丢失："><a href="#如何保证消息不丢失：" class="headerlink" title="如何保证消息不丢失："></a>如何保证消息不丢失：</h2><h3 id="那些环节会造成消息丢失？"><a href="#那些环节会造成消息丢失？" class="headerlink" title="那些环节会造成消息丢失？"></a>那些环节会造成消息丢失？</h3><ul>
<li>生产者往MQ中发送消息的过程中丢失；</li>
<li>MQ主从同步的过程中：主从同步的过程中主节点挂了，就会丢失数据。</li>
<li>消息持久化的过程中：内存中的消息在持久化到硬盘中挂了，那么就会造成消息的丢失。</li>
<li>消费者从MQ获取消息的过程中丢失；</li>
</ul>
<h3 id="怎么去防止消息丢失："><a href="#怎么去防止消息丢失：" class="headerlink" title="怎么去防止消息丢失："></a>怎么去防止消息丢失：</h3><ol>
<li><p><strong>防止生产者往MQ中发送消息的过程中的丢失</strong>：</p>
<ul>
<li><p><strong>消息发送 + 回调：</strong>异步发送的时候，应该在回调方法中检查，如果发送失败或者异常，则进行重试。</p>
</li>
<li><p><strong>事务消息：</strong>事务消息可以<strong>保证 生产者本地事务 和 生产者向MQ发送消息 的原子性</strong>。换句话说，<strong>本地事务和消息发送同成功同失败。</strong></p>
<p>生产者首先向MQ中发送一个 半消息（该消息对消费者不可见，它仅用于检查MQ状态可用）；</p>
<p>MQ向生产者发送 半消息响应，表示MQ可以使用；</p>
<p>生产者知道MQ可用之后，会执行自己的本地事务，同时发送一个具体的消息，<strong>这个消息中包含了本地事务的状态</strong>（事务状态有三种：成功、失败、未知）；</p>
<p>MQ接收到这个带有 本地事务状态的消息之后，检查这个状态信息。如果本地事务成功，说明该信息可以保留在MQ中；如果失败，则应该丢弃这个消息；如果状态未知，则向生产者发送消息回查，生产者会再次检查本地事务状态（比如数据库中是否能查到这条信息）并再次返回事务状态给MQ，MQ会重复上面的检查，已决定是否保留这条消息。</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240514155139282.png" alt="image-20240514155139282"></p>
<p><strong>应用：如何设计一个订单超时关闭的功能？</strong></p>
<p>生产者在第三步向MQ中发送消息的时候，主动地发送一个未知状态的消息，时候MQ会发起回查。</p>
<p>这里注意了，这里生产者接收到MQ回查消息后，不再检查自己的本地事务状态，而是检查订单系统中的支付状态，如果已完成则返回成功，否则失败。</p>
</li>
</ul>
</li>
<li><p><strong>防止MQ主从同步的过程中发生消息丢失：</strong></p>
<p><strong>普通集群中：</strong>有两种方式进行同步：</p>
<ul>
<li><strong>同步进行</strong>：从节点都完成主从复制后，才会通知生产者消息提交成功。这种方式不会发生消息丢失，但是效率低。</li>
<li><strong>异步进行：</strong>消息保存到主节点上就进行返回，异步进行从节点的复制。这种方式效率高，但是有可能发生消息丢失。</li>
</ul>
<p><strong>Dledger集群中</strong>，会使用两阶段提交的方式：</p>
<ul>
<li>Dledger集群与普通集群不同的是，普通集群主从节点一开始就确定好了，<strong>但是Dledger集群所有节点都是一个等级，</strong>只有在接收消息时会<strong>选举出一个主节点</strong>，其余的节点作为从节点。</li>
<li>当消息保存到主节点时，就返回给主节点消息提交成功，并设置为自己的状态为uncommitted 。然后主节点异步进行主从复制。当半数以上从节点完成主从复制后，主节点状态转变为committed。等到下一个消息来临的时候，所有节点不区分主从，这样在保证吞吐的同时又能保证消息不丢失。</li>
</ul>
</li>
<li><p><strong>防止消息持久化的过程中丢失：</strong></p>
<p>两种机制：<strong>同步刷盘 &amp; 异步刷盘</strong>。</p>
<ul>
<li>同步刷盘是每条消息完成持久化后才会返回确认信息。效率低。</li>
<li>异步刷盘是每条消息先保存到虚拟内存中，之后就直接返回确认信息了，然后用多线程将虚拟内存中的消息进行持久化。</li>
</ul>
</li>
<li><p><strong>防止消费者从MQ获取消息的过程中丢失（消费没有被成功消费导致丢失）：</strong></p>
<p>消费者保证成功消费消息的关键在于 <strong>确认的时机</strong>。<strong>不在收到消息后就立即发送消费确认，而是在执行完所有业务逻辑后，再发送消费确认。</strong></p>
<p>因为消息队列维护了消费的位置，逻辑执行失败了，没有确认，再去队列拉取消息，就还是之前的一条。</p>
</li>
</ol>
<h2 id="订单超时自动取消如何实现？"><a href="#订单超时自动取消如何实现？" class="headerlink" title="订单超时自动取消如何实现？"></a>订单超时自动取消如何实现？</h2><ol>
<li><p><strong>使用DelayQueue延迟队列来实现</strong></p>
<p>每次生成的订单加入到延迟队列中，以超时时间作为权重排序，最快超时的订单排在队列最前。由一个线程不停的轮询延迟队列。一旦发现有订单超时，则进行超时处理（即取消订单）。</p>
<ul>
<li>优点：好实现，不需要引入第三方库。</li>
<li>缺点：<ul>
<li>所有超时处理订单都要加入到延迟队列中，占用内存大；</li>
<li>数据都是在内存中，掉电恢复时还得从数据库中初始化，很麻烦；</li>
<li>没法做到分布式处理，因为它是基于JVM的，只能在集群中选一台leader专门进行处理，效率低。</li>
<li>不适合订单量大的场景。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>使用消息队列的延迟消息来实现（RocketMq）</strong></p>
<p>消息的生产者，会向消息队列中发送一个带有定时时间的消息。当定时时间到了之后，该消息才能投递给消费者，被消费者所消费。</p>
<ul>
<li>优点：<ul>
<li>使用简单，就像发送一个普通消息一样。</li>
<li>支持分布式。</li>
<li>精度高，支持任意时刻。</li>
</ul>
</li>
<li>缺点：<ul>
<li>使用限制：定时时长的最大值为24小时。</li>
<li>每个订单都会新增一个定时消息，并且不会马上进行消费，这给MQ带来很大的存储成本。</li>
<li>同一时刻大量消息会导致消息延迟：定时消息的实现逻辑需要先经过定时存储等待触发，定时时间到达后才会投递给消费者。因此，<strong>如果将大量定时消息的定时时间设置到同一刻，则到达该时刻后会有大量的消息同时需要被处理，会造成系统压力过大，导致消息分发延迟，影响定时精度。</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>使用redis的过期监听实现</strong></p>
<ul>
<li>优点同使用MQ的优点，好实现、支持分布式、精度高等</li>
<li>缺点（也是所有中间件的缺点）<ul>
<li>不可靠，Redis在过期通知的时候，如果应用正好重启或者宕机，那么就有可能通知事件就丢了，会导致订单一直无法关闭，有稳定性问题。如果一定要使用Redis过期监听方案，建议再通过定时任务做兜底。</li>
<li>如果订单量庞大，需要占用中间件大量的存储空间，需要额外的维护成本。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>定时任务分布式批处理</strong></p>
</li>
</ol>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240522153230935.png" alt="image-20240522153230935"></p>
<p>由分布式任务调度中间件（quartz、xxlJob等）来实现，在定时任务中间件指定定时任务，比如从数据库中筛选出超时的订单信息统一处理批量入库。</p>
<ul>
<li>优点：<ul>
<li>稳定性好，使用中间件都可能导致消息丢失，而在这种方式下，任务调度中间件挂了重启后，再从超时中心中获取超时订单进行处理就可以了。</li>
<li>容易实现。</li>
</ul>
</li>
<li>缺点：<ul>
<li>超时精度不高，需要设置合适的处理频率。</li>
</ul>
</li>
</ul>
<p>如果对于超时精度比较高，超时时间在24小时内，并且不会有峰值压力的场景，推荐使用RocketMQ的延迟消息的解决方案。</p>
<p>在电商业务下，许多订单超时场景都在24小时以上，对于超时精度没有那么敏感，并且由海量的订单需要处理，推荐使用定时任务分布式批处理的解决方案。</p>
<h2 id="如何保证消息的顺序性："><a href="#如何保证消息的顺序性：" class="headerlink" title="如何保证消息的顺序性："></a>如何保证消息的顺序性：</h2><p>顺序消息是指消息的生产顺序和消费顺序相同。在有些业务逻辑下，必须保证消息顺序消费。</p>
<p>顺序消息分为全局顺序消息和局部顺序消息：</p>
<ul>
<li>全局顺序消息是指某个Topic下的所有消息都要保证顺序；</li>
<li>部分顺序消息只要保证每一组消息被顺序消费即可，比如，同一个订单ID的消息需要被顺序消费。</li>
</ul>
<h3 id="全局顺序消息的实现："><a href="#全局顺序消息的实现：" class="headerlink" title="全局顺序消息的实现："></a>全局顺序消息的实现：</h3><p><strong>RocketMQ默认情况下不保证顺序，比如创建一个Topic，默认8个写队列，8个读队列，这时一条消息可能被写入任意一个队列里</strong>；</p>
<p>在数据的读取过程中，可能有多个Consumer，每个Consumer也可能启动多个线程进行并行处理，所以消息被哪个Concumer消费，被消费的顺序和写入的顺序是否一致不确定。</p>
<p>要保证全局顺序消息，<strong>首先要将Topic的读写队列数量设置为1，然后Producer Consumer的并发设置也得是1</strong>。简单来说，<strong>为了保证Topic全局消息有序，只能消除所有的并发处理，各部分都设置为单线程处理</strong>，这时候就会完全牺牲RocketMQ的高并发、高吞吐的特性了。</p>
<h3 id="部分顺序消息的实现："><a href="#部分顺序消息的实现：" class="headerlink" title="部分顺序消息的实现："></a><strong>部分顺序消息的实现：</strong></h3><p>生产端需要把同订单ID的消息发送到同一个 Message Queue；在消费过程中，要做到同一个Message Queue读取的消息顺序处理–即消费者端不能并发处理顺序消息，这样才能达到部分有序。</p>
<h2 id="如何避免消息重复消费"><a href="#如何避免消息重复消费" class="headerlink" title="如何避免消息重复消费"></a>如何避免消息重复消费</h2><p>RocketMQ 确保消息一定投递，保证消息不丢失，但有可能造成消息的重复。</p>
<p><strong>处理消息重复问题</strong>，主要有由业务端自己保证，主要方式分为两种：<strong>业务幂等</strong> 和 <strong>消息幂等</strong></p>
<p>（1）<strong>业务幂等</strong>：保证消费逻辑的幂等性，也就是多次调用和一次调用的效果是一样的。</p>
<p>（2）<strong>消息去重：</strong>在消息生产时，MQ内部针对每条生产者发送的消息生成一个唯一ID，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列。在消息消费时，要求消息体中也要有一个全局唯一ID作为去重和幂等的依据，避免同一条消息被重复消费。</p>
<h2 id="如何处理消息积压："><a href="#如何处理消息积压：" class="headerlink" title="如何处理消息积压："></a>如何处理消息积压：</h2><h3 id="第一种方法，消费者扩容："><a href="#第一种方法，消费者扩容：" class="headerlink" title="第一种方法，消费者扩容："></a>第一种方法，消费者扩容：</h3><p>适用于当前主题<strong>Topic消息队列数量 大于 消费者数量</strong>的情形。通过增加消费者来扩容，从而提高消费能力，尽快消费积压的消息。通过增加消费者，可以使消息队列分配给更多的消费者进行并行消费，加快消息处理速度。</p>
<h3 id="第二种方法，消息迁移Queue扩容："><a href="#第二种方法，消息迁移Queue扩容：" class="headerlink" title="第二种方法，消息迁移Queue扩容："></a>第二种方法，消息迁移Queue扩容：</h3><p>适用于当前主题<strong>Topic消息队列数量 小于等于 消费者数量</strong>的情形。这种情况下，添加消费者数量不够有效。这时需要考虑扩容消息队列。</p>
<p>一种方法是，创建一个临时主题，在<strong>临时主题上设置更多的消息队列</strong>。然后将<strong>部分消费者用于将消息从原主题转发到临时主题</strong>，这个过程不需要进行业务处理，只是将消息转发，因此速度很快。接下来，使用扩容后的消费者来消费临时主题中的消息。<strong>当所有积压消息被消费完毕后，恢复到原始状态</strong>。</p>
<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240523150236245.png" alt="image-20240523150236245" style="zoom: 50%;" />





<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="1-Mybatis和Mybatis-plus的区别"><a href="#1-Mybatis和Mybatis-plus的区别" class="headerlink" title="1. Mybatis和Mybatis-plus的区别"></a>1. Mybatis和Mybatis-plus的区别</h2><p>MP是一个Mybatis的增强工具，只是在Mybatis的基础上做了增强却不做改变，Mybatis-Plus支持所有Mybatis原生的特性，所以引入Mybatis-Plus不会对现有的Mybatis框架产生任何影响。</p>
<p><strong>二者的区别：</strong></p>
<p><strong>Mybatis</strong>：</p>
<ul>
<li>所有的SQL语句全部需要自己写；</li>
<li>手动解析实体关系映射转换为MyBatis内部对象注入容器；</li>
<li>不支持Lambda形式调用；</li>
</ul>
<p><strong>Mybatis-Plus</strong>:</p>
<ul>
<li>强大的条件构造器，满足各类使用需求</li>
<li>内置Mapper，通用的service，少量配置即可实现单表大部分CRUD操作；</li>
<li>支持Lambda形式调用；</li>
<li>提供了基本的CRUD功能，连SQL语句都不需要写；</li>
<li>自动解析实体关系映射转换为MyBatis内部对象注入容器；</li>
</ul>
<h2 id="2-MyBatis的优缺点"><a href="#2-MyBatis的优缺点" class="headerlink" title="2. MyBatis的优缺点"></a>2. MyBatis的优缺点</h2><p>优点：</p>
<ul>
<li>Mybatis封装了JDBC底层访问书库的细节，是我们程序员不需要与JDBC API打交道，就可以访问数据库；</li>
<li>MyBatis简单易学，开发者直接编写SQL语句，适合对SQL语句性能要求比较高的项目；</li>
<li>SQL语句封装在配置文件中，便于统一管理与维护，降低了程序的耦合度；</li>
</ul>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="1-Eureka和Nacos的区别"><a href="#1-Eureka和Nacos的区别" class="headerlink" title="1. Eureka和Nacos的区别"></a>1. Eureka和Nacos的区别</h2><ul>
<li><strong>通信方式：</strong><ul>
<li>Eureka基于HTTP restful API进行通信；Nacos同时支持HTTP 和 TCP两种通信方式，TCP方式效率更高，适用于服务间通信；</li>
</ul>
</li>
<li><strong>服务发现：</strong><ul>
<li><strong>Eureka基于拉模式</strong>，Eureka client会定期从Server中拉取服务信息；</li>
<li><strong>Nacos基于推送模式</strong>，Server会实时推送服务信息变化给Client，AP模式下更适合大规模服务；</li>
<li>Eureka通过注册中心定期拉取服务列表，有缓存，默认每30秒拉取一次。</li>
<li>Nacos是推送式服务列表更新，注册中心每次服务列表变化都会实时推送给订阅者，服务端和客户端保持心跳连接。</li>
</ul>
</li>
<li><strong>CAP理论：</strong><ul>
<li>Eureka只支持AP，保证可用性和分区容错性；</li>
<li>Nacos可以切换AP和CP两种模式。AP用于生产环境，可以保证高可用性和分区容错性，CP模式用于测试环境，可以保证数据一致性和分区容错性；</li>
</ul>
</li>
<li><strong>架构：</strong><ul>
<li>Eureka采用CS架构，由服务注册中心Eureka Server和服务提供者&#x2F;消费者Eureka Client组成；</li>
<li>Nacos采用高可用的P2P设计，无主节点，所有的server节点都是同等作用；</li>
</ul>
</li>
</ul>
<h1 id="分布式理论"><a href="#分布式理论" class="headerlink" title="分布式理论"></a>分布式理论</h1><h2 id="1-CAP原则"><a href="#1-CAP原则" class="headerlink" title="1. CAP原则"></a>1. CAP原则</h2><p>CAP原则是指，在一个分布式系统中，<strong>Consistency （一致性）、Availablity（可用性）、Partition tolerance（分区容错性），最多只能同时满足三个特性中的两个，三者不可兼得</strong>。</p>
<ul>
<li><strong>consistency一致性</strong>：<ul>
<li><strong>更新操作成功并返回客户端后，所有节点在同一时间的数据完全一致</strong>，这就是分布式的一致性。一致性的问题在并发系统中不可避免，对于客户端来说，一致性指的是并发访问时，更新过的数据如何获取的问题。从服务端来看，则是更新复制如何分布到整个系统，以保证数据最终一致。</li>
</ul>
</li>
<li><strong>Availability可用性</strong>：<ul>
<li>可用性即“read and write always succeed”，即服务一直可用，而且是正常响应时间。好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。</li>
</ul>
</li>
<li><strong>Partition Tolerance分区容错性</strong>：<ul>
<li>分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。分区容错性要求能够使应用最然是一个分布式系统，但看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或几个机器宕掉了，其他剩下的机器还是能够正常运转满足系统需求，对于用户而言并没有什么体验上的影响。</li>
</ul>
</li>
</ul>
<h4 id="为什么分布式系统中无法同时保证一致性和可用性？"><a href="#为什么分布式系统中无法同时保证一致性和可用性？" class="headerlink" title="为什么分布式系统中无法同时保证一致性和可用性？"></a>为什么分布式系统中无法同时保证一致性和可用性？</h4><p>首先，对于一个分布式系统而言，分区容错性是一个最基本的要求，因此基本上我们在<strong>设计分布式系统的时候只能从一致性和可用性之间进行取舍。</strong></p>
<ul>
<li><strong>如果保证了一致性</strong>：对于节点N1和N2，当向N1中写入数据时，N2上的操作必须被暂停，只有当N1同步数据到N2时才能对 N2进行读写请求。在N2被暂停操作期间，客户端提交的请求要么失败或者超时。这显然与可用性相悖。</li>
<li><strong>如果保证了可用性</strong>：那就不能暂停N2的读写操作，但是这时N1在写数据啊，这显然也不符合一致性的要求。</li>
</ul>
<p>总结来说：<strong>为了保证一致性，不能访问未同步完成的节点，也就失去了部分可用性。为了保证可用性，允许读取所有结点的数据，但是数据可能不一致。</strong></p>
<h4 id="如何在可用性和一致性之间进行权衡和取舍？"><a href="#如何在可用性和一致性之间进行权衡和取舍？" class="headerlink" title="如何在可用性和一致性之间进行权衡和取舍？"></a>如何在可用性和一致性之间进行权衡和取舍？</h4><p>在分布式系统中，分区容错性必不可少，因为总要假定网络是不可靠的。因此，CAP理论实际上是要在一致性和可用性之间做取舍。</p>
<ul>
<li><strong>最终一致思想</strong>：各分支事务分别进行提交，如果有不一致的情况，再想办法恢复数据；</li>
<li><strong>强一致思想</strong>：各分支事务执行完业务不要提交，等待彼此结果，而后统一提交或回滚；</li>
</ul>
<h2 id="2-BASE理论"><a href="#2-BASE理论" class="headerlink" title="2. BASE理论"></a>2. BASE理论</h2><p>BASE理论是 <strong>基本可用（Basically Available）、软状态（Soft State）</strong>和 <strong>最终一致性（Eventually Consistent）</strong>三个短语的缩写。</p>
<p>BASE是CAP理论中AP方案的延申。核心思想是<strong>即使无法做到强一致性</strong>（CAP中的一致性就是强一致性），但应用<strong>可以采用适合的方式达到最终一致性</strong>。其思想包括三个方面：</p>
<ul>
<li><strong>Basically Available基本可用</strong>：基本可用是指分布式系统在<strong>出现不可预知的故障的时候，允许损失部分可用性，但不等于系统不可用</strong>。</li>
<li><strong>Soft State软状态</strong>：即指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即<strong>允许系统在不同节点之间的数据副本之间进行数据同步的过程存在延时</strong>。</li>
<li><strong>Eventually consistent最终一致性</strong>：强调系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。其本质是需要<strong>系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</strong></li>
</ul>
<h2 id="分布式一致性算法"><a href="#分布式一致性算法" class="headerlink" title="分布式一致性算法"></a>分布式一致性算法</h2><h3 id="1-Paxos算法"><a href="#1-Paxos算法" class="headerlink" title="1. Paxos算法"></a>1. Paxos算法</h3><p>Paxos算法是基于消息传递且具有高效容错性的一致性算法，目前公认的解决分布式一致性问题最有效的算法之一。</p>
<p>在Paxos有三类角色：</p>
<ul>
<li>Proposer提议者：提议者提出提案，用于投票表决。</li>
<li>Acceptor接受者：对提案进行投票，并接受达成共识的提案。</li>
<li>Learner学习者：被告知投票的结果，接受达成共识的提案。</li>
</ul>
<p><strong>Paxos算法是一个两阶段的过程，包括 准备阶段 和 接受阶段 两个阶段。</strong></p>
<p><strong>准备阶段：</strong> </p>
<ul>
<li>第一步，提案编号选择：Proposer提议者选择一个提案编号N，这个编号必须是全局唯一且递增的，可以使用时间戳加服务器ID来生成。</li>
<li>第二步，发送Prepare请求：Proposer向半数以上的Acceptor发送编号为N的Prepare请求。</li>
<li>第三步，响应处理：Acceptor在收到Prepare请求后，如果他没有收到更高编号的Prepare请求，就会承诺不再接受更低编号的提案，并回应Proposer。</li>
</ul>
<p><strong>接受阶段：</strong></p>
<ul>
<li>第一步，发送Accept请求：当多个Proposer收到多数Acceptor对Prepare请求的响应后，他将发送一个携带提案内容和提案编号N的Accept请求给所有Acceptor。</li>
<li>第二步，接受提案：Acceptor在收到Accept请求后，如果该请求的请求编号大于等于他已经响应的Prepare请求中的最大编号，那么他就会接受这个请求。</li>
<li>第三步，学习结果：一旦提案被多数Acceptor接受，该提案就被认为是选定的，Learner可以从Acceptor那里获取并学习这个决策结果。</li>
</ul>
<p>总的来说，Paxos算法通过这两个阶段的交互，确保了即使在部分节点或网络出现问题的情况下，分布式系统也能够就某个值达成一致性。这个过程需要满足一定的条件，以确保最终能够选出一个提案。</p>
<h3 id="2-Raft算法"><a href="#2-Raft算法" class="headerlink" title="2. Raft算法"></a>2. Raft算法</h3><p>Raft算法也是一个一致性算法，Paxos和Raft的区别在于选举过程不同。Raft算法流程的详细描述如下：</p>
<p>在raft中，时间被分为一个个任期，每次任期开始都要重新进行选举。</p>
<p>Raft协议将Server进程分为三个角色：</p>
<ul>
<li>leader 领导者；</li>
<li>follower 跟随者；</li>
<li>candidate 候选人；</li>
</ul>
<p>首先开启一轮大选，大选期间所有 follower都能参与竞选，这时所有follower的角色就变成了 候选人candidate，民主投票选出leader后，就开始这届leader的任期，然后选举结束，所有除leader外的candidate变为follower，听从leader的领导。</p>
<p>leader的选举过程如下：</p>
<p>Raft使用心跳触发leader选举，当server启动时，角色初始化为follower，leader向所有follower周期性发送心跳。如果follower在选举时间内没有收到leader的心跳，就会等待一段随机的时间后发起一次leader选举。</p>
<p>follower将其当前任期term加一，然后转换角色为candidate。它首先给自己投票，并给集群中的其他服务器发送 requestVote RPC。结果有以下三种情况：</p>
<ul>
<li>赢得了多数选票，成功选举为leader；</li>
<li>收到了leader的消息，表示有其他服务器已经抢先当上了leader；</li>
<li>没有server赢得多数的选票，leader选举失败，等待选举时间超时后，发起下一次选举。</li>
</ul>
<p>选举出leader后，leader通过定期向所有follower发送心跳维持其统治。若follower一段时间后没有收到leader的心跳，则认为leader已经挂了，然后发起新的选举过程。</p>
<h1 id="Maven-amp-Git"><a href="#Maven-amp-Git" class="headerlink" title="Maven &amp; Git"></a>Maven &amp; Git</h1><h2 id="Maven生命周期"><a href="#Maven生命周期" class="headerlink" title="Maven生命周期"></a>Maven生命周期</h2><p>Maven有以下<strong>三个标准的生命周期</strong>：</p>
<p>1、<strong>Clean生命周期</strong>：</p>
<ul>
<li><strong>clean</strong>：删除目标目录中的编译输出文件。这通常是在构建（Build）过程之前执行的，以确保项目从一个干净的状态开始。</li>
</ul>
<p>2、<strong>Default生命周期</strong>（也成为Build生命周期）：</p>
<ul>
<li><strong>validate 验证</strong>：验证项目的正确性，例如检查项目的版本是否正确。</li>
<li><strong>compile 编译</strong>：编译项目的源代码。</li>
<li><strong>test 测试</strong>：运行项目的单元测试。</li>
<li><strong>package 打包</strong>：将编译后的代码打包成可分发的格式，例如jar或者war。</li>
<li><strong>verify 检查</strong>：对项目进行额外的检查以确保质量。</li>
<li><strong>install 安装</strong>：将项目的构建结果安装到本地Maven仓库中，以供其他项目使用。</li>
<li><strong>deploy 部署</strong>：将项目的构建结果复制到远程仓库，以供其他开发人员或团队使用。</li>
</ul>
<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240701213354361.png" alt="image-20240701213354361" style="zoom:67%;" />

<p>3、<strong>Site生命周期</strong>：</p>
<ul>
<li><strong>site</strong>：生成项目文档和站点信息。</li>
<li><strong>deploy-site</strong>：将生成的站点信息发布到远程服务器，以便共享文档。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://shadiaoyu.github.io/2023/10/23/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/23/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">刷题笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-10-23 14:44:21 / 修改时间：16:33:09" itemprop="dateCreated datePublished" datetime="2023-10-23T14:44:21+08:00">2023-10-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="java优先级队列-and-比较器"><a href="#java优先级队列-and-比较器" class="headerlink" title="java优先级队列 and 比较器"></a>java优先级队列 and 比较器</h3><p>(1) 比较器Comparator：</p>
<p>Comparator接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类需要实现Comparator接口，它一定要实现compareTo(T o1,T o2) 函数，但可以不实现equals(Object object) 函数。</p>
<p>当第一个参数小于、等于、或大于第二个参数时，compareTo函数返回负值、零值或正值。</p>
<p>可以使用Lambda表达式实现匿名内部类的方法来定义比较器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;<span class="type">int</span>[]&gt; comparator = (arr1, arr2) -&gt; arr1[<span class="number">0</span>] - arr2[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>(2) 优先级队列PriorityQueue</p>
<p><strong>优先级队列默认使用小根堆，升序排列（1的优先级最高，234…优先级依次减少）。</strong></p>
<p>Java集合框架中提供了<strong>PriorityQueue</strong>和<strong>PriorityBlockingQueue</strong>两种类型的优先级队列，PriorityQueue是<strong>线程不安全</strong>的，PriorityBlockingQueue是<strong>线程安全</strong>的</p>
<p>PriorityQueue的几种常见构造方式：</p>
<ul>
<li>PriorityQueue() : 创建一个空的优先级队列，默认容量是11；</li>
<li>PriorityQueue(int initialCapacity) ：创建一个初始容量为initialCapacity的优先级队列，注意：值小于1会爆出IllegalArgumentException 异常；</li>
<li>PriorityQueue(Collection &lt;? extends E&gt; c)：用一个集合来创建优先级队列；</li>
<li>PriorityQueue(Comparator&lt;? super E&gt; comparator) ：创建具有初始容量的优先级队列，并根据指定的比较器对元素进行排序；</li>
</ul>
<p><strong>使用比较器comparator构造优先级队列priorityQueue:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((n1,n2) -&gt; n1-n2); <span class="comment">// 默认的顺序也是如此</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((n1,n2) -&gt; n2-n1); <span class="comment">// 降序排列（4优先级最高，321优先级依次降低）</span></span><br></pre></td></tr></table></figure>

<p>优先级内部依据比较器返回结果进行处理。</p>
<ul>
<li><p>在比较n1和n2的时候，如果结果大于0（n1-n2&gt;0）那么将n1下沉（大的数进行下沉，即小根堆的操作）；</p>
</li>
<li><p>当比较器返回值修改为n2-n1的时候，如果结果大于0（n2-n1&gt;0）,还是n1下沉（也就是说，无论n1大还是n2大，都会将n1下沉，但是现在这种情况相当于将小的数进行下沉，即大根堆的操作，此时应该是降序排列了）。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://shadiaoyu.github.io/2023/10/16/SpringCloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/16/SpringCloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">SpringCloud学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-16 15:27:59" itemprop="dateCreated datePublished" datetime="2023-10-16T15:27:59+08:00">2023-10-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-03 17:15:23" itemprop="dateModified" datetime="2024-04-03T17:15:23+08:00">2024-04-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-Feign与Gateway中的负载均衡："><a href="#1-Feign与Gateway中的负载均衡：" class="headerlink" title="1. Feign与Gateway中的负载均衡："></a>1. Feign与Gateway中的负载均衡：</h3><ul>
<li>Feign中的负载均衡是指微服务的实例和实例之间互相调用时进行负载均衡（内部）；</li>
<li>Gateway中的负载均衡是指对用户请求进行负载均衡（外部）；</li>
</ul>
<h3 id="2-Docker命令"><a href="#2-Docker命令" class="headerlink" title="2. Docker命令"></a>2. Docker命令</h3><h4 id="（1）Docker镜像命令："><a href="#（1）Docker镜像命令：" class="headerlink" title="（1）Docker镜像命令："></a>（1）Docker镜像命令：</h4><ul>
<li><p>查看镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o [outputFile] [imageName]</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [imageName]</span><br></pre></td></tr></table></figure>
</li>
<li><p>从文件加载镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i [xxx.tar(镜像文件)]</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（2）Docker容器命令："><a href="#（2）Docker容器命令：" class="headerlink" title="（2）Docker容器命令："></a>（2）Docker容器命令：</h4><ul>
<li><p>运行容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name [containerName] -p [80]:[80] -d [imageName]</span><br></pre></td></tr></table></figure>

<p>命令解读：</p>
<ul>
<li>docker run: 创建并运行一个容器；</li>
<li>–name: 给容器起一个名字；</li>
<li>-p: 将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口；</li>
<li>-d: 后台运行容器；</li>
<li>【imageName】: 镜像名称；</li>
</ul>
</li>
<li><p>暂停容器（运行态到暂停状态）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止暂停（暂停状态到运行状态）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause</span><br></pre></td></tr></table></figure>
</li>
<li><p>终止容器（运行态到终止态）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动容器（终止态到运行态）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入容器执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it [containerName] bash</span><br></pre></td></tr></table></figure>

<p>命令解读：</p>
<ul>
<li>docker exec：进入容器内部，执行一个命令；</li>
<li>-it：给当前进入的容器创建一个标准输入、输出终端，允许我们与容器进行交互；</li>
<li>mn：要进入的容器的名称；</li>
<li>bash：进入 容器后执行的命令，bash是一个linux终端的交互命令；</li>
</ul>
</li>
<li><p>查看容器运行日志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看所有运行的容器及状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除指定容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（3）Docker数据卷命令"><a href="#（3）Docker数据卷命令" class="headerlink" title="（3）Docker数据卷命令"></a>（3）Docker数据卷命令</h4><ul>
<li><p>数据卷操作的基本语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure>

<p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p>
<ul>
<li>create：创建一个volume;</li>
<li>inspect：显示一个或多个volume的信息；</li>
<li>ls：列出所有volume;</li>
<li>prune：删除未使用的volume;</li>
<li>rm：删除一个或多个指定的volume;</li>
</ul>
</li>
<li><p>例子：创建一个nginx容器，并挂载数据卷到容器内的html目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name myNginx -v html:/usr/share/nginx/html -p 80:80 -d nginx</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-Docker自定义镜像"><a href="#3-Docker自定义镜像" class="headerlink" title="3. Docker自定义镜像"></a>3. Docker自定义镜像</h3><h4 id="镜像结构："><a href="#镜像结构：" class="headerlink" title="镜像结构："></a>镜像结构：</h4><ul>
<li>镜像是将应用程序及其所需要的系统函数库、环境、配置、依赖打包而成。</li>
</ul>
<h4 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile:"></a>DockerFile:</h4><p>DockerFile就是一个文本文件，其中包含 一个个的<strong>指令（Instruction）</strong>，用指令说明要执行什么操作来构建镜像。每一个指令都会形成一层layer。</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20231021202201010.png" alt="image-20231021202201010"></p>
<p>根据dockerFile创建镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t [repository:tag] [dockFilePath]</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t javaweb:1.0 ../dockerfile/</span><br></pre></td></tr></table></figure>

<ul>
<li>DockerFile的本质是一个文件，通过指令描述镜像的构建过程。</li>
<li>DockerFile的第一行必须是FROM，从一个基础镜像来构建</li>
<li>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如java8-alpine。</li>
</ul>
<h1 id="微服务架构特征"><a href="#微服务架构特征" class="headerlink" title="微服务架构特征"></a>微服务架构特征</h1><ul>
<li>单一职责：微服务拆分粒度更小，每个业务都对应唯一的业务能力，做到单一职责。</li>
<li>自治：团队独立，技术独立，数据独立，独立部署和交付。</li>
<li>面向服务：服务提供统一标准的接口，与语言和技术无关。</li>
<li>隔离性强：服务调用做好隔离，容错，降级、避免出现级联问题。</li>
</ul>
<h2 id="服务拆分原则"><a href="#服务拆分原则" class="headerlink" title="服务拆分原则"></a>服务拆分原则</h2><ul>
<li>不同微服务，不要重复开发相同的业务</li>
<li>微服务数据独立，不要访问其它微服务的数据库</li>
<li>微服务可以将自己的业务暴露为接口，供其他微服务调用</li>
</ul>
<h2 id="1-注册中心（Eureka，Nacos）"><a href="#1-注册中心（Eureka，Nacos）" class="headerlink" title="1. 注册中心（Eureka，Nacos）"></a>1. 注册中心（Eureka，Nacos）</h2><h3 id="1-1Eureka"><a href="#1-1Eureka" class="headerlink" title="1.1Eureka"></a>1.1Eureka</h3><ul>
<li><p>问题1：服务1如何得知服务2的实例地址（服务1 调用 服务2）？</p>
<p>获取地址信息的流程如下：</p>
<ul>
<li><strong>服务注册：</strong>服务2的服务实例启动后，会将自己的信息注册到 Eureka服务端 。这就叫做服务注册。</li>
<li><strong>服务端保存映射关系：</strong>Eureka服务端保存<code>服务名称</code>到<code>服务实例地址列表</code>的映射关系</li>
<li><strong>服务发现：</strong>服务1根据服务名称，拉取实力地址列表。这就叫做服务发现</li>
</ul>
</li>
<li><p>问题2：服务1如何从多个服务2的实例中选择一个具体的实例？</p>
<ul>
<li>服务1 从实力列表中，利用负载均衡算法，选择一个实例地址</li>
<li>向该实例地址发起远程调用</li>
</ul>
</li>
<li><p>服务1 如何得知某个 服务2实例是否仍然健康？是不是已经宕机？</p>
<ul>
<li>服务2（被调用方）会每隔一段时间（默认30秒），向Eureka服务端报告自己的状态，<strong>称为心跳</strong>。</li>
<li>超过一定时间没有发送心跳时，Eureka服务端会认为微服务实例故障，将该实例从服务列表中删除。</li>
<li>服务1（调用方）拉取服务时，就能将故障实例排除了。</li>
</ul>
</li>
<li><p><strong>注意，一个微服务，既可以是服务提供者，也可以是服务调用者，因此Eureka将服务注册，服务发现等功能统一封装到了Eurkea-client端</strong>。</p>
</li>
</ul>
<p>（1）具体实现（orderservice在8080，userservice有两个实例，分别部署在8081和8082）：</p>
<ol>
<li><p>服务发现、服务注册都封装在eureka-client依赖，因此两个service都要引入<code>eureka-client</code>依赖。</p>
</li>
<li><p><strong>服务注册：</strong>user service是服务提供者，我们需要在这个服务里面修改yaml，添加服务名称、eureka地址。</p>
<p>eureka.client.service-url 指定服务端的注册地址，这个是客户端使用的，告诉客户端服务的地址，它可以指定多个，有一个默认的defaultZone。</p>
<pre><code>  3.  **服务发现：**现在将orderService的逻辑修改，向eureka-server拉取user service的信息，实现服务发现。
</code></pre>
<ul>
<li><p>引入依赖，指定注册地址（就是前面的那个）</p>
</li>
<li><p>在orderservice 的主程序中，给restTemplate这个bean添加一个@LoadBanlanced注解。（这样就实现了负载均衡）。</p>
</li>
<li><p>修改orderservice服务中的orderservice类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Order <span class="title function_">queryOrderById</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://userservice/user/&quot;</span> + order.getUserId();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class);</span><br><span class="line">        order.setUser(user);</span><br><span class="line">        <span class="comment">// 4.返回</span></span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p> spring 会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实力列表，而后完成负载均衡。</p>
<pre><code>  4.  **Ribbon负载均衡**
</code></pre>
<p> springCloud其实是使用了一个名为ribbon的组件，来实现负载均衡。</p>
<p> <img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240323202022271.png" alt="image-20240323202022271"></p>
<p> springCloudRibbon的底层采用了一个拦截器，拦截了restTemplate发出的请求，对地址做出了修改。</p>
<p> <img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240323202201453.png" alt="image-20240323202201453"></p>
<p> <strong>基本流程如下：</strong></p>
<ul>
<li>拦截rest Template请求<code>http://userservice/user/1</code></li>
<li>ribbonLoadBanlancerClient会从请求url中获取服务名称，即user service</li>
<li>DynamicServerListLoadBalander根据user service到eureka拉取服务列表。</li>
<li>eureka返回列表，user service拢共两个实例，那么就返回这两个实例的地址。</li>
<li>IRule利用内置负载均衡规则，从列表中挑选一个服务地址（假设是localhost:8081）。</li>
<li>RibbonLoadBalancer修改请求地址，用localhost:8081替代user service，得到<a target="_blank" rel="noopener" href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li>
</ul>
<p> <strong>Ribbon默认是采用懒加载，即第一次访问时才会去创建loadBalanceClient，请求时间会很长。</strong>而饥饿加载、会在项目启动时创建，降低第一次访问的耗时。通过下面的配置开启饥饿加载：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ribbon:</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: <span class="literal">true</span> # 开启饥饿加载</span><br><span class="line">    clients:</span><br><span class="line">      - userservice # 指定饥饿加载的服务名称</span><br><span class="line">      - xxxxservice # 如果需要指定多个，需要这么写</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-2-Nacos"><a href="#1-2-Nacos" class="headerlink" title="1.2 Nacos"></a>1.2 Nacos</h3><ol>
<li><p><strong>与eureka的联系：</strong>springCloudAlibaba也遵循spring Cloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。nacos跟eureka的主要区别在于（1）依赖不同（2）服务地址不同</p>
</li>
<li><p><strong>前期准备工作：</strong>安装nacos，<strong>nacos默认运行在8848端口</strong>。进入安装目录下的bin目录，执行<code>startup.cmd -m standalone</code>即可开启nacos服务。</p>
</li>
<li><p><strong>引入依赖：</strong></p>
<ul>
<li>在父工程的pom文件中引入spring Cloud Alibaba的依赖。</li>
<li>在两个服务userservice和orderService中的pom文件中引入nacos-discovery依赖。</li>
</ul>
</li>
<li><p><strong>配置nacos地址：</strong>在userservice和orderservice的application.yml中添加nacos地址如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重启微服务后，登录nacos管理页面，可以看到微服务信息。</strong></p>
</li>
<li><p><strong>服务分级存储模型：</strong></p>
<ul>
<li><p>一个服务可以有多个实例，假如这些实例分布于全国各地的不同机房，nacos就会将同一机房内的实例划分为一个<strong>集群</strong>。</p>
</li>
<li><p>也就是说，一个服务可以有多个集群，这些集群下面就是该服务的多个实例。</p>
</li>
<li><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才会访问其他集群。</p>
</li>
</ul>
</li>
<li><p><strong>给user-service配置集群：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:<span class="number">8848</span></span><br><span class="line">      discovery:</span><br><span class="line">        cluster-name: HZ # 集群名称</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>同集群优先的负载均衡：</strong>默认的ZoneAvoidanceRule并不能</p>
</li>
</ol>
<h2 id="2-消息队列MQ（RabbitMQ-、SpringAMQP）"><a href="#2-消息队列MQ（RabbitMQ-、SpringAMQP）" class="headerlink" title="2. 消息队列MQ（RabbitMQ 、SpringAMQP）"></a>2. 消息队列MQ（RabbitMQ 、SpringAMQP）</h2><ul>
<li><p><strong>同步调用的问题（微服务间基于Feign的调用就属于同步方式，存在一些问题）：</strong></p>
<ul>
<li>（1）耦合导致改动很麻烦：每次加入新的需求，都要修改原来的代码；</li>
<li>（2）性能与吞吐量的下降：调用者需要等待服务提供者相应，如果调用链过长则响应时间等于调用的时间之和；</li>
<li>（3）产生了严重的资源浪费：调用链中的每个服务在等待响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源；</li>
<li>（4）级联失败：如果服务提供者出现问题，所有调用方都会跟着出问题；</li>
</ul>
</li>
<li><p><strong>异步调用方案：解决了上述的同步调用的问题。引入事件代理Broker，用户服务向broker发布事件，由broker进行通知。</strong></p>
<ul>
<li>另一个优势是，可以进行<strong>流量削峰</strong>，broker可以起到一个缓冲的作用，降低服务的压力。</li>
<li>总结来说，异步通信的优点在于（1）耦合度低（2）吞吐量提升（3）故障隔离（4）流量削峰；异步通信的缺点在于<strong>（1）依赖于Broker的可靠性，安全性以及吞吐能力（2）架构复杂了，业务没有明显的流程线，不好追踪管理</strong>。</li>
</ul>
</li>
<li><p><strong>各个MQ消息队列之间的对比：</strong></p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240326151804916.png" alt="image-20240326151804916"></p>
</li>
<li><p>RabbitMQ的broker工作流程：</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240326152825654.png" alt="image-20240326152825654"></p>
</li>
<li><p><strong>Rabbit中的几个概念：</strong></p>
<ul>
<li>channel：操作MQ的工具</li>
<li>exchange：路有消息到队列中</li>
<li>queue：缓存消息</li>
<li>virtual host：虚拟主机，是对queue、exchange等资源的逻辑分组。</li>
</ul>
</li>
<li><p><strong>RabbitMQ常见消息模型：</strong></p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240326153454835.png" alt="image-20240326153454835"></p>
</li>
</ul>
<h3 id="2-1-springAMQP"><a href="#2-1-springAMQP" class="headerlink" title="2.1 springAMQP"></a>2.1 springAMQP</h3><ul>
<li><p>AMQP是应用间消息通信的一种协议，与语言和平台无关。</p>
</li>
<li><p>springAMQP是基于AMQP协议定义的一套API规范，提供了模板来发送和接收消息。包含两部分，其中spring-amqp是基础抽象，spring-rabbit是底层的默认实现。</p>
</li>
<li><p><strong>利用SpringAMQP实现helloworld中的基础消息队列功能</strong></p>
<ul>
<li><p>流程如下：</p>
<ul>
<li>1.在父工程中引入spring-ampq的依赖。</li>
<li>2.在publisher服务中利用<strong>RabbitTemplate</strong>发送消息到simple.queue这个队列。</li>
<li>3.在consumer服务中编写消费逻辑，绑定simple.queue这个队列。</li>
</ul>
</li>
<li><p>首先，配置publisher和consumer的application.yaml:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.1</span>.设置连接参数，分别是：主机名、端口号、用户名、密码、vhost</span><br><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    virtual-host: /</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后编写测试类springAmqpTest用于实现消息发送:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testSendMessage2SimpleQueue</span> <span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend (queueName,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在consumer中新建一个类,来实现消息的接收：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring消费者接收到消息：&quot;</span> + meg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结，SpringAMQP如何接收消息：</strong></p>
<ul>
<li>引入amqp的starter依赖</li>
<li>配置RabbitMQ地址</li>
<li>定义类，添加@Component注解</li>
<li>类中声明方法 ，添加@RabbitListener注解，方法参数就是消息。</li>
</ul>
<p>注意，消息一旦消费就会从队列中删除，rabbitMQ没有消息回溯功能。</p>
</li>
</ul>
</li>
<li><p><strong>SpringAMQP消息预取机制</strong></p>
<ul>
<li>预取机制就是，当消息进入到消息队列的时候，消费者不管自己的消费能力有多少，轮流预取队列中的消息，随后进行消费，这会导致低消费能力的consumer也有可能处理很多的消息。</li>
<li><strong>解决办法：</strong>修改application.yaml文件，设置<code>spring-rabbitmq-listener-simple-prefetch</code>属性，可以控制预取消息的上限。</li>
</ul>
</li>
<li><p><strong>发布订阅模型：</strong>发布订阅模式与之前的区别就在于允许将同一消息发送给多个消费者，实现方式是加入了exchange（交换机）（也就是说，同一个消息可以被多个消费者消费）</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240326170444055.png" alt="image-20240326170444055"></p>
</li>
<li><p><strong>FanoutExchange</strong></p>
<ul>
<li>交换机的作用是什么？<ul>
<li>接收publisher发送的消息</li>
<li>将消息按照规则路由到与之绑定的队列（fanout是广播，会路由到所有队列）</li>
<li>不能缓存消息，路由失败，消息会丢失</li>
<li>FanoutExchange会将消息路由到每个绑定的队列</li>
</ul>
</li>
<li>声明队列、交换机、绑定关系的Bean是什么？<ul>
<li>Queue</li>
<li>FanoutExchange</li>
<li>Binding</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>DirectExhange:</strong> 其会将接收到的消息根据路由规则路由到指定的Queue，因此称为路由模式（router）</p>
<ul>
<li>每一个Queue都与Exchange设置一个BindingKey</li>
<li>发布者发布消息时，指定消息的RoutingKey</li>
<li>Exchange将消息路由到BindingKey与消息RoutingKey一致的队列</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://shadiaoyu.github.io/2023/10/09/JUC%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/09/JUC%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">JUC学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-10-09 19:48:37 / 修改时间：19:52:56" itemprop="dateCreated datePublished" datetime="2023-10-09T19:48:37+08:00">2023-10-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-Synchroize的使用"><a href="#1-Synchroize的使用" class="headerlink" title="1. Synchroize的使用"></a>1. Synchroize的使用</h3><ul>
<li>synchronized在方法上使用时，锁住的是this对象；</li>
<li>synchronized在<strong>静态</strong>方法上使用时，锁住的是当前类；</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
