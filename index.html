<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/test1/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/test1/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/test1/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/test1/images/logo.svg" color="#222">

<link rel="stylesheet" href="/test1/css/main.css">


<link rel="stylesheet" href="/test1/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"gitee.com","root":"/test1/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="沙雕鱼罐头">
<meta property="og:url" content="https://gitee.com/SHaDiaoYU/index.html">
<meta property="og:site_name" content="沙雕鱼罐头">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="jiawei">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://gitee.com/SHaDiaoYU/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>沙雕鱼罐头</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/test1/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">沙雕鱼罐头</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/test1/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/test1/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/SHaDiaoYU/2024/05/08/api%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D-%E5%85%AB%E8%82%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/test1/images/avatar.gif">
      <meta itemprop="name" content="jiawei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕鱼罐头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/test1/2024/05/08/api%E5%BC%80%E6%94%BE%E5%B9%B3%E5%8F%B0-%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D-%E5%85%AB%E8%82%A1/" class="post-title-link" itemprop="url">api开放平台-项目介绍&八股</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-08 21:57:42" itemprop="dateCreated datePublished" datetime="2024-05-08T21:57:42+08:00">2024-05-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/SHaDiaoYU/2024/04/08/%E5%A4%A9%E6%9C%BA%E5%AD%A6%E5%A0%82%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/test1/images/avatar.gif">
      <meta itemprop="name" content="jiawei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕鱼罐头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/test1/2024/04/08/%E5%A4%A9%E6%9C%BA%E5%AD%A6%E5%A0%82%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">天机学堂学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-08 14:29:18" itemprop="dateCreated datePublished" datetime="2024-04-08T14:29:18+08:00">2024-04-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/SHaDiaoYU/2024/03/19/redis%E5%A4%8D%E4%B9%A0-%E7%BB%93%E5%90%88%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/test1/images/avatar.gif">
      <meta itemprop="name" content="jiawei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕鱼罐头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/test1/2024/03/19/redis%E5%A4%8D%E4%B9%A0-%E7%BB%93%E5%90%88%E9%BB%91%E9%A9%AC%E7%82%B9%E8%AF%84/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-19 20:30:25" itemprop="dateCreated datePublished" datetime="2024-03-19T20:30:25+08:00">2024-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-23 22:17:25" itemprop="dateModified" datetime="2024-04-23T22:17:25+08:00">2024-04-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis:"></a>Redis:</h2><h3 id="Redis数据结构："><a href="#Redis数据结构：" class="headerlink" title="Redis数据结构："></a>Redis数据结构：</h3><p>（1）5种基础数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p>
<p>（2）3种特殊数据结构：HyperLogLogs（基数统计）、BitMap（位存储）、Geospatial（地理位置）</p>
<h4 id="1-Redis-双写一致性：redis作为缓存，mysql的数据如何与redis进行同步呢？"><a href="#1-Redis-双写一致性：redis作为缓存，mysql的数据如何与redis进行同步呢？" class="headerlink" title="1.Redis 双写一致性：redis作为缓存，mysql的数据如何与redis进行同步呢？"></a>1.Redis 双写一致性：redis作为缓存，mysql的数据如何与redis进行同步呢？</h4><p>这里有两种需求（1）一致性要求高的 （2）允许延迟一致，这里分开来描述：</p>
<ul>
<li><strong>一致性要求高的（但是性能不高）：</strong><ul>
<li>读数据的时候添加读锁（其他线程可以读，但是不能写，跟共享锁一个概念），写数据的时候添加写锁（其他线程既不能读，也不能写，类似于排他锁），读写锁可以从redission中获取。</li>
</ul>
</li>
<li><strong>允许延迟一致的（异步通知、基于Canal的异步通知）：</strong><ul>
<li><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240406200855325.png" alt="image-20240406200855325"></li>
<li>基于Canal的异步通知<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240406201005207.png" alt="image-20240406201005207"></li>
</ul>
</li>
</ul>
<p>无论是先更新数据库，再更新缓存；还是先更新缓存，再更新数据库，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象。</p>
<p><strong>因此采用Cache Aside 策略，不更新缓存，而是删除缓存中的数据。最后到读取数据时，发现缓存中没有数据之后，再从数据库中读取数据，更新到缓存中。</strong></p>
<ul>
<li><strong>写策略的步骤：</strong><ul>
<li>更新数据库中的数据</li>
<li>删除缓存中的数据</li>
</ul>
</li>
<li><strong>读策略的步骤：</strong><ul>
<li>如果读取的数据命中了缓存，则直接返回数据；</li>
<li>如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存中，并返回给用户。</li>
</ul>
</li>
</ul>
<p><strong>针对写策略步骤的执行先后顺序，又会有一些问题：</strong></p>
<ul>
<li>如果先删除缓存，再更新数据库的话，在<strong>读+写</strong>并发的时候，还是会出现缓存和数据库数据的不一致的情况；<ul>
<li>这种情况下为了解决一致性问题，我们采用<strong>延迟双删</strong>的方法，即<strong>删除缓存，更新数据库，延迟一段时间后，再次删除缓存。</strong>主要是为了确保请求A在睡眠的时候，请求B能够在这一段时间内完成从数据库读取数据，再把缺失的缓存写入缓存的操作，<strong>但是具体睡眠多久比较玄学，搞不好依然会出现 读脏数据的问题。</strong></li>
</ul>
</li>
<li>如果<strong>先更新数据库，再删除缓存</strong>，在并发的时候，还是会出现缓存和数据库的数据不一致的情况，<strong>但是出现这种情况的概率很小，因为缓存的写入远快于数据库的写入，</strong>很难出现请求B已经更新了数据库并删除了缓存后，请求A才更新完缓存的情况。<strong>所以，这种情况是可以保证一致性的</strong><ul>
<li>但是这个方案因为在每次更新数据库的时候都要删除缓存，所以会导致缓存命中率降低。因此可以采用<strong>更新数据库+ 更新缓存的方案</strong>，但是会出现并发安全问题，因此有两种解决办法<strong>（1）在更新缓存之前添加一个分布式锁，保证同一时间只有一个请求更新缓存；（2）更新完缓存之后，给缓存加上较短的过期时间，这样即使出现不一致的情况，数据也会很快过期。</strong></li>
</ul>
</li>
</ul>
<h3 id="黑马点评"><a href="#黑马点评" class="headerlink" title="黑马点评"></a>黑马点评</h3><h4 id="（1）商家缓存主动更新策略（根据id查询商家信息时用到）："><a href="#（1）商家缓存主动更新策略（根据id查询商家信息时用到）：" class="headerlink" title="（1）商家缓存主动更新策略（根据id查询商家信息时用到）："></a>（1）商家缓存主动更新策略（根据id查询商家信息时用到）：</h4><ul>
<li><p>这一策略同时进行数据库操作和缓存操作，加入了事务，以保证同成功同失败。</p>
</li>
<li><p><strong>先更新数据库，再更新缓存：</strong> 缓存的读写是很快的，而数据库的操作是很慢的，如果先操作缓存（即先删除缓存），再更新数据库时，另一个线程在进行同样的查询的过程中，由于没有读到缓存，会去读数据库中的数据（而数据库数据更新很慢，这时还没更新完成），因此会读到旧数据，并把这个旧数据给写入缓存中，这就导致了缓存数据和数据库数据的不一致。<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240320213306700.png"></p>
</li>
<li><p>具体实现:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">    <span class="comment">//更新店铺信息</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">        <span class="keyword">if</span> (id == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;店铺id 不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.更新数据库</span></span><br><span class="line">        updateById(shop);</span><br><span class="line">        <span class="comment">//2.删除缓存</span></span><br><span class="line">        stringRedisTemplate.delete(CACHE_SHOP_KEY + id);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（2）缓存穿透解决办法"><a href="#（2）缓存穿透解决办法" class="headerlink" title="（2）缓存穿透解决办法"></a>（2）缓存穿透解决办法</h4><ul>
<li><p><strong>缓存穿透是指，请求的数据在缓存和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库</strong></p>
</li>
<li><p><strong>解决策略：</strong></p>
<ul>
<li>缓存空对象（本项目用的这个） ：数据库也查不到信息后，向缓存中缓存空数据（会设置TTL），防止一直访问数据库。<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：因为缓存了空数据，造成了额外的内存消耗。同时，如果数据库又更新了数据，而此时缓存中仍为空数据，会造成短时间内的数据不一致（在缓存TTL结束后就可以保持一致了）。</li>
</ul>
</li>
<li>设置布隆过滤器：<ul>
<li>优点：内存占用比较少，没用使用多余的key。</li>
<li>缺点：实现复杂，并且存在误判的可能。</li>
</ul>
</li>
<li>缓存预热时，需要预热布隆过滤器。</li>
</ul>
</li>
</ul>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240320214835903.png" alt="image-20240320214835903"></p>
<ul>
<li>关于布隆过滤器的原理：<ul>
<li>当我们向过滤器添加一个元素key的时候，我们通过多个hash函数，分别计算出多个值，然后将这些值所在的位置置为1.</li>
<li><strong>那么如果新来一个数据，如何判断它存不存在？</strong>当新数据来的时候，同样使用前面的多个hash函数计算值，查看每一个计算结果对应的位置是不是1，如果有一个不是1，那么就认定这个数据不存在。</li>
<li><strong>如果每个位置都是1，也不能保证这个数据真的存在。</strong>毕竟多个数据可以通过hash计算出相同的位置。如果这个位置是1，可能是另一个数据计算得来的。<strong>因此，布隆过滤器可以判定某个数据一定不存在，但不能保证某个数据一定存在。</strong></li>
<li>布隆过滤器的优缺点很明显：使用二进制数组，占用内存极少，并且插入和查询速度都很快；但是随着数据的增加，误判率会增加，无法判断数据一定存在；此外还有一个重要的缺点，就是他无法删除数据。</li>
</ul>
</li>
</ul>
<h4 id="（3）缓存雪崩解决办法："><a href="#（3）缓存雪崩解决办法：" class="headerlink" title="（3）缓存雪崩解决办法："></a>（3）缓存雪崩解决办法：</h4><ul>
<li><strong>缓存雪崩</strong>是指在同一时段内，大量的缓存key同时失效或者redis服务宕机，导致大量的请求打到数据库，带来巨大的压力。</li>
<li>**解决策略： ** <ul>
<li>给不同的key的ttl添加随机值</li>
<li>利用redis集群提高服务的可用性</li>
<li>为缓存业务添加降级限流策略：分库分表可还行。</li>
<li>为业务设置多级缓存：例如使用本地缓存 + 分布式缓存的方式，不同级别缓存时间过时间不一样，即使某个级别缓存过期了，还有其他缓存级别兜底。</li>
</ul>
</li>
</ul>
<h4 id="（4）缓存击穿解决办法："><a href="#（4）缓存击穿解决办法：" class="headerlink" title="（4）缓存击穿解决办法："></a>（4）缓存击穿解决办法：</h4><ul>
<li><p><strong>缓存击穿</strong>也叫热点key问题，就是一个<strong>被高并发访问，并且缓存重建业务较复杂的key</strong>突然失效了，无数的请求访问会在瞬间给数据库带来巨大冲击。</p>
</li>
<li><p>缓存雪崩是指大量的缓存key失效，而缓存击穿是指热点key失效。缓存穿透是指要查的key在缓存中和数据库中都不存在。</p>
</li>
<li><p>（查询数据库和重建缓存的过程会很缓慢，在这期间如果有大量的请求过来，都是未命中，导致一直访问数据库。）<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240321202635871.png" alt="image-20240321202635871"></p>
</li>
<li><p><strong>解决策略：</strong> </p>
<ul>
<li><p>互斥锁：</p>
<ul>
<li><p>每个请求如果未命中缓存后需要进行缓存的重建工作，这时我们指定唯一获得互斥锁的线程进行缓存重建，等到重建完成后再释放锁。在此期间其他线程会重复缓存查询以及获取锁的过程。</p>
</li>
<li><p>关于互斥锁的构建，这里使用stringRedisTemplate 的setIfAbsent来进行实现（Redis的Setnx命令），<strong>在指定的key不存在时，为key设置指定的值。返回值表示设置成功与失败</strong></p>
</li>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F; 获取互斥锁，返回值标识是否获得<br>private boolean tryLock(String lockKey) {<br>    &#x2F;&#x2F; 添加锁，并设置有效期，有效期时长要比业务时间长<br>    Boolean flag &#x3D; stringRedisTemplate.opsForValue().setIfAbsent(lockKey, “1”, 10L, TimeUnit.SECONDS);<br>    &#x2F;&#x2F; 拆箱过程中可能会出现空指针异常，所以使用hutool提供的工具来解决<br>    return BooleanUtil.isTrue(flag);<br>}<br><br>&#x2F;&#x2F; 释放锁<br>private void unlock(String lockKey) {<br>    stringRedisTemplate.delete(lockKey);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 逻辑过期</span><br><span class="line"></span><br><span class="line">  * 逻辑过期并不是真正的过期，对于对应的key我们并不需要去设置TTL，而是通过业务逻辑来达到一个类似于过期的效果。其本质还是限制落到数据库的请求数量！</span><br><span class="line">  * 这样一来，缓存基本是会被命中的，因为没有给缓存设置任何过期时间，并且对于key的设置都是实现选择好的，如果出现未命中的情况基本可以判断他不在选择之内，这样我们就可以直接返回错误信息。</span><br><span class="line">  * 那么对于命中的情况，就需要先判断逻辑时间是否过期，再根据结果来决定是否进行缓存重建。**而这里的逻辑时间就是减少大量请求落到数据库的一个关口**</span><br><span class="line"></span><br><span class="line">* ![image-20240321202444133](https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240321202444133.png)</span><br><span class="line"></span><br><span class="line">* 在发现逻辑过期后（意味着数据更新），首先尝试获取互斥锁，在获取到锁后，会开启新的线程来进行缓存的重建，而原线程返回的是未更新的老数据，这意味着使用**逻辑时间不保证数据的一致性。**</span><br><span class="line"></span><br><span class="line">* **注意做逻辑过期时，要先预热，手动缓存热点key**</span><br><span class="line"></span><br><span class="line">* 在进行商铺信息的查询的过程中，使用了互斥锁以及逻辑过期时间的方式解决缓存击穿问题。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">/**</span><br><span class="line">     * 使用互斥锁，解决缓存击穿问题</span><br><span class="line">     * 缓存穿透问题：缓存穿透是指客户请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会被打到数据库。</span><br><span class="line">     * 缓存击穿问题：指热点key失效，大量请求打到数据库的问题。</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    private Shop queryWithMutex(Long id) &#123;</span><br><span class="line">        Shop shop;</span><br><span class="line">        //1.从redis中查询商铺缓存</span><br><span class="line">        String key = CACHE_SHOP_KEY + id;</span><br><span class="line">        String shopJson = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        //2.判断是否存在</span><br><span class="line">        if (StrUtil.isNotBlank(shopJson)) &#123;</span><br><span class="line">            //3.存在则直接返回</span><br><span class="line">            shop = JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">            return shop;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 因为我们在解决缓存穿透的时候会将空值放入redis中，所以可能会取得空值，因此需要对空值再进行一次判断</span><br><span class="line">        if (shopJson != null) &#123;</span><br><span class="line">            // 命中的信息是空值，所以直接进行返回</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        //添加互斥锁，解决缓存击穿问题</span><br><span class="line">        //第一步，获取互斥锁</span><br><span class="line">        String lockKey = RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">        try &#123;</span><br><span class="line">            boolean isLock = tryLock(lockKey);</span><br><span class="line">            //第二步，判断是否获得锁</span><br><span class="line">            if (!isLock) &#123;</span><br><span class="line">                //第三步，如果失败，进行休眠，休眠后重试</span><br><span class="line">                Thread.sleep(10);</span><br><span class="line">                return queryWithMutex(id);</span><br><span class="line">            &#125;</span><br><span class="line">            /*第四步，如果成功，应再次检测redis缓存是否存在，做double check，这样做的原因是我们在获得锁之后，其他</span><br><span class="line">             *线程可能已经将数据写入redis缓存中了，那么我们即使拿到锁，也没有必要再去查询数据库了，直接从redis中获取</span><br><span class="line">             * 就可以了。</span><br><span class="line">             * 而且，代码已经走到了这一步，说明我们的key取得的缓存不是我们用于解决缓存穿透时设置的空值了，因此不需要在进行</span><br><span class="line">             * 空值的校验了。</span><br><span class="line">             * */</span><br><span class="line">            String secondShopJson = stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">            if (StrUtil.isNotBlank(secondShopJson)) &#123;</span><br><span class="line">                // 缓存中存在，则直接返回</span><br><span class="line">                Shop secondShop = JSONUtil.toBean(shopJson, Shop.class);</span><br><span class="line">                return secondShop;</span><br><span class="line">            &#125;</span><br><span class="line">            //走到这，说明拿到锁后，缓存中依旧没有出现我们想要的值，那么就需要查询数据库了</span><br><span class="line">            shop = getById(id);</span><br><span class="line">            // 模拟重建的延时</span><br><span class="line">            Thread.sleep(200);</span><br><span class="line">            //5.判断数据库中是否存在</span><br><span class="line">            if (shop == null) &#123;</span><br><span class="line">                // 避免缓存穿透问题，若数据库中不存在数据，则在redis中存入空值</span><br><span class="line">                stringRedisTemplate.opsForValue().set(key, &quot;&quot;, RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">                //7.若不存在，则报错</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            //6.若存在，则存入redis缓存，并返回</span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonPrettyStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //释放锁</span><br><span class="line">            unlock(lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">        return shop;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用线程池来管理线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Shop <span class="title function_">queryWithLocalExpire</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        Shop shop;</span><br><span class="line">        <span class="comment">//1.从redis中获取缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_KEY + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJson</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line">        <span class="comment">//2.判断是否为空，如果为空则返回null;</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(shopJson)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.如果不为空，需要先把json反序列化为对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(shopJson, RedisData.class);</span><br><span class="line">        <span class="type">JSONObject</span> <span class="variable">data</span> <span class="operator">=</span> (JSONObject) redisData.getData();</span><br><span class="line">        shop = JSONUtil.toBean(data, Shop.class);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">expireTime</span> <span class="operator">=</span> redisData.getExpireTime();</span><br><span class="line">        <span class="comment">//4.获取时间，判断是否过期</span></span><br><span class="line">        <span class="keyword">if</span> (LocalDateTime.now().isBefore(expireTime)) &#123;</span><br><span class="line">            <span class="comment">//4.1 如果没有过期，则直接返回即可</span></span><br><span class="line">            <span class="keyword">return</span> shop;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.2 如果过期，需要进行缓存重建</span></span><br><span class="line">        <span class="comment">//5 缓存重建</span></span><br><span class="line">        <span class="comment">//6 获取互斥锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> RedisConstants.LOCK_SHOP_KEY + id;</span><br><span class="line">        <span class="comment">//6.1 判断是否获取成功，如果成功，开启新线程进行缓存重建</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> tryLock(lockKey);</span><br><span class="line">        <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 重建缓存</span></span><br><span class="line">                    <span class="built_in">this</span>.saveShop2Redis(id, <span class="number">20L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//7 返回旧数据</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240321210833411.png" alt="image-20240321210833411" style="zoom:67%;" /></li>
</ul>
<h4 id="5-基于List的点赞列表-amp-基于SortedSet的点赞排行榜"><a href="#5-基于List的点赞列表-amp-基于SortedSet的点赞排行榜" class="headerlink" title="(5) 基于List的点赞列表&amp;基于SortedSet的点赞排行榜"></a>(5) 基于List的点赞列表&amp;基于SortedSet的点赞排行榜</h4><ul>
<li><p>用户发表博文内容时，后端接收到的请求中不包含userID，userID需要我们从ThreadLocal中获取。在保存博文时，需要set博文的作者userID，在保存成功后，查询该用户的所有粉丝，并将博文信息推送给粉丝。</p>
</li>
<li><p>这里我们使用sortedSet来实现发布信息的推送，key为follow_user_id(粉丝ID)，value为blog_id，score为System.currentTimeMillis()。（这里可以优化为使用mq进行实现）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">        <span class="comment">//获取登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//保存blog</span></span><br><span class="line">        blog.setUserId(userId);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">save</span> <span class="operator">=</span> save(blog);</span><br><span class="line">        <span class="keyword">if</span> (save) &#123;</span><br><span class="line">            <span class="comment">//查询笔记作者的所有粉丝</span></span><br><span class="line">            List&lt;Follow&gt; follows = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, userId).list();</span><br><span class="line">            <span class="keyword">for</span> (Follow follow : follows) &#123;</span><br><span class="line">                <span class="comment">//获取粉丝id</span></span><br><span class="line">                <span class="type">Long</span> <span class="variable">followUserId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.FEED_KEY + followUserId;</span><br><span class="line">                <span class="comment">//推送</span></span><br><span class="line">                stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//推送笔记的id给所有粉丝</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回blog id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于博客实体类，我们通过‘@TableField(exist &#x3D; false)’注解来指定，icon（头像）,name（用户姓名）表示这两个字段不属于Blog表中的字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户图标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> String icon;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否点赞过了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isLike;</span><br></pre></td></tr></table></figure>


</li>
<li><p>因为用户和头像这俩字段不属于blog的数据表字段，所以不仅在保存博客的时候我们需要从threadLocal中获取用户id并保存，在查询博文内容的时候，我们还要根据博文的user ID来查询发布者的用户名以及头像等信息。</p>
</li>
<li><p><strong>点赞功能（首页探店排行榜&amp;博文详情页都可以点赞）</strong></p>
<p>点赞功能的需求如下：（1）同一个用户只能点赞一次，再次点击则取消点赞；（2）如果当前用户已经点赞，则点赞按钮高亮显示（前端已经实现了，判断字段Blog类的isLike属性）</p>
<ul>
<li><p>实现步骤：</p>
<ul>
<li><p>给Blog类中添加一个isLike字段，用来表示当前blog是否被当前用户点赞。</p>
</li>
<li><p>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数加1，已点赞过则点赞数-1。缓存key为blog的id，缓存采用sortedSet的数据结构，value为userID，score为用户点赞时刻（<strong>即，每个blogID对应的是所有点赞该blog的userid，userID根据用户点赞时间为score进行排序</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">likeBlog</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">//实现帖子点赞功能</span></span><br><span class="line">        <span class="comment">// 1. 获取当前登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//2.判断当前用户是否已经点赞</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.BLOG_LIKED_KEY + id;</span><br><span class="line">        <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">        <span class="keyword">if</span> (score == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//3.如果未点赞，可以点赞</span></span><br><span class="line">            <span class="comment">//3.1 数据库点赞数加一</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked + 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">            <span class="comment">//3.2 保存点赞用户id 到redis sortedSet集合</span></span><br><span class="line">            <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">                stringRedisTemplate.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4. 如果已经点赞，取消点赞</span></span><br><span class="line">            <span class="comment">//4.1 数据库点赞数减一</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> update().setSql(<span class="string">&quot;liked = liked - 1&quot;</span>).eq(<span class="string">&quot;id&quot;</span>, id).update();</span><br><span class="line">            <span class="comment">//4.2 将用户信息从reids sortedSet集合中删除</span></span><br><span class="line">            <span class="keyword">if</span> (isSuccess) &#123;</span><br><span class="line">                stringRedisTemplate.opsForZSet().remove(key, userId.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>修改queryBlogById方法，判断当前登录用户是否点赞过（即判断能不能查到当前userID，有就说明已点赞），并将结果赋值给blog的isLike字段。(<strong>isLike字段不属于blog表字段，它的作用是，当前用户如果点赞过，那么就将isLike置为真，在客户端发请求查询blog信息时，前端根据这个字段决定是否高亮显示点赞按钮</strong>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isBlogLiked</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">       <span class="comment">//判断当前笔记是否被点赞过</span></span><br><span class="line">       <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">       <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">//用户未登录，不用关心是否点赞过，直接返回</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.BLOG_LIKED_KEY + blog.getId();</span><br><span class="line">       <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> stringRedisTemplate.opsForZSet().score(key, userId.toString());</span><br><span class="line">       blog.setIsLike(score != <span class="literal">null</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>修改分页查询Blog业务，判断当前用户是否点赞过，赋值给isLike字段（<strong>这个业务是用于分页展示点赞排行榜的博文，点赞排行榜根据博文的点赞数量降序排序并分页展示的</strong>）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryHotBlog</span><span class="params">(Integer current)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据用户查询</span></span><br><span class="line">        Page&lt;Blog&gt; page = blogService.query()</span><br><span class="line">                .orderByDesc(<span class="string">&quot;liked&quot;</span>)</span><br><span class="line">                .page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));</span><br><span class="line">        <span class="comment">// 获取当前页数据</span></span><br><span class="line">        List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line">        <span class="comment">// 查询用户,以及查询是否被点赞过</span></span><br><span class="line">        records.forEach(blog -&gt; &#123;</span><br><span class="line">            <span class="built_in">this</span>.queryBlogUser(blog);</span><br><span class="line">            <span class="built_in">this</span>.isBlogLiked(blog);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(records);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询当前帖子被哪些用户点赞了（<strong>这里只在前端展示前5位点赞用户的头像，按照点赞时间从前到后进行排序</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryBlogLikes</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">//返回帖子点赞top5用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.BLOG_LIKED_KEY + id;</span><br><span class="line">        Set&lt;String&gt; top5 = stringRedisTemplate.opsForZSet().range(key, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">if</span> (top5 == <span class="literal">null</span> || top5.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 解析出其中的用户id</span></span><br><span class="line">        List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">        <span class="type">String</span> <span class="variable">idListStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">        <span class="comment">//3.根据用户id查询用户，返回已点赞用户列表</span></span><br><span class="line">        <span class="comment">//List&lt;UserDTO&gt; users = userService.listByIds(ids).stream().map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class)).collect(Collectors.toList());</span></span><br><span class="line">        List&lt;UserDTO&gt; users = userService.query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;order by field(id,&quot;</span> + idListStr + <span class="string">&quot;)&quot;</span>).list()</span><br><span class="line">                .stream()</span><br><span class="line">                .map(user -&gt; BeanUtil.copyProperties(user, UserDTO.class))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="comment">//4.返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(users);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="（6）好友关注功能"><a href="#（6）好友关注功能" class="headerlink" title="（6）好友关注功能"></a>（6）好友关注功能</h4><ul>
<li><p>在探店图文的详情页面中，可以关注发布笔记的作者：</p>
</li>
<li><p><strong>业务逻辑：</strong></p>
<ul>
<li><p><strong>关注用户</strong>功能的实现：前端传一个isFollow值，如果用户已经关注该博主，则isFollow为false，没有关注资格，但可以进行取关。反之为true，说明可以进行关注。new Follow对象，将user ID和userFollowID（用户关注的人）都set到Follow对象里。再将follow对象save到数据库表中。</p>
</li>
<li><pre><code class="java">public Result follow(Long id, boolean isFollow) &#123;
        //关注和取关
        //1. 获取登录用户
        UserDTO user = UserHolder.getUser();
        if (user == null) &#123;
            //如果用户未登录，不用判断是否关注
            return Result.ok();
        &#125;

        Long userId = user.getId();
        String key = RedisConstants.FOLLOW_USER_KEY + userId;
        if (isFollow) &#123;
            // 如果未关注，新增数据
            Follow follow = new Follow();
            follow.setUserId(userId);
            follow.setFollowUserId(id);
            boolean isSuccess = save(follow);
            if (isSuccess) &#123;
                stringRedisTemplate.opsForSet().add(key,id.toString());
            &#125;
        &#125; else &#123;
            //如果已关注，取关删除数据
            boolean isSuccess = remove(new QueryWrapper&lt;Follow&gt;().eq(&quot;user_id&quot;, userId).eq(&quot;follow_user_id&quot;, id));
            if (isSuccess) &#123;
                stringRedisTemplate.opsForSet().remove(key,id.toString());
            &#125;
        &#125;
        return Result.ok();
    &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* **查看他人主页功能的实现：**前端传该人的userID ，首先根据user ID查询用户信息，其次还要查询该用户发表的博文信息，并分页进行展示：</span><br><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  // 根据id查询用户</span><br><span class="line">      @GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="line">      public Result queryUserById(@PathVariable(&quot;id&quot;) Long userId)&#123;</span><br><span class="line">          // 查询详情</span><br><span class="line">          User user = userService.getById(userId);</span><br><span class="line">          if (user == null) &#123;</span><br><span class="line">              return Result.ok();</span><br><span class="line">          &#125;</span><br><span class="line">          UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);</span><br><span class="line">          // 返回</span><br><span class="line">          return Result.ok(userDTO);</span><br><span class="line">      &#125;</span><br><span class="line">  @GetMapping(&quot;/of/user&quot;)</span><br><span class="line">  public Result queryBlogByUserId(</span><br><span class="line">  		@RequestParam(value = &quot;current&quot;, defaultValue = &quot;1&quot;) Integer current,</span><br><span class="line">  		@RequestParam(&quot;id&quot;) Long id) &#123;</span><br><span class="line">  	// 根据用户查询</span><br><span class="line">  	Page&lt;Blog&gt; page = blogService.query()</span><br><span class="line">  			.eq(&quot;user_id&quot;, id).page(new Page&lt;&gt;(current, SystemConstants.MAX_PAGE_SIZE));</span><br><span class="line">  	// 获取当前页数据</span><br><span class="line">  	List&lt;Blog&gt; records = page.getRecords();</span><br><span class="line">  	return Result.ok(records);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><strong>共同关注功能的实现：</strong>共同关注功能使用redis中的<strong>set结构</strong>进行实现，求两个用户关注列表的交集，因此我们不仅需要吧数据存入follow表中（保存关注关系），还要把user ID放入redis的set集合中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">followCommons</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="comment">//获取当前用户</span></span><br><span class="line">        <span class="type">UserDTO</span> <span class="variable">user</span> <span class="operator">=</span> UserHolder.getUser();</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果用户未登录，不用判断是否关注</span></span><br><span class="line">            <span class="keyword">return</span> Result.ok();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">key1</span> <span class="operator">=</span> RedisConstants.FOLLOW_USER_KEY + userId;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key2</span> <span class="operator">=</span> RedisConstants.FOLLOW_USER_KEY + id;</span><br><span class="line">        <span class="comment">//求交集</span></span><br><span class="line">        Set&lt;String&gt; intersect = stringRedisTemplate.opsForSet().intersect(key1, key2);</span><br><span class="line">        <span class="comment">//查询交集中的用户 信息</span></span><br><span class="line">        <span class="keyword">if</span> (intersect == <span class="literal">null</span> || intersect.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());</span><br><span class="line">        List&lt;UserDTO&gt; commons = userService.listByIds(ids)</span><br><span class="line">                .stream().map(followUser -&gt; BeanUtil.copyProperties(followUser, UserDTO.class))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> Result.ok(commons);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>Feed流实现关注用户的博文推送：</strong></p>
<ul>
<li><p>本例中的个人界面，是基于关注的好友来进行feed流的，因此采用timeLine的方式，依照时间顺序刷新。（也有像抖音那种的，使用智能推荐算法进行推荐的智能排序的feed流）。</p>
</li>
<li><p>实现方案有三种：<strong>推模式、拉模式、推拉结合的模式（推拉是相对于当前用户而言的）</strong></p>
<ul>
<li>拉模式：又称为读扩散，每个博主发送信息的时候都发送到自己的发件箱中（一个缓冲区），用户读的时候从各个关注用户的发件箱中读取信息。但是读操作过于频繁，若用户关注了许多博主，一次要读的消息也是十分的多，延迟会很高。</li>
</ul>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240326203018064.png" alt="image-20240326203018064"></p>
<ul>
<li><p>推模式：又称为写扩散，每个用户有自己的收件箱（一个缓冲区），每个博主发送信息的时候，将发送内容推送至每一个用户的收件箱中。显然，这样会导致写操作十分频繁，如果博主有许多粉丝，写操作会更频繁。</p>
</li>
<li><p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240326203034238.png" alt="image-20240326203034238"></p>
</li>
<li><p>推拉结合的模式：也称作读写结合，兼具推和拉两种方式的优点。对于普通博主，粉丝少，那么就可以使用推模式，这样写操作就并不繁重；对于大博主，粉丝多，分为两种情况，活跃粉多，那么就可以使用拉模式；活跃粉少，那么就可以使用推模式。</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240326203318389.png" alt="image-20240326203318389"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>推送到粉丝收件箱：</strong></p>
<ul>
<li><p>需求：</p>
<ul>
<li>修改新增探店笔记的业务，在保存blog到数据库的同时，推送到粉丝的收件箱（收件箱使用sortedSet实现）</li>
<li>收件箱满足可以根据时间戳排序，必须用redis的数据结构实现。</li>
<li>查询收件箱数据的 时候，可以进行分页查询。</li>
</ul>
</li>
<li><p><strong>注意：Feed流中的数据会不断更新，所以数据的角标也在变化，因此不能采用传统的分页模式。</strong></p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240326203940897.png" alt="image-20240326203940897"></p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240326204001342.png" alt="image-20240326204001342"></p>
</li>
</ul>
</li>
<li><p>新增博文信息的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">saveBlog</span><span class="params">(Blog blog)</span> &#123;</span><br><span class="line">       <span class="comment">//获取登录用户</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       <span class="comment">//保存blog</span></span><br><span class="line">       blog.setUserId(userId);</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">save</span> <span class="operator">=</span> save(blog);</span><br><span class="line">       <span class="keyword">if</span> (save) &#123;</span><br><span class="line">           <span class="comment">//查询笔记作者的所有粉丝</span></span><br><span class="line">           List&lt;Follow&gt; follows = followService.query().eq(<span class="string">&quot;follow_user_id&quot;</span>, userId).list();</span><br><span class="line">           <span class="keyword">for</span> (Follow follow : follows) &#123;</span><br><span class="line">               <span class="comment">//获取粉丝id</span></span><br><span class="line">               <span class="type">Long</span> <span class="variable">followUserId</span> <span class="operator">=</span> follow.getUserId();</span><br><span class="line">               <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.FEED_KEY + followUserId;</span><br><span class="line">               <span class="comment">//推送</span></span><br><span class="line">               stringRedisTemplate.opsForZSet().add(key, blog.getId().toString(), System.currentTimeMillis());</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//推送笔记的id给所有粉丝</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//返回blog id</span></span><br><span class="line">       <span class="keyword">return</span> Result.ok(blog.getId());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>滚动分页的实现：<strong>简单来说，每次查询，我们都记住上一次查询的score的最小值，然后从小于最小值的第一个值进行查询</strong>，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.FEED_KEY + userId;</span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet().reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2L</span>);</span><br></pre></td></tr></table></figure>

<p>对应的redis指令是<code>ZrevrangeByScore 【key]】【上次查到的score最小值】【score的最小值】 withscores Limit 【偏移量，这里为1】，【count，页面大小】</code>。</p>
<p>翻译一下就是：以上次查询的最小值作为本次查询range的max，min为0，limit指定从上次查询的最小值的下一个元素（为0的话是查询&lt;&#x3D;最大值的的元素，会造成重复，所以这里应该为1，查询&lt;&#x3D;最大值的最近的元素）进行查询（根据偏移量来的），总共查询count个元素。</p>
<p>这里计算最小时间minTime和偏移量offset的代码也很巧妙：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ofCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        List&lt;String&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">        <span class="comment">//3. 解析收件箱：blogId ,score ,minTime(时间戳)</span></span><br><span class="line">        <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; typedTuple : typedTuples) &#123;</span><br><span class="line">            ids.add(typedTuple.getValue());</span><br><span class="line">            <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> typedTuple.getScore().longValue();</span><br><span class="line">            <span class="keyword">if</span> (time == minTime) &#123;</span><br><span class="line">                ofCount ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ofCount = <span class="number">1</span>;</span><br><span class="line">                minTime = time;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>概括一下就是，ofCount是用来计算score值等于最小时间的元素个数，后续作为offset封装到对象中，time在遍历过程中不断进行更新，遍历完就是取得了最小值，把它付给minTime，封装到对象中去。</strong></p>
<p>在查询后，又会将本次查询的最小值和偏移量封装到ScrollResult对象中，供下一次查询使用。</p>
<p>总体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">queryBlogOfFollow</span><span class="params">(Long max, Integer offset)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 获取当前登录用户</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">//2. 获取收件箱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> RedisConstants.FEED_KEY + userId;</span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; typedTuples = stringRedisTemplate.opsForZSet().reverseRangeByScoreWithScores(key, <span class="number">0</span>, max, offset, <span class="number">2L</span>);</span><br><span class="line">        <span class="comment">// 非空判断</span></span><br><span class="line">        <span class="keyword">if</span> (typedTuples.isEmpty() || typedTuples == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">minTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ofCount</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        List&lt;String&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(typedTuples.size());</span><br><span class="line">        <span class="comment">//3. 解析收件箱：blogId ,score ,minTime(时间戳)</span></span><br><span class="line">        <span class="keyword">for</span> (ZSetOperations.TypedTuple&lt;String&gt; typedTuple : typedTuples) &#123;</span><br><span class="line">            ids.add(typedTuple.getValue());</span><br><span class="line">            <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> typedTuple.getScore().longValue();</span><br><span class="line">            <span class="keyword">if</span> (time == minTime) &#123;</span><br><span class="line">                ofCount ++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ofCount = <span class="number">1</span>;</span><br><span class="line">                minTime = time;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">idStr</span> <span class="operator">=</span> StrUtil.join(<span class="string">&quot;,&quot;</span>, ids);</span><br><span class="line">        <span class="comment">//4. 根据id查询blog</span></span><br><span class="line">        List&lt;Blog&gt; blogs = blogService.query().in(<span class="string">&quot;id&quot;</span>, ids).last(<span class="string">&quot;order By field (id,&quot;</span> + idStr + <span class="string">&quot;)&quot;</span>).list();</span><br><span class="line">        <span class="comment">//4.1 查询blog用户，blog是否被点赞过</span></span><br><span class="line">        <span class="keyword">for</span> (Blog blog : blogs) &#123;</span><br><span class="line">            queryBlogUser(blog);</span><br><span class="line">            isBlogLiked(blog);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//封装并返回</span></span><br><span class="line">        <span class="type">ScrollResult</span> <span class="variable">scrollResult</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScrollResult</span>();</span><br><span class="line">        scrollResult.setList(blogs);</span><br><span class="line">        scrollResult.setMinTime(minTime);</span><br><span class="line">        scrollResult.setOffset(ofCount);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(scrollResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（7）优惠券秒杀"><a href="#（7）优惠券秒杀" class="headerlink" title="（7）优惠券秒杀"></a>（7）优惠券秒杀</h4><ul>
<li><p><strong>全局ID生成器</strong>：是一种在分布式系统下用来生成全局唯一id的工具，满足以下特性</p>
<ul>
<li><strong>唯一性</strong></li>
<li>高可用</li>
<li>高性能</li>
<li><strong>递增性</strong></li>
<li><strong>安全性</strong></li>
</ul>
</li>
<li><p>我们生成的ID由以下部分组成，订单ID就使用了其生成的ID。</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240329215303515.png" alt="image-20240329215303515"></p>
</li>
<li><p>具体的工具类代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prefix是业务的前缀，我们可以为不同的业务使用不同的全局ID</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span>&#123;</span><br><span class="line">        <span class="comment">//1. 生成时间戳（31位）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timeStamp</span> <span class="operator">=</span> LocalDateTime.now().toEpochSecond(ZoneOffset.UTC) - BEGIN_TIMESTAMP;</span><br><span class="line">        <span class="comment">//2. 生成序列号</span></span><br><span class="line">        <span class="comment">//2.1 获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">//2.2 自增长（添加了date是为了防止key自增到上限，并且方便统计）</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line">        <span class="comment">//3. 拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> (timeStamp &lt;&lt; COUNT_BITS) | count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意拼接这一步，<code>timeStamp &lt;&lt;  32</code>是先让时间戳左移32位，然后与序列号进行或运算</strong></p>
</li>
<li><p><strong>乐观锁解决超卖问题</strong></p>
<ul>
<li><p>超卖问题产生的原因：线程1查询库存，发现余额为1并且大于0，可以进行扣减，但是在线程1进行扣减库存操作之前，有一个线程2，它也查询库存，发现为1(因为线程1还没开始扣减)，于是它也进行扣减，这就导致了1个库存却被两个线程消费了，这就是超卖问题。</p>
</li>
<li><p><strong>乐观锁&amp;悲观锁</strong>：</p>
<ul>
<li>悲观锁认为线程安全问题一定会发生，因此在<strong>操作数据之前都要先获取锁</strong>，确保线程串行执行。（例如Synchronize、Lock都属于悲观锁）；</li>
<li>乐观锁则认为，线程安全问题不一定会发生，因此不进行加锁，只是<strong>在数据进行更新的时候去判断有没有其他线程对数据做了修改</strong>。如果没有修改，则认为是安全的，自己可以更新数据；如果已经被其他线程修改，说明发生了安全问题，此时可以重试或者异常。</li>
</ul>
</li>
<li><p>悲观锁实现比较简单，操作前获取锁，操作结束后才释放锁，让多个线程串行执行，但是你让并发线程串行执行，效率会十分低下。</p>
</li>
<li><p><strong>乐观锁设计：</strong></p>
<ul>
<li><p>第一种设计：<strong>添加版本号version</strong>，在扣减操作前会读取库存stack和版本号version，在进行扣减时，要检查version的值是不是最开始查到的值，如果是的话，才进行stack的扣减，并且让version自增；如果version与最开始查到的值不同，说明有其他线程修改过库存了，此时应该进行重试操作。</p>
<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240330150853650.png" alt="image-20240330150853650" style="zoom: 50%;" />
</li>
<li><p>第二种设计：<strong>CAS法</strong>，这里我们直接对比库存值，在进行扣减操作前会查询库存stack值，在进行扣减操作时，检查statck值（<strong>内存中的值V</strong>）是否与最开始读到的值（<strong>预期原始值A</strong>）相同，如果相同则可以进行扣减，反之，不同的话说明有其他线程更改过库存了，此时应该进行重试工作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">什么是CAS机制（compare and swap）</span><br><span class="line">CAS算法的作用：解决多线程条件下使用锁造成性能损耗问题的算法，保证了原子性，这个原子操作是由CPU来完成的</span><br><span class="line">CAS的原理：CAS算法有三个操作数，通过内存中的值（V）、预期原始值（A)、修改后的新值。</span><br><span class="line">（1）如果内存中的值和预期原始值相等， 就将修改后的新值保存到内存中。</span><br><span class="line">（2）如果内存中的值和预期原始值不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作，直到重试成功。</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建订单功能采用CAS法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)<span class="comment">//set stock = stock -1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>,voucherId).eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock()) <span class="comment">//where id = ? and stock =?</span></span><br><span class="line">                .update();</span><br></pre></td></tr></table></figure>

<p>上面代码的意思就是，在执行update的时候，再次检查stock值和当前获取到的stack值是否相同。<strong>但是这样修改后，我们发现成功率很低，在开启200个线程执行的情况下，100张只卖出去了23张。</strong>原因就在于，在并发环境下，stock值前后匹配的成功率很小，这导致大量的线程购买失败了。</p>
<p>因此对上面的代码继续修改，在扣减前查询stack值是否大于0，如果大于0，当前线程就可以进行扣减库存的操作了，如果等于0，说明有其他线程已经把库存扣完了，于是返回false表示库存扣减失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.扣减库存</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">                .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)</span><br><span class="line">                .update();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>一人一单问题</strong></p>
<ul>
<li><p>需要修改业务逻辑，一名用户只能购买一张优惠券，防止黄牛刷券。</p>
</li>
<li><p>具体业务流程如下：</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240330154534430.png" alt="image-20240330154534430"></p>
</li>
<li><p>于是修改代码如下：</p>
<ul>
<li><p>&#96;&#96;&#96;java<br>&#x2F;&#x2F;查询订单<br>    int count &#x3D; query().eq(“user_id”, userId).eq(“voucher_id”, voucherId).count();<br>    if (count &gt; 0) {<br>        return Result.fail(“不可重复下单！”);<br>    }<br>    &#x2F;&#x2F; 5.扣减库存<br>    boolean success &#x3D; seckillVoucherService.update()<br>            .setSql(“stock &#x3D; stock - 1”)<br>            .eq(“voucher_id”, voucherId).gt(“stock”, 0)<br>            .update();<br>    if (!success) {<br>        return Result.fail(“优惠券库存不足！”);<br>    }<br>    &#x2F;&#x2F; 6.创建订单<br>。。。。。。。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">**问题1**但是我们在测试的时候，发现问题并没有解决，原因就在于，在高并发环境下，多个线程查询该userID下的订单数count，都会得到0，从而都进行库存的扣减。导致没有实现一人一单。</span><br><span class="line">  </span><br><span class="line">那么自然考虑要加锁了，但是这里并不能用乐观锁方案，因为我们这里是新增数据操作，不是更新操作，数据一开始是不存在的。所以这里要使用悲观锁。</span><br><span class="line">  </span><br><span class="line">那么这里将查询订单到创建订单这个过程为一个方法，给这个方法加锁。</span><br><span class="line">  </span><br><span class="line">```java</span><br><span class="line">    @Transactional</span><br><span class="line">    public synchronized Result createVoucherOrder(Long voucherId) &#123;</span><br><span class="line">        // 一人一单</span><br><span class="line">        Long userId = UserHolder.getUser().getId();</span><br><span class="line">        //synchronized (userId.toString().intern()) &#123;</span><br><span class="line">        //查询订单</span><br><span class="line">        int count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();</span><br><span class="line">        if (count &gt; 0) &#123;</span><br><span class="line">            return Result.fail(&quot;不可重复下单！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 5.扣减库存</span><br><span class="line">        boolean success = seckillVoucherService.update()</span><br><span class="line">                .setSql(&quot;stock = stock - 1&quot;)</span><br><span class="line">                .eq(&quot;voucher_id&quot;, voucherId).gt(&quot;stock&quot;, 0)</span><br><span class="line">                .update();</span><br><span class="line">        if (!success) &#123;</span><br><span class="line">            return Result.fail(&quot;优惠券库存不足！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 6.创建订单</span><br><span class="line">        long orderId = redisIdWorker.nextId(&quot;order&quot;);</span><br><span class="line">        VoucherOrder voucherOrder = new VoucherOrder();</span><br><span class="line">        //6.1订单id</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        //6.2用户id</span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        //6.3优惠券id</span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        //7.保存订单</span><br><span class="line">        save(voucherOrder);</span><br><span class="line">        // 8.返回订单id</span><br><span class="line">        return Result.ok(orderId);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题二，缩小锁范围：</strong>但是在方法上使用synchronized锁的是当前this对象，导致每个用户到这里都要获取这一把锁，让这个方法串行执行了，效率会极低。我们只打算锁当前用户，不让他多次创建订单就可以了，那么这里我们synchronized（user ID.toString()）就可以了。</p>
<p><strong>问题三，但是用了toString还是不好使，因为toString底层都是new了一个新的对象，所以锁无法起作用。</strong>于是我们再次修改为<code>synchronized(userID.toString().intern())</code>，intern会从字符串常量池中寻找值一样的引用并返回。</p>
<p><strong>问题四，但是，我们这里将锁定义在了方法内部，因此在锁释放之后，创建订单的事务才会提交。而在锁释放到事务提交这段时间内（这个时候，由于事务尚未提交，数据库还没更新，如果此时有另外的线程进入的话，依然查不到count，会继续进行订单创建，这是我们不能允许的），因此synchronize不能放在方法内。</strong>于是就将代码改造成了下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 查询优惠券</span></span><br><span class="line">        <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">beginTime</span> <span class="operator">=</span> seckillVoucher.getBeginTime();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> seckillVoucher.getEndTime();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LocalDateTime.now().isBefore(beginTime)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀活动尚未开始！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">        <span class="keyword">if</span> (LocalDateTime.now().isAfter(endTime)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀活动已经结束！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line">        <span class="keyword">if</span> (stock &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;优惠券已售空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意这里，这里是我们修改的地方</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">     *  <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;        </span><br><span class="line">     *     <span class="keyword">return</span> createVoucherOrder(voucherId);</span><br><span class="line">     *  &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题五，但是这里还存在一个事务的问题</strong>，这里return的实际上是this.createVoucherOrder()方法，而spring事务生效是因为spring对当前对象做了动态代理，用的是代理对象做事务处理，而这里用this，是一个非代理对象，显然事务是不会生效的。</p>
<p>解决方案就是，拿到当前对象的代理对象。确保事务生效。</p>
<p><strong>问题六，在分布式情况下，上面的一人一单解决方法不好使了。这里引出》》》》分布式锁！！</strong></p>
<p>问题的原因如下，分布式情况下，有多个jvm存在，不同的jvm有多个锁监视器，这会导致每个jvm都会成功一个。</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240330215139748.png" alt="image-20240330215139748"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>分布式锁：</strong></p>
<ul>
<li>分布式锁就是满足分布式系统或集群模式下多进程可见并且互斥的锁。</li>
<li>分布式锁应有如下功能特性：<strong>多进程可见、互斥、高可用、高性能、安全性</strong></li>
<li>分布式锁的实现：</li>
<li><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240330220500961.png" alt="image-20240330220500961"></li>
</ul>
</li>
<li><p><strong>Redis分布式锁误删问题：</strong></p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240331145142125.png" alt="image-20240331145142125"></p>
<p><strong>问题：</strong>线程1在获取到锁，在进行自己的业务逻辑的时候却发生了阻塞，阻塞时间甚至超过了我们预设的redis锁超时时间。这导致锁提前被释放掉了，这时线程2自然而然获得了锁，在它执行业务逻辑的时候，<strong>线程1的业务完成了，于是线程1二话不说，进行释放锁，</strong>于是线程2的锁也没了，线程3就能获取锁执行自己的业务了………</p>
<p><strong>解决方法：</strong>在释放锁的时候判断一下线程标识是否一致，如果一致，就释放锁，不一致就不释放。（很好判断，因为我们setNx的value就是线程id，但是在集群模式下，多个jvm会出现线程id的重复，因此我们存放的标识也要尽可能的唯一，这里采用UUID + 线程ID的方式。）</p>
</li>
<li><p><strong>分布式锁的原子性问题</strong>：</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240331152244051.png" alt="image-20240331152244051"></p>
<p>上面我们解决了分布式锁误删问题，但是在并发情况下还是会存在隐患。</p>
<p><strong>问题：</strong>线程1在获取锁执行完业务进行释放的时候，由于我们释放锁的过程分为两步（1）判断线程标识是否一致（2）delete KEY，<strong>而在完成第一步后释放锁之前，假设线程1阻塞了（很有可能发生，比如垃圾回收会阻塞所有线程），等到锁被超时释放掉的时候，</strong>线程2可以趁虚而入了，它可以获取锁并执行自己的业务，<strong>而在它执行业务的时候，线程1恢复了，由于线程1已经进行了一致性判断，因此线程1会直接把锁释放掉，</strong>加入此时又来一个线程3，它就又可以执行自己的业务了。</p>
<p><strong>解决方法：</strong>这里我们使用lua脚本来保证释放锁的原子性。具体如下所示：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取锁中的线程标识</span></span><br><span class="line"><span class="keyword">local</span> id = redis.call(<span class="string">&#x27;get&#x27;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 判断是否一致</span></span><br><span class="line"><span class="keyword">if</span> (ARGV[<span class="number">1</span>] == id)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这里，为了避免每次释放锁的时候都要用IO流读脚本，这里采用静态代码块的方式，直接预加载我们的脚本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了避免每次释放锁都要重新加载脚本浪费性能，所以我们选择使用静态代码块进行初始化加载</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;unlock.lua&quot;</span>));</span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，在类初始化后，我们的脚本也完成了预加载。</p>
</li>
<li><p><strong>分布式锁工具类SimpleRedisLock</strong></p>
<p>在解决了锁误删问题以及原子性问题后，我们的工具类如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">//获取当前线程标识</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX +Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">//获取锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(isSuccess);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">// 调用lua脚本, 参数列表： lua脚本，key,args</span></span><br><span class="line">        stringRedisTemplate.execute(UNLOCK_SCRIPT, Collections.singletonList(KEY_PREFIX + <span class="built_in">this</span>.name),ID_PREFIX +Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>Redis分布式锁优化</strong></p>
<ul>
<li>基于setnx实现的分布式锁存在下面的问题<strong>（引出Redission）</strong>：<ul>
<li><strong>不可重入：</strong>同一个线程无法多次获取同一把锁。</li>
<li><strong>不可重试</strong>： 获取锁只尝试1次就返回了，没有重试机制。</li>
<li><strong>超时释放</strong>：锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致所释放，存在安全隐患。</li>
<li><strong>主从一致性：</strong>如果redis提供了主从集群，主从同步存在延迟，当主宕机时，如果从同步主中锁数据，则会出现锁实现。</li>
</ul>
</li>
<li><strong>Redission：</strong>redission是一个在redis基础上实现的java驻内存数据网格。它<strong>不仅提供了一系列的分布式地常用Java对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</strong>（redis下各种分布式工具集合）</li>
</ul>
</li>
<li><p><strong>Redission入门：</strong></p>
<ul>
<li><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240401141124091.png" alt="image-20240401141124091"><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240401142605710.png" alt="image-20240401142605710"><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240401143311866.png" alt="image-20240401143311866"><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240401150536638.png" alt="image-20240401150536638"></li>
<li><strong>Redission分布式锁原理：</strong><ul>
<li>可重入：利用Hash结构，记录线程id和重入次数</li>
<li>可重试：利用信号量和PubSub功能实现等待、唤醒、获取锁失败的重试机制</li>
<li>超时续约：利用watchDog，每隔一段时间（releaseTime &#x2F; 3），重置超时时间</li>
</ul>
</li>
<li><strong>Redission分布式锁主从一致性问题（联锁MultiLock）：</strong><ul>
<li>一般redis集群会设置主从模式，主节点用来写，从节点用来读，同时设置主从同步机制保证数据的一致性。但是如果我们从主节点获取锁，但是在主从同步过程中主节点宕机，这就会导致新的主节点没有锁的内容，产生并发安全问题。</li>
<li>Redission的解决方法是，不区分主从节点，所有节点同一级别，互不联系。在获取锁的时候，从每个redis节点获取锁，并且，只有当所有节点都能获取锁的时候该线程才能获取锁，这样就解决了分布式锁主从一致性问题。<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240401153807053.png" alt="image-20240401153807053"></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>总结：</strong></p>
<ul>
<li>（1）不可重入Redis分布式锁:<ul>
<li>原理：利用setNx的互斥性；利用ex避免死锁；释放锁时判断线程标识。</li>
<li>缺陷：不可重入、无法重试、锁超时失效。</li>
</ul>
</li>
<li>（2）可重入的Redis分布式锁：<ul>
<li>原理：利用hash结构，记录线程标识可重入次数；利用watchDog延续锁时间；利用信号量控制锁充实等待</li>
<li>缺陷：redis宕机引起锁失效问题</li>
</ul>
</li>
<li>（3）Redission的multilock:<ul>
<li>原理：多个独立的redis节点，必须在所有节点都获取重入锁，才算获取锁成功</li>
<li>缺陷：运维成本高、实现复杂</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>异步秒杀思路</strong></p>
<ul>
<li><p>在我们使用了分布式锁改造后的优惠券秒杀过程可以概括为如下几步：</p>
<ul>
<li>根据传入的voucher ID查询优惠券信息（<strong>访问数据库</strong>）；</li>
<li>判断秒杀是否开始或者已经结束（访问优惠券属性）</li>
<li>判断库存是否充足（访问优惠券属性）</li>
<li>获取当前用户id，查询当前用户是否已经购买过该优惠券（<strong>访问数据库</strong>）</li>
<li>如果符合一人一单，那么进行库存扣减（<strong>访问数据库</strong>）</li>
<li>创建订单信息并持久化（<strong>访问数据库</strong>）</li>
</ul>
</li>
<li><p><strong>该过程涉及4次数据库访问，串行执行的时候，会相当消耗时间，从而造成效率的降低，因此需要对整个流程进行异步化改造。</strong></p>
</li>
<li><p>这里，将判断秒杀库存和校验一人一单的功能交给redis来做，开启新的线程来完成那些需要访问数据库的操作。redis和tomcat之间通过一个消息队列来进行消息传递，当库存充足并且通过一人一单的校验后，redis向消息队列中发布消息，包含用户id，优惠券id，订单id；tomcat在接收到消息队列中的信息后，访问数据库，完成订单的创建。</p>
</li>
<li><p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240402140309308.png" alt="image-20240402140309308"></p>
</li>
<li><p><strong>缓存设计：</strong>对于判断秒杀库存的缓存设计，直接使用string结构就可以；而对于一人一单的校验，这里我们使用set结构来保存。1是因为同一张id的优惠券可以被多个用户购买，2是这些value不能有重复的，因此选用set结构正合适。</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240402141239535.png" alt="image-20240402141239535"></p>
</li>
<li><p>使用lua脚本来保证我们使用缓存进行库存判断和一人一单校验时的原子性：</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240402141618424.png" alt="image-20240402141618424"></p>
</li>
<li><p>整个工作流程如下：</p>
<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240402141928196.png" alt="image-20240402141928196" style="zoom:67%;" />
</li>
<li><p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">       <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//1. 执行lua脚本</span></span><br><span class="line">       <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> stringRedisTemplate.execute(</span><br><span class="line">               SECKILL_SCRIPT,</span><br><span class="line">               Collections.emptyList(),</span><br><span class="line">               voucherId.toString(), userId.toString(), String.valueOf(orderId));</span><br><span class="line">       <span class="comment">//2.判断结果，</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> result.intValue();</span><br><span class="line">       <span class="keyword">if</span> (r != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//2.1 不为0，代表没有</span></span><br><span class="line">           <span class="keyword">return</span> Result.fail(r == <span class="number">1</span> ? <span class="string">&quot;库存不足！&quot;</span> : <span class="string">&quot;不能重复下单！&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="comment">// 生成订单id</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    <span class="comment">// 添加阻塞队列</span></span><br><span class="line">    .......</span><br><span class="line">    <span class="comment">//3.返回订单id</span></span><br><span class="line">       <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用阻塞队列的方式完成异步下单 有一个很重要的缺点，那就是<strong>阻塞队列使用的是jvm内存，在高并发情况下会有无数的对象放在阻塞队列中，这可能会导致内存的溢出；同时，由于内容都是存在于内存中，如果发生宕机，内存中的数据发生丢失，会出现数据的安全问题</strong>（引出消息队列）。</p>
</li>
<li><p>基于PubSub的消息队列的优缺点：</p>
<ul>
<li>优点：采用发布订阅模型，支持多生产，多消费</li>
<li>缺点：不支持持久化；无法避免消息丢失；消息堆积有上限，超出时数据丢失</li>
</ul>
</li>
<li><p><strong>基于Stream的消息队列–单消费模式：</strong></p>
<ul>
<li>stream是redis5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列</li>
<li>stream中的消息读完不会删除。</li>
<li><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240403140103440.png" alt="image-20240403140103440"></li>
<li><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240403140208717.png" alt="image-20240403140208717"></li>
<li><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240403140306245.png" alt="image-20240403140306245"></li>
<li><strong>阻塞方式的一个bug：</strong>当我们指定起始id为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过1条以上的消息到达队列，则下次获取时也只能读取到最新的一条，会出现漏读消息的问题。</li>
<li><strong>总结，Stream类型的消息队列的xRead命令特点如下：</strong><ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>基于Stream的消费队列–消费者组</strong></p>
<ul>
<li><strong>消费者组：</strong>将多个消费者划分到一个组中，监听同一个队列。具备以下特点：<ul>
<li><strong>消息分流：</strong>队列中的消息会分流给组内的不同消费者，而不是重复的消费，从而加快消息处理的速度</li>
<li><strong>消息标识：</strong>消费者组会维护一个标识，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标识之后读取消息。确保每一个消息都会被消费</li>
<li><strong>消息确认：</strong>消费者获取消息后，消息处于pending状态，并存入一个pending-List。当处理完成后需要XACK来确认消息，标记消息已处理，才会从pendingList中移除。</li>
</ul>
</li>
<li><strong>Stream类型消息队列的XREADGROUP命令特点：</strong><ul>
<li>消息可回溯</li>
<li>可以多消费者争抢消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消息漏读的风险</li>
<li>有消息确认机制，保证消息至少被消费一次</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>基于Stream消息队列实现</strong></p>
<ul>
<li><p>流程变更如下：</p>
<ul>
<li>创建一个stream类型的消息队列，命名为stream.orders</li>
<li>修改之前的秒杀下单lua脚本，在认定有抢购资格后，直接向stream.order中添加消息，内容包含voucherID、user ID、orderID</li>
<li>项目启动时，开启一个线程任务，尝试获取stream.order中的信息，完成下单</li>
</ul>
</li>
<li><p>修改后的Lua脚本：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--参数列表</span></span><br><span class="line"><span class="comment">--优惠券id</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>]</span><br><span class="line"><span class="comment">--用户id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>]</span><br><span class="line"><span class="comment">--订单id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">--数据key</span></span><br><span class="line"><span class="comment">--库存key</span></span><br><span class="line"><span class="keyword">local</span> stockKey = <span class="string">&#x27;seckill:stock:&#x27;</span> .. voucherId</span><br><span class="line"><span class="comment">--订单key(这里的orderKey代表的是：该优惠券下的所有订单，它是一个集合的key)</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId</span><br><span class="line"></span><br><span class="line"><span class="comment">--3.脚本业务</span></span><br><span class="line"><span class="comment">--3.1判断库存是否充足 get stockkey</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;get&#x27;</span>,stockKey)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">--3.2 库存不足，返回1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--判断用户是否下单 sismember orderKey userId</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">--3.3 存在，说明是重复下单，返回2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--3.4 扣减库存，</span></span><br><span class="line">redis.call(<span class="string">&#x27;incrby&#x27;</span>,stockKey,<span class="number">-1</span>)</span><br><span class="line"><span class="comment">--3.5 下单，保存用户(将用户id加入到以orderKey 为key的集合中)</span></span><br><span class="line">redis.call(<span class="string">&#x27;sadd&#x27;</span>,orderKey,userId)</span><br><span class="line"><span class="comment">--3.6 发送消息到消息队列中，XADD stream.orders * k1 v1 k2 v2....</span></span><br><span class="line">redis.call(<span class="string">&quot;XADD&quot;</span>,<span class="string">&quot;stream.orders&quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;userId&quot;</span>,userId,<span class="string">&quot;voucherId&quot;</span>,voucherId,<span class="string">&quot;id&quot;</span>,orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改后的，使用stream的订单处理线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;stream.orders&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//1.获取消息队列中的订单信息</span></span><br><span class="line">                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = stringRedisTemplate.opsForStream().read(</span><br><span class="line">                            Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                            StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofSeconds(<span class="number">2</span>)),</span><br><span class="line">                            StreamOffset.create(queueName, ReadOffset.lastConsumed())</span><br><span class="line">                    );</span><br><span class="line">                    <span class="comment">//2.判断消息获取是否成功</span></span><br><span class="line">                    <span class="keyword">if</span> (list == <span class="literal">null</span> || list.isEmpty()) &#123;</span><br><span class="line">                        <span class="comment">//2.1 如果消息获取失败，说明没有消息，继续进行下一次循环</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//2.2 如果消息获取成功，对消息进行处理</span></span><br><span class="line">                    <span class="comment">// 解析list中的订单信息</span></span><br><span class="line">                    MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                    Map&lt;Object, Object&gt; map = record.getValue();</span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(map, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                    <span class="comment">//对消息进行处理,即创建订单</span></span><br><span class="line">                    handleVoucherOrder(voucherOrder);</span><br><span class="line">                    <span class="comment">//3. ACK确认</span></span><br><span class="line">                    stringRedisTemplate.opsForStream().acknowledge(queueName, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;订单消息处理异常！&quot;</span>, e);</span><br><span class="line">                    <span class="comment">//4.消息处理异常，说明存在被读取但未被ack的订单消息</span></span><br><span class="line">                    handlePendingList();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="面试相关问题"><a href="#面试相关问题" class="headerlink" title="面试相关问题"></a>面试相关问题</h1><h2 id="1-项目里为什么要用消息队列："><a href="#1-项目里为什么要用消息队列：" class="headerlink" title="1. 项目里为什么要用消息队列："></a>1. 项目里为什么要用消息队列：</h2><h2 id="2-请求很多，消息堆积处理不过来了如何应对"><a href="#2-请求很多，消息堆积处理不过来了如何应对" class="headerlink" title="2. 请求很多，消息堆积处理不过来了如何应对"></a>2. 请求很多，消息堆积处理不过来了如何应对</h2><h2 id="3-用户在消息堆积时以为卡了，多次请求怎么处理"><a href="#3-用户在消息堆积时以为卡了，多次请求怎么处理" class="headerlink" title="3. 用户在消息堆积时以为卡了，多次请求怎么处理"></a>3. 用户在消息堆积时以为卡了，多次请求怎么处理</h2><h2 id="4-项目都有哪些表"><a href="#4-项目都有哪些表" class="headerlink" title="4. 项目都有哪些表"></a>4. 项目都有哪些表</h2><h2 id="5-超卖问题怎么解决？"><a href="#5-超卖问题怎么解决？" class="headerlink" title="5. 超卖问题怎么解决？"></a>5. 超卖问题怎么解决？</h2><h2 id="5-秒杀场景下扣减库存太慢了怎么解决"><a href="#5-秒杀场景下扣减库存太慢了怎么解决" class="headerlink" title="5. 秒杀场景下扣减库存太慢了怎么解决"></a>5. 秒杀场景下扣减库存太慢了怎么解决</h2><h2 id="7-Redis大key怎么解决？"><a href="#7-Redis大key怎么解决？" class="headerlink" title="7. Redis大key怎么解决？"></a>7. Redis大key怎么解决？</h2><h2 id="8-什么是热Key"><a href="#8-什么是热Key" class="headerlink" title="8. 什么是热Key"></a>8. 什么是热Key</h2><h2 id="9-如何解决热key问题"><a href="#9-如何解决热key问题" class="headerlink" title="9. 如何解决热key问题"></a>9. 如何解决热key问题</h2><h2 id="10-短信登录的短信怎么发送的"><a href="#10-短信登录的短信怎么发送的" class="headerlink" title="10.  短信登录的短信怎么发送的"></a>10.  短信登录的短信怎么发送的</h2><h2 id="11-项目的拦截器详细讲讲"><a href="#11-项目的拦截器详细讲讲" class="headerlink" title="11. 项目的拦截器详细讲讲"></a>11. 项目的拦截器详细讲讲</h2><h2 id="12-怎么保存验证码"><a href="#12-怎么保存验证码" class="headerlink" title="12. 怎么保存验证码"></a>12. 怎么保存验证码</h2><h2 id="13-项目里存在redis里的key的格式，存的什么"><a href="#13-项目里存在redis里的key的格式，存的什么" class="headerlink" title="13.项目里存在redis里的key的格式，存的什么"></a>13.项目里存在redis里的key的格式，存的什么</h2><h2 id="14-如何标识用户"><a href="#14-如何标识用户" class="headerlink" title="14. 如何标识用户"></a>14. 如何标识用户</h2><h2 id="15-项目的权限刷新什么意思"><a href="#15-项目的权限刷新什么意思" class="headerlink" title="15.项目的权限刷新什么意思"></a>15.项目的权限刷新什么意思</h2><h2 id="16-旁路缓存机制具体解决的什么场景"><a href="#16-旁路缓存机制具体解决的什么场景" class="headerlink" title="16. 旁路缓存机制具体解决的什么场景"></a>16. 旁路缓存机制具体解决的什么场景</h2><h2 id="17-更新缓存失败了怎么办"><a href="#17-更新缓存失败了怎么办" class="headerlink" title="17 更新缓存失败了怎么办"></a>17 更新缓存失败了怎么办</h2><h2 id="重试的时候，缓存中的错数据被访问多次了，怎么解决"><a href="#重试的时候，缓存中的错数据被访问多次了，怎么解决" class="headerlink" title="重试的时候，缓存中的错数据被访问多次了，怎么解决"></a>重试的时候，缓存中的错数据被访问多次了，怎么解决</h2><h2 id="项目为什么要加个消息队列"><a href="#项目为什么要加个消息队列" class="headerlink" title="项目为什么要加个消息队列"></a>项目为什么要加个消息队列</h2><h2 id="抢优惠券没有及时处理怎么办"><a href="#抢优惠券没有及时处理怎么办" class="headerlink" title="抢优惠券没有及时处理怎么办"></a>抢优惠券没有及时处理怎么办</h2><h2 id="抢优惠券处理完了如何通知用户"><a href="#抢优惠券处理完了如何通知用户" class="headerlink" title="抢优惠券处理完了如何通知用户"></a>抢优惠券处理完了如何通知用户</h2><h2 id="Redis的Zset"><a href="#Redis的Zset" class="headerlink" title="Redis的Zset"></a>Redis的Zset</h2><h2 id="Zset的范围查询的时间复杂度是多少"><a href="#Zset的范围查询的时间复杂度是多少" class="headerlink" title="Zset的范围查询的时间复杂度是多少"></a>Zset的范围查询的时间复杂度是多少</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/SHaDiaoYU/2024/02/27/%E5%85%AB%E8%82%A1%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/test1/images/avatar.gif">
      <meta itemprop="name" content="jiawei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕鱼罐头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/test1/2024/02/27/%E5%85%AB%E8%82%A1%E6%96%87/" class="post-title-link" itemprop="url">八股文</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-02-27 19:16:58" itemprop="dateCreated datePublished" datetime="2024-02-27T19:16:58+08:00">2024-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-09 15:51:36" itemprop="dateModified" datetime="2024-05-09T15:51:36+08:00">2024-05-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、java基础"><a href="#一、java基础" class="headerlink" title="一、java基础"></a>一、java基础</h1><h2 id="8种基本数据类型"><a href="#8种基本数据类型" class="headerlink" title="8种基本数据类型"></a>8种基本数据类型</h2><p>byte（8位，默认0B）、short（16位，默认0）、int（32位，默认0）、long（64位，默认0L）、float（32位，默认0.0f）、double（64位，默认0.0d）、char（16位，默认值\u0000）、boolean（jvm实现相关，一般情况下为1个字节，默认false）</p>
<h2 id="包装类型的常量池技术"><a href="#包装类型的常量池技术" class="headerlink" title="包装类型的常量池技术"></a><strong>包装类型的常量池技术</strong></h2><p>Byte、Short、Integer、Long这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据。Character 创建了数值在 [0,127] 范围的缓存数据，Boolean直接返回True或False。</p>
<p><strong>两种浮点类型的包装类Float、Double并没有实现包装类技术。</strong></p>
<p><strong>所有整型包装类对象之间值的比较，全部使用equals方法进行比较。</strong></p>
<p>我们以 <code>int与Integer</code> 作为例子，看下”&#x3D;&#x3D;”和”equal()”方法：</p>
<p>1）基本型和封装类型进行”&#x3D;&#x3D;”运算符的比较，封装类型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较。</p>
<p>2）两个Integer类型进行”&#x3D;&#x3D;”比较，如果其值在-128至127，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，后面会说。</p>
<p>3）两个封装类型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true。</p>
<p>4）基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。</p>
<h2 id="为什么要有包装类型？"><a href="#为什么要有包装类型？" class="headerlink" title="为什么要有包装类型？"></a>为什么要有包装类型？</h2><ul>
<li>Java是一种面向对象编程的语言，它要求所有的东西都是对象。然而，基本数据类型不是对象，它们是原始的数据类型，无法直接参与面向对象中的特性（比如继承、多态等）。因此引入了包装类型，使其能够像其它对象那样参与面向对象。</li>
<li><strong>泛型的支持</strong>，Java5引入了泛型，但是泛型要求类型参数必须是对象类型，不能是基本数据类型。因此，如果要在集合类中存储基本数据类型，就需要使用对应的包装类型。</li>
<li><strong>空值的支持</strong>，包装类型可以表示空值（null），而基本数据类型不行。</li>
<li>包装类型提供了一些额外的方法和功能，使得对基本数据类型的操作更加方便。</li>
</ul>
<h2 id="什么是自动拆装箱？原理？"><a href="#什么是自动拆装箱？原理？" class="headerlink" title="什么是自动拆装箱？原理？"></a><strong>什么是自动拆装箱？原理？</strong></h2><h2 id="遇到过自动拆箱引发的NPE（空指针）问题么？"><a href="#遇到过自动拆箱引发的NPE（空指针）问题么？" class="headerlink" title="遇到过自动拆箱引发的NPE（空指针）问题么？"></a>遇到过自动拆箱引发的NPE（空指针）问题么？</h2><ul>
<li>数据库的查询结果可能是null，因为自动拆箱，使用基本数据类型进行接受会有NPE风险。</li>
<li>在三目运算（b?x:y）中，当 x和y的类型不一致时，会发生自动拆箱，将x,y全部转换为基本类型，在自动拆箱的过程中有可能NPE。</li>
</ul>
<h2 id="String，StringBuffer和StringBuilder的区别是什么？String为什么时不可变的？"><a href="#String，StringBuffer和StringBuilder的区别是什么？String为什么时不可变的？" class="headerlink" title="String，StringBuffer和StringBuilder的区别是什么？String为什么时不可变的？"></a>String，StringBuffer和StringBuilder的区别是什么？String为什么时不可变的？</h2><ul>
<li><p>可变性：String是不可变的，StringBuffer和StringBuilder是可变的；</p>
</li>
<li><p>线程安全性：String和StringBuffer是线程安全的，可以被多个线程安全的使用，StringBuilder不是线程安全的</p>
</li>
<li><p>StringBuffer的性能相对较低，因为它的所有公共方法都是同步的，这意味着在多线程环境下会有性能开销。</p>
<p>StringBuilder的性能优于StringBuffer，但因为它的方法都不是同步的，因此在单线程环境下更有效。</p>
</li>
<li><p>String实现了serializable接口，可以被序列化。</p>
</li>
</ul>
<p>重载和重写的区别？**</p>
<ul>
<li><p>重载指的是在同一个类中，可以定义多个方法具有相同的名称但具有不同的参数列表（参数类型、参数个数、参数顺序）；</p>
<p>重写指的是子类重新定义（覆盖）了父类中具有相同名称、参数列表和返回类型的方法。</p>
</li>
<li><p>重载方法可以有不同的返回类型，但不能仅仅通过返回类型的不同来区分方法。</p>
</li>
<li><p>重写方法具有与被重写方法相同的方法签名，包括方法名、参数列表和返回类型。</p>
</li>
<li><p>重写方法不能降低访问权限，即子类中重写的方法的访问权限不能比父类中被重写的方法的访问权限更低。</p>
</li>
<li><p>重载是编译时多态，重写是运行时多态。</p>
</li>
<li><p>重写方法一定不能抛出新的检查异常，或者比被重写方法声明更加宽泛的检查型异常。</p>
</li>
</ul>
<p><strong>总结：方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。</strong></p>
<h2 id="“-x3D-x3D-”和“equals-”的区别"><a href="#“-x3D-x3D-”和“equals-”的区别" class="headerlink" title="“&#x3D;&#x3D;”和“equals ()”的区别"></a>“&#x3D;&#x3D;”和“equals ()”的区别</h2><ul>
<li><p>对于<code>==</code>，比较的是值是否相等</p>
<ul>
<li>如果作用于基本数据类型的变量，则直接比较存储的值是否相等</li>
<li>如果作用于引用类型的变量，则比较的是所指向的对象的地址是否相等</li>
</ul>
<p>（其实&#x3D;&#x3D;比较的不管是基本数据类型还是引用类型，比较的都是值，只是引用类型变量存储的是对象的地址。）</p>
</li>
<li><p>对于<code>equals()</code>方法，根据是否重写equals方法，分为两种情况：</p>
<ul>
<li><strong>类没有重写equals方法：</strong>和&#x3D;&#x3D;的效果一样，都是比较引用类型的变量所指向的对象的地址。</li>
<li><strong>类重写了equals方法：</strong>比较两个对象的属性是否相等，如果它们的属性相等，则返回true（即，认为这两个对象相等。）</li>
<li><strong>特别注意的是，equals()方法不能作用于基本数据类型的变量。</strong></li>
</ul>
</li>
</ul>
<h2 id="Java反射？反射有什么优缺点？你是怎么理解反射的（为什么框架需要反射？）"><a href="#Java反射？反射有什么优缺点？你是怎么理解反射的（为什么框架需要反射？）" class="headerlink" title="Java反射？反射有什么优缺点？你是怎么理解反射的（为什么框架需要反射？）"></a>Java反射？反射有什么优缺点？你是怎么理解反射的（为什么框架需要反射？）</h2><ul>
<li>反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意对象，都能调用它的任意一个方法。在Java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。这种动态获取的信息以及动态调用对象的方法的功能称为java的反射机制。</li>
<li>反射机制的优缺点：<ul>
<li>优点：能够运行时动态获取类的实例，提高灵活性和通用性；可以使用反射编写更加通用的代码，减少组件之间的耦合；反射是实现动态代理机制的基础。</li>
<li>缺点：使用反射基本是解释执行，对执行速度有影响。</li>
</ul>
</li>
<li>对于反射的理解（为什么框架需要反射）：<ul>
<li>通过反射，框架可以在不了解具体类结构的情况下，实现对用户代码的调用和管理，从而提高了框架的灵活性和可扩展性。</li>
<li>依赖注入：在依赖注入中，框架通常需要动态的创建和注入依赖对象，而这些对象的类型通常是在运行时才确定的。通过反射，框架可以实现自动化的依赖注入，无需显式地在代码中指定对象的类型。</li>
<li>AOP：框架通常使用动态代理和反射机制来实现AOP，以在运行时动态地植入切面逻辑。</li>
<li>框架通常需要处理大量的配置信息和元数据，以实现各种功能和行为。通过反射，框架可以动态地解析和处理配置文件和元数据，从而实现对各种不同情况的适应性。</li>
</ul>
</li>
</ul>
<h2 id="谈谈对Java注解的理解，解决了什么问题？"><a href="#谈谈对Java注解的理解，解决了什么问题？" class="headerlink" title="谈谈对Java注解的理解，解决了什么问题？"></a>谈谈对Java注解的理解，解决了什么问题？</h2><p>在写程序时，有时候想给一些特殊的地方加上标记，告诉编译器或者其他工具，这些地方有一些特殊的意义。Java注解就是一种在代码中添加特殊标记的方式，这些标记可以帮助编译器、工具或者其他程序理解你的代码，并可以触发一些额外的处理或行为。</p>
<ul>
<li>注解解决的问题：<ul>
<li>注解可以用于为代码提供更多的文档化信息，这样做可以增加代码的可读性和可维护性，使得代码更容易理解和使用。</li>
<li>注解可以用于在编译时对程序进行动态检查和验证，从而减少运行时错误。</li>
<li>注解可以用于驱动代码生成和自动化处理工具，从而减少重复性工作和提高开发效率（如通过编写自定义的注解，可以在编译时根据注解生成代码、配置文件或其他资源）</li>
<li>注解可以用于配置和扩展框架和库的行为，，使得它们更加灵活和可定制（如在类、方法或字段上添加注解配置框架的行为，以实现依赖注入，AOP等功能）</li>
</ul>
</li>
</ul>
<h2 id="Java泛型了解么？泛型的作用？什么是类型擦除？泛型有哪些限制？介绍一下常用的通配符？"><a href="#Java泛型了解么？泛型的作用？什么是类型擦除？泛型有哪些限制？介绍一下常用的通配符？" class="headerlink" title="Java泛型了解么？泛型的作用？什么是类型擦除？泛型有哪些限制？介绍一下常用的通配符？"></a>Java泛型了解么？泛型的作用？什么是类型擦除？泛型有哪些限制？介绍一下常用的通配符？</h2><ul>
<li>Java 泛型是一种在<strong>编译时</strong>进行类型检查和类型安全的机制，它允许程序员在编写代码时指定类、接口和方法可以支持任意类型（包括类、接口和原始类型）。Java 泛型提供了参数化类型的概念，使得代码可以更加通用和类型安全（可读性更好，更安全）。</li>
<li>Java 泛型的主要目的是<strong>在编译时捕获类型错误</strong>，并在编译时发现这些错误，从而避免在运行时抛出类型转换异常。它提供了编译时类型安全检查，使得代码更加健壮、可读性更高，并且减少了强制类型转换的需要。</li>
<li>Java 中的泛型是通过类型擦除实现的，这意味着在编译时会将泛型信息擦除掉，以确保与旧版 Java 代码的兼容性。这也导致了一些泛型相关的限制和局限性。（在运行时无法获取泛型类型的信息，在运行时，数组的元素类型必须是具体的非泛型类型）。</li>
<li>泛型的限制：<ul>
<li>类型擦除：这意味着在编译后，泛型信息会被擦除掉，因此在运行时无法获取泛型类型的具体信息，这限制了对泛型类型的操作和反射行为。</li>
<li>无法创建参数化类型的数组：例如<code>new ArrayList&lt;String&gt;[]  </code> 是非法的。这是因为在运行时无法获取泛型类型的信息。</li>
<li>在静态上下文（如静态方法或静态初始化块）中无法引用泛型类型的类型参数：因为类型参数是实例化时才确定的，而静态成员在类加载时就已经存在，此时无法确定类型参数的具体值。</li>
<li>不能使用基本类型作为类型参数。</li>
<li>无法实例化泛型类型的具体化对象。</li>
<li>无法创建泛型数组列表。</li>
<li>不能捕获泛型类型的异常：泛型类型不能用作catch块中的异常类型。</li>
<li>不能实例化泛型类型的数组。</li>
</ul>
</li>
</ul>
<ol start="12">
<li><h3 id="内部类了解么？匿名内部类了解么？"><a href="#内部类了解么？匿名内部类了解么？" class="headerlink" title="内部类了解么？匿名内部类了解么？"></a>内部类了解么？匿名内部类了解么？</h3><ul>
<li><p>内部类：如果A类需要直接访问B类中的成员，而B类又需要建立A类的对象，这时为了方便设计和访问，直接将A类定义在B类中就可以了。A类就称为内部类。</p>
</li>
<li><p>内部类可以直接访问外部类的成员。但是外部类访问内部类时，必须先创建内部类对象。</p>
</li>
<li><p>内部类定义在外部类的成员位置上，可以使用一些成员修饰符如private，static。不同的修饰有不同的情况：</p>
<ul>
<li>默认修饰符default：直接访问内部类格式：<code>外部类名.内部类名 = 外部类对象.内部类对象(Outer.Inner in = new Outer.Inner())</code>。但这种方式不常见，因为定义内部类就是为了封装。想要获取内部类对象通常都需要通过外部类的方法来获取。这样可以对内部类对象进行控制。</li>
<li>私有修饰符private：通常内部类被封装，都会被私有化，因为封装性不让其他程序直接访问。</li>
<li>静态修饰符static：如果内部类被静态修饰，相当于外部类，会出现访问局限性，内部类只能访问外部类中的静态成员。<strong>注意：如果内部类中定义了静态成员，那么该内部类必须是静态的。</strong></li>
</ul>
</li>
<li><p>匿名内部类是内部类的简化写法。一般只使用一次就可以使用这种形式。匿名内部类其实就是一个匿名子类对象。想要定义匿名内部类，前提是<strong>内部类必须继承一个父类或者实现一个接口。</strong></p>
<p>匿名内部类的格式：<code>new 父类名&amp;接口名&#123;定义子类成员或者覆盖父类方法&#125;.方法</code>。</p>
</li>
<li><p>匿名内部类的使用场景：当函数的参数是接口类型引用的时候，如果接口中的方法不超过3个。可以通过匿名内部类来完成参数的传递。（换句话说就是，创建匿名内部类时，该类中封装的方法不要太多，最好两个或者两个以内）</p>
</li>
</ul>
</li>
<li><h3 id="BIO，NIO，AIO有什么区别？"><a href="#BIO，NIO，AIO有什么区别？" class="headerlink" title="BIO，NIO，AIO有什么区别？"></a>BIO，NIO，AIO有什么区别？</h3><ul>
<li><p>BIO（Blocking I&#x2F;O）：<strong>同步阻塞</strong>I&#x2F;O模式，数据的读取和写入必须阻塞在同一个线程内等待其完成。</p>
<ul>
<li>传统BIO（一请求一应答）：</li>
</ul>
  <img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240228203224835.png" alt="image-20240228203224835" style="zoom: 67%;" />

<p>  要使该IO模型能够同时处理多个客户端请求，就必须使用多线程，也就是说它在接收到客户端连接请求后为每一个客户端创建一个新的线程进行链路处理，处理完成后，通过输出流返回应答给客户端，线程销毁。<strong>这就是一请求一应答</strong>。但是这个连接如果不做任何事情的话就会造成不必要的线程浪费，这种情况可以通过使用<strong>线程池</strong>技术改善。</p>
<ul>
<li><p>伪异步I&#x2F;O：引入了线程池来缓解资源浪费问题，但本质上还是传统BIO同步阻塞那一套。无法从根本上解决问题。</p>
<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240228203836711.png" alt="image-20240228203836711" style="zoom: 67%;" /></li>
</ul>
</li>
<li><p>NIO（New I&#x2F;O）：NIO是一种<strong>同步非阻塞</strong>的IO模型，NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I&#x2F;O操作方法。 </p>
<ul>
<li>NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。</li>
<li>阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。</li>
<li>对于低负载、低并发的应用程序，可以使用同步阻塞I&#x2F;O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。</li>
</ul>
</li>
<li><p>NIO与IO的区别（<strong>阻塞与非阻塞，三大组件</strong>）：</p>
<ul>
<li><p>NIO是非阻塞的，IO是阻塞的</p>
</li>
<li><p><strong>Buffer</strong>：IO面向IO流（Stream oriented），而NIO面向缓冲区（Buffer oriented）。在面向流的IO中，可以将数据直接写入或者将数据直接读到Stream对象中。虽然Stream也有Buffer开头的扩展类，但是只是流的包装类，还是从流读到缓冲区，而NIO是直接读到Buffer中进行操作。</p>
<p>在NIO中，所有数据都是用缓冲区处理的，在读取数据时，它直接读缓冲区中的；在写数据时，它从缓冲区中读。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</p>
</li>
<li><p><strong>Channel</strong>：NIO通过Channel（通道）进行读写，通道是双向的，可读也可写。而流的读写是单向的。通道只能和Buffer交互。因为Buffer，通道可以异步的读写。</p>
</li>
<li><p><strong>Selectors</strong>： NIO有选择器，而IO没有。选择器用于使用单个线程处理多个通道，因此，他需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。因此，为了提高效率使用选择器是有效的。</p>
<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240228210012986.png" alt="image-20240228210012986" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>AIO（Asynchronous I&#x2F;O）：AIO也就是NIO 2。在Java7中引入了NIO 2，它是<strong>异步非阻塞</strong>的。异步IO是基于时间和回调机制实现的。AIO是异步IO的缩写，虽然NIO在网络操作中，提供了非阻塞的方法，但是NIO的IO行为还是同步的。</p>
</li>
</ul>
</li>
</ol>
<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><h2 id="几种集合的数据结构："><a href="#几种集合的数据结构：" class="headerlink" title="几种集合的数据结构："></a>几种集合的数据结构：</h2><ul>
<li>HashMap：哈希表 + 链表 ，无序，允许键和值为null，线程不安全</li>
<li>LinkedHashMap： 哈希表 + 双向链表，保持插入顺序或访问顺序。</li>
<li>TreeMap： 基于红黑树实现的有序Map</li>
<li>Hashtable：基于哈希表实现的map，线程安全</li>
<li>concurrentHashMap：基于哈希表实现的线程安全的 Map，支持高并发操作。</li>
</ul>
<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><h2 id="volatile关键字："><a href="#volatile关键字：" class="headerlink" title="volatile关键字："></a>volatile关键字：</h2><p>volatile关键字保证了 <strong>可见性（一个线程对共享变量进行修改后，其他线程能立即看到这个修改）</strong> 和 <strong>有序性（程序执行的顺序与代码的顺序一致）</strong></p>
<p><strong>volatile如何保证可见性：</strong></p>
<ul>
<li>一个变量被声明为volatile时，<strong>线程在写入变量时</strong>， 不会立即把值缓存到寄存器或其他地方，而是<strong>会把值刷新回主内存。</strong></li>
<li>当其他线程<strong>读取到该共享变量</strong>，<strong>会从主存中获取最新值</strong>，而不是使用当前线程的本地内存中的值。</li>
</ul>
<p><strong>volatile如何保证有序性：</strong></p>
<ul>
<li><p>volatile通过<strong>限制指令重排序</strong>（编译器重排序 和 处理器重排序 这两种重排序）来保证有序性的。</p>
</li>
<li><p><strong>写操作</strong> 加的屏障是 阻止<strong>上方</strong>其它写操作越过屏障<strong>排到 volatile变量写之下</strong>；</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240507210723973.png" alt="image-20240507210723973"></p>
</li>
<li><p><strong>读操作</strong> 加的屏障是阻止 下方其它读操作越过屏障<strong>排到 volatile变量读之上</strong>；</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240507210744195.png" alt="image-20240507210744195"></p>
</li>
</ul>
<h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p><strong>（1）synchronized的三种用法：</strong></p>
<ul>
<li>修饰实例方法：这种方式相当于 synchronized（this对象），进入同步代码块之前需要获得 当前对象实例的锁；</li>
<li>修饰静态方法：这种用法会作用于类的所有对象实例，进入同步块之前要获得当前 class的锁；</li>
<li>修饰代码块： synchronized(类.class) 表示进⼊同步 代码前要获得 当前 class 的锁；</li>
</ul>
<p><strong>（2）synchronized 怎么保持可见性的：</strong></p>
<ul>
<li>线程枷锁前，清空工作内存中共享变量的值，从而从主存中读取最新的共享变量值；</li>
<li>线程加锁后，其他线程无法获取主存中的共享变量；</li>
<li>线程解锁前，会将最新的共享变量值刷新到主存中。</li>
</ul>
<p><strong>（3）synchronized 怎么保持有序性的：</strong></p>
<ul>
<li>synchronized同步的代码块，一次只能被一个线程拥有，所以synchronized保证<strong>同一时刻，代码是单线程执行的。</strong> <strong>因为as-if-serial语义的存在，单线程的程序能保证最终结果是有序的，但是不保证不 会指令重排。</strong></li>
</ul>
<p><strong>（4）synchronized怎么实现可重入的：</strong></p>
<ul>
<li>synchronized锁对象的时候有一个<strong>锁计数器，它会记录下线程获取锁的次数，在执行完代码块后，计数器 -1，直到计数器清零，就释放锁了。</strong></li>
</ul>
<h1 id="二、Spring框架"><a href="#二、Spring框架" class="headerlink" title="二、Spring框架"></a>二、Spring框架</h1><h2 id="1-Bean生命周期"><a href="#1-Bean生命周期" class="headerlink" title="1.Bean生命周期"></a>1.Bean生命周期</h2><p>大致可分为四个阶段： <strong>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</strong></p>
<ul>
<li><strong>（实例化）</strong>首先，在Bean容器中找到SpringBean的定义BeanDefination。</li>
<li><strong>（实例化）</strong>Bean容器根据Java Reflection API创建一个Bean的实例（调用构造方法实例化bean）。</li>
<li><strong>（属性赋值）</strong>设置属性（为Bean设置相关属性和依赖、或者说依赖注入）</li>
<li><strong>（初始化）</strong>初始化Initialization：<ul>
<li>检查Aware的相关接口并设置相关依赖。如果实现了BeanAware接口，调用setBeanName()方法，传入Bean的名字。</li>
<li>BeanPostProcessor前置处理；如果实现了 BeanFactoryAware 接⼝，调⽤ setBeanFactory() ⽅法，传⼊ BeanFactory 对 象的实例。 类似，如果实现了其他 *.Aware 接⼝，就调⽤相应的⽅法。</li>
<li>检查是否实现InitializationBean接口；如果 Bean 实现了 InitializingBean 接⼝，执⾏ afterPropertiesSet() ⽅法。</li>
<li>检查是否配置自定义的init-method；如果 Bean 在配置⽂件中的定义包含 init-method 属性，执⾏指定的⽅法。</li>
<li>BeanPostProcessor后置处理</li>
</ul>
</li>
<li>使用中</li>
<li><strong>（销毁）</strong>销毁<ul>
<li>是否实现DisposableBean接口</li>
<li>是否配置自定义的destory-method</li>
</ul>
</li>
<li>结束。</li>
</ul>
<h2 id="2-Spring循环依赖"><a href="#2-Spring循环依赖" class="headerlink" title="2. Spring循环依赖"></a>2. Spring循环依赖</h2><ul>
<li>只有单例Bean才会存在循环依赖。</li>
<li>当循环依赖的实例都采用setter方法注入，Spring可以解决；都采用构造器方法注入时，spring不可以解决；构造器注入和setter注入同时存在的时候，看天。</li>
</ul>
<p><strong>Spring通过三级缓存解决了循环依赖问题：</strong></p>
<ul>
<li>一级缓存：singletonObjects<strong>单例池</strong>，用于保存实例化、属性赋值（注入）、初始化完成的bean实例；</li>
<li>二级缓存：earlySingletonObjects<strong>早期曝光对象</strong>，用于保存实例化完成的bean实例</li>
<li>三级缓存：singletonFactories<strong>早期曝光对象工厂</strong>，用于保存Bean创建工厂，以便于后面扩展有机会创建代理对象。</li>
</ul>
<h2 id="3-Spring事务"><a href="#3-Spring事务" class="headerlink" title="3. Spring事务"></a>3. Spring事务</h2><h3 id="spring事务隔离级别："><a href="#spring事务隔离级别：" class="headerlink" title="spring事务隔离级别："></a>spring事务隔离级别：</h3><ul>
<li><strong>ISOLATION_DEFAULT： 使用后端数据库的默认隔离级别</strong>，mysql默认 可重复读 级别</li>
<li>ISOLATION_READ_UNCOMMITTED：即读未提交，最低的隔离级别，不能解决脏读，幻读，不可重复读</li>
<li>ISOLATION_READ_COMMITTED：即 读已提交，可以解决脏读，不能解决不可重复读 以及 幻读；</li>
<li>.ISOLATION_REPEATABLE_READ：即 可重复读，可解决脏读，不可重复读，不能解决幻读；</li>
<li>ISOLATION_SERIALIZABLE： 串行化，完全服从ACID，但是会严重影响性能。</li>
</ul>
<h3 id="Spring事务传播行为："><a href="#Spring事务传播行为：" class="headerlink" title="Spring事务传播行为："></a>Spring事务传播行为：</h3><p>事务传播行为是为了解决<strong>service层方法之间互相调用</strong>的事务问题（一个事务方法被另一个事务方法调用时，需要指定事务如何传播）。</p>
<p><strong>事务传播行为包括如下：</strong></p>
<ul>
<li>REQUIRED： 默认的事务传播行为，required表示当前方法必须在一个事务中运行，如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务；</li>
<li>SUPPORTS：当前方法支持在一个事务中运行，如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式执行；</li>
<li>MANDATORY：当前方法必须在一个事务中运行，如果当前存在事务，则加入该事务，如果当前没有事务，则抛出异常；</li>
<li>REQUIRES_NEW：当前方法必须在一个新的事务中运行，如果当前存在事务，就挂起该事务，并创建一个新的事务。</li>
<li>NOT_SUPPORTED：当前方法不应该在事务中运行，如果当前存在事务，就挂起该事务，以非事务的方式执行。</li>
<li>NEVER：表示当前方法不应在事务中运行，如果当前存在事务，则抛出异常。</li>
<li>NESTED：表示当前方法必须在一个嵌套的事务中运行，如果当前存在事务，则该在事务的嵌套事务中运行；如果当前没有事务，则创建一个新的嵌套事务。</li>
</ul>
<h3 id="事务失效场景"><a href="#事务失效场景" class="headerlink" title="事务失效场景"></a>事务失效场景</h3><ul>
<li><strong>@Transactional 应用在非 public 修饰的方法上</strong>：spring要求被代理方法必须是public的。在<code>AbstractFallbackTransactionAttributeSource</code>类的<code>computeTransactionAttribute</code>方法中有个判断，如果目标方法不是 public，则<code>TransactionAttribute</code>返回 null，即不支持事务。</li>
<li><strong>方法用 final修饰：</strong>如果将事务方法定义为final，这样会导致事务失效。原因是spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现事务的功能。<strong>如果某个方法被final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能</strong>。 同样的，如果某个<strong>方法是static的</strong>，同样<strong>无法</strong>通过动态代理，<strong>变成事务方法</strong>。</li>
<li><strong>同一个类中方法调用，导致事务失效：</strong>方法A调用本地的方法B，但<strong>A没有声明注解事务，但是B声明了</strong>，在<strong>外部调用方法A后，B的事务是不会起作用</strong>的。这还是由于SpringAOP代理造成的，因为只有当<strong>事务方法被当前类以外的代码调用的时候，才会由spring生成的代理对象</strong>来管理。</li>
<li><strong>方法所在的类没有被Spring管理：</strong>用spring事务的前提是，对象要被spring管理。</li>
</ul>
<h3 id="事务不回滚场景："><a href="#事务不回滚场景：" class="headerlink" title="事务不回滚场景："></a>事务不回滚场景：</h3><ul>
<li><strong>设置了错误的传播特性 propagation；</strong></li>
<li><strong>自己吞了异常：</strong>在事务方法中手动try catch了异常，这种情况下事务不会正常回滚。</li>
<li><strong>手动抛出了别的异常：</strong>即使开发者没有手动捕获异常，但是抛的异常不正确，spring事务也不会回滚。spring事务，默认情况下只会回滚 runtimeException和 error，对于普通的Exception（非运行时异常），它不会回滚。</li>
</ul>
<h1 id="三、计算机网络"><a href="#三、计算机网络" class="headerlink" title="三、计算机网络"></a>三、计算机网络</h1><h2 id="1-TCP三次握手-amp-四次挥手"><a href="#1-TCP三次握手-amp-四次挥手" class="headerlink" title="1. TCP三次握手 &amp; 四次挥手"></a>1. TCP三次握手 &amp; 四次挥手</h2><p><strong>三次握手建立连接</strong>。从client的视角来看：</p>
<ul>
<li><strong>第一次握手</strong>： client发送一个带有<code>syn（seq = x）</code>标志的数据包到server端，然后标识自己的状态为<strong>syn_send</strong>已发送状态；</li>
<li><strong>第二次握手</strong>：server收到了client发来的消息，于是向client发送 <code>syn (seq = y) + ack（ack=x+1） </code>确认信息。client接收到确认信息后，这时候client知道自己的发送和接收都能正常进行，对方的发送和接收都正常；server知道自己能正常接收，对方能正常发送（<strong>但不知道对方能否正常接收，自己能不能正常发送</strong>）；在server发送确认信息后表示自己状态为<strong>syn_recv</strong>已接收状态。</li>
<li><strong>第三次握手</strong>：client发送一个<code>ack (ack = y+1)</code>标志的数据包，然后client和server端都进入 <strong>establish</strong>链接建立状态。完成三次握手。</li>
</ul>
<p><strong>三次握手最重要的目的就是双方确认自己与对方的发送与接收都是正常的。</strong></p>
<ul>
<li><strong>第一次握手</strong>：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li><strong>第二次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li><strong>第三次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ul>
<p><strong>第二次握手传回了ack，为什么 还要传回syn?</strong></p>
<p>传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。</p>
<p><strong>四次挥手断开连接</strong>：</p>
<ul>
<li><strong>第一次挥手：</strong> client发送一个<code>FIN（seq = x）</code>的数据包到服务端，用来关闭客户端到服务端的数据传送，然后client进入<strong>FIN-Wait-1</strong>状态；</li>
<li><strong>第二次挥手</strong>：server收到这个<code>FIN（seq=x）</code>的数据包，然后发送一个<code>ACK（ack = x+1）</code>的数据包到client，随后server进入<strong>Close-wait</strong>状态，client收到这个数据包后进入<strong>FIN-Wait-2</strong>状态；</li>
<li><strong>第三次挥手</strong>：server发送一个<code>FIN （seq = y）</code>的数据包到client，请求关闭连接，随后server进入<strong>LAST-ACK</strong>状态；</li>
<li><strong>第四次挥手</strong>：client发送一个<code>ACK (ack=y+1)</code> 的数据包到server，然后client进入到<strong>TIME-Wait</strong>状态，server端在接收到这个数据包后进入<strong>CLOSE</strong>状态。此时如果client等待 <strong>2*MSL</strong>（一个片段在网络中的最大存活时间）没有收到回复，说明server已经正常关闭，随后client也可以关闭连接了。</li>
</ul>
<h1 id="四、JVM"><a href="#四、JVM" class="headerlink" title="四、JVM"></a>四、JVM</h1><h2 id="1-JVM内存"><a href="#1-JVM内存" class="headerlink" title="1. JVM内存"></a>1. JVM内存</h2><h3 id="jvm内存组成："><a href="#jvm内存组成：" class="headerlink" title="jvm内存组成："></a>jvm内存组成：</h3><ul>
<li><strong>方法区</strong>（线程共享区）<ul>
<li>也称为永久代，JDK8后改为<strong>元空间</strong>；</li>
<li>存储<strong>已加载的类</strong>的类信息、常量、静态变量、即时编译器编译后的代码等；</li>
</ul>
</li>
<li><strong>堆</strong>（线程共享区）<ul>
<li>存储<strong>对象实例</strong>和<strong>数组</strong>；</li>
<li>JVM管理的最大一块内存区域（垃圾回收）</li>
<li>在JVM启动时被创建，并且在运 行时进行动态扩展或收缩；</li>
</ul>
</li>
<li><strong>本地方法栈</strong>（线程私有区）<ul>
<li>与虚拟机栈类似，但它是为了<strong>本地方法</strong>服务</li>
<li>本地方法使用其他语言写的一些方法，需要特殊的栈支持。</li>
</ul>
</li>
<li><strong>虚拟机栈（</strong>线程私有区）<ul>
<li>每个线程在执行Java方法时，都会创建一个对应的<strong>栈帧</strong></li>
<li><strong>栈帧</strong>用来存储<strong>局部变量、方法参数、操作数栈、动态链接</strong>等信息</li>
</ul>
</li>
<li><strong>程序计数器</strong>（线程私有区）<ul>
<li>每个线程都有自己的程序计数器，用来记录当前线程执行的位置。</li>
</ul>
</li>
</ul>
<h3 id="对象创建过程："><a href="#对象创建过程：" class="headerlink" title="对象创建过程："></a>对象创建过程：</h3><ul>
<li>遇到new字节码指令的时候，检查指令的参数能否找到一个类的符号引用</li>
<li>如果这个符号引用对应的类还没有被加载、解析、初始化过，那么先执行类加载过程。</li>
<li>类加载完成后，为新对象分配内存，分配内存的方法包括<strong>指针碰撞、空闲列表</strong>方法。</li>
<li>分配完内存，对分配好的内存（除了对象头）进行初始化工作，都初始化为0值。</li>
<li>接下来设置对象头，对象头包括所属的类、哈希码、GC分代年龄等。</li>
<li>最后，JVM执行对象的构造函数，对对象的实例变量进行初始化或其他必要操作。</li>
</ul>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><ul>
<li>对象头<ul>
<li>对象运行时数据：<ul>
<li>哈希码</li>
<li>GC分代年龄</li>
<li>锁状态标识</li>
<li>线程持有的锁</li>
<li>偏向线程ID</li>
<li>偏向时间戳</li>
</ul>
</li>
<li>类型指针（自己代表哪个类）。</li>
<li>如果是数组，还有一个保存自己长度信息的数据</li>
</ul>
</li>
<li>实例化数据，存储对象真正的有效信息。</li>
<li>对齐填充padding，无实际意义。</li>
</ul>
<h3 id="对象有哪几种引用类型"><a href="#对象有哪几种引用类型" class="headerlink" title="对象有哪几种引用类型"></a>对象有哪几种引用类型</h3><ul>
<li>强引用<ul>
<li>当一个对象被强引用时，不会被垃圾回收</li>
<li>没有任何强引用指向一个对象时，可以被垃圾回收</li>
</ul>
</li>
<li>软引用<ul>
<li>相对弱化的强引用，当内存不足时，可能会回收软引用关联的对象</li>
</ul>
</li>
<li>弱引用<ul>
<li>相对弱化的强引用，无论内存是否充足，都会回收被弱引用关联的对象</li>
</ul>
</li>
<li>虚引用<ul>
<li>最弱化的强引用，任何时候都可能会被回收，不会通过虚引用获取到对象实例。</li>
</ul>
</li>
</ul>
<h3 id="堆内存分区"><a href="#堆内存分区" class="headerlink" title="堆内存分区"></a>堆内存分区</h3><ul>
<li>新生代<ul>
<li>Eden区（较大）</li>
<li>survivor区 （较小）<ul>
<li>from区</li>
<li>to区</li>
</ul>
</li>
</ul>
</li>
<li>老年代</li>
</ul>
<p>对象被创建时，会被放至Eden区，垃圾回收后，Eden中的存活对象会被转入survivor区，经过多次垃圾回收后会转入老年代。老年代的回收频率较低。</p>
<p>每次分配内存只是用Eden和其中一块survivor，发生垃圾收集时，eden和survivor中存活的对象一次性复制到另一块survivor上。然后直接清理掉 Eden和已用过的那块Survivor空间。</p>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul>
<li><strong>标记-清除法</strong>：标记出要回收的对象，然后回收所有被标记的对象。<ul>
<li>缺点：执行效率不稳定，标记和清除两个过程的执行效率都随对象数量增长而降低；并且会造成内存空间的碎片化问题</li>
</ul>
</li>
<li><strong>标记-复制法</strong>：划分为大小相等的两块，每次只用一块，当这一块的内存用完了，将存活的内存复制到另一块，这一块的内存直接回收<ul>
<li>缺点：始终有一半的内存是空闲的，造成了空间的浪费</li>
<li>所以新生代垃圾回收一般使用这个方法，因为新生代<strong>存活对象</strong>较少</li>
</ul>
</li>
<li><strong>标记-整理法</strong>： 让所有存活的对象都向内存空间一端移动，然后直接清理掉边界之外的内存。<ul>
<li>缺点：移动存活对象是个极为负重的工作，并且还要stop the word</li>
<li>因此老年代主要用这种方法。</li>
</ul>
</li>
</ul>
<h3 id="类生命周期"><a href="#类生命周期" class="headerlink" title="类生命周期"></a>类生命周期</h3><ol>
<li>加载： 将类的字节码文件加载到内存中，并创建该类的.Class对象</li>
<li>验证： 验证字节码文件是否符合JVM规范</li>
<li>准备： 为类的静态变量分配内存空间，并设置初始值</li>
<li>解析：这一阶段主要是将符号引用转换为直接引用。</li>
<li>初始化：执行构造器方法的过程，这一阶段是类主动使用的阶段。</li>
<li>使用： 在该类被加载和初始化后，就可以使用该类创建对象，调用类的方法。</li>
<li>卸载：当一个类不再被引用，并且也没有活跃的实例时，JVM会卸载该类。</li>
</ol>
<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><ol>
<li>通过类的全限定名 来获取此类的二进制字节流</li>
<li>将这个字节流代表的 静态数据结构 转变为 方法区的运行时数据结构</li>
<li>在内存区生成一个 代表这个类的 java.lang.Class 对象，作为 方法区这个类的各种数据的访问入口。</li>
</ol>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul>
<li><strong>启动类加载器</strong>：又称为根类加载器，是JVM的一部分，负责加载java的核心类库。</li>
<li><strong>扩展类加载器</strong>：用来加载java的扩展库，JVM的实现会提供一个扩展库目录，该类加载器在该目录里查找并加载扩展类。</li>
<li><strong>系统类加载器</strong>：根据java应用的类路径来加载类，一般java应用的类都是它加载的。可以通过ClassLoader.getSystemClasssLoader() 来获取</li>
<li><strong>用户类加载器：</strong>用户可以通过集成java.lang.classLoader的方式自行实现类加载器。</li>
</ul>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p>当一个类加载器收到加载类的请求时，会首先请求父类加载器进行类加载，如果加载成功则类加载结束。否则由子类类加载器进行加载。</p>
<h3 id="使用双亲委派机制的好处"><a href="#使用双亲委派机制的好处" class="headerlink" title="使用双亲委派机制的好处"></a>使用双亲委派机制的好处</h3><ul>
<li><strong>避免类的重复加载</strong>：如果父类加载器已经加载了一个类，那么子类不会再次加载。<strong>节省了内存</strong>。</li>
<li><strong>确保类的安全性和一致性</strong>：Java核心类库由 启动类加载器 加载，可以<strong>防止恶意代码替换核心类库</strong>，保证核心类库的安全性和一致性。</li>
<li><strong>防止类的篡改</strong>： 父类加载器加载的类不会被子类加载器替换，防止了类的篡改。</li>
<li><strong>方便类加载器的扩展和自定义</strong>： 可以通过扩展classLoader类来实现类加载器的自定义，通过双亲委派机制，可以<strong>方便的扩展和自定义类加载器的功能，满足不同的加载需求。</strong></li>
</ul>
<h3 id="如何破坏类加载机制"><a href="#如何破坏类加载机制" class="headerlink" title="如何破坏类加载机制"></a>如何破坏类加载机制</h3><ul>
<li>自定义类加载器： 可以重写LoadClass方法，实现自己的类加载逻辑，不再委托给父类加载器。但是自定义类加载器需要遵循一定的类加载规则，以确保类加载的一致性和正确性。</li>
<li>使用Thread.currentThread.setContextClassLoader方法：通过该方法设置当前线程的上下文类加载器，将类加载的委派顺序改变，这样可以绕过双亲委派机制，直接指定类加载器进行加载。</li>
</ul>
<h1 id="五、MySQL"><a href="#五、MySQL" class="headerlink" title="五、MySQL"></a>五、MySQL</h1><h2 id="0-基础"><a href="#0-基础" class="headerlink" title="0.基础"></a>0.基础</h2><h3 id="一条SQL执行的步骤："><a href="#一条SQL执行的步骤：" class="headerlink" title="一条SQL执行的步骤："></a>一条SQL执行的步骤：</h3><ul>
<li><strong>权限检查：</strong>检查用户是否有执行该语句的权限。</li>
<li><strong>查询缓存（仅适用于8.0版本之前）：</strong>如果缓存中有该语句的结果，就从缓存中返回结果。</li>
<li><strong>语法分析和语义检查：</strong>由MySQL<strong>解析器</strong>验证语句的合法性。</li>
<li><strong>查询优化</strong>：MySQL的<strong>查询优化器</strong>根据查询的复杂度、索引情况、统计信息等因素选择最佳的查询计划。</li>
<li><strong>执行查询计划：</strong>涉及表扫描、索引的匹配、数据的过滤和排序等操作。</li>
<li><strong>数据检索和返回：</strong> <strong>执行器</strong>根据查询计划获取数据，并将结果返回客户端。如果涉及查询大量数据，MySQL可能会使用临时表来存储中间结果，并进行排序和分页操作。</li>
</ul>
<h2 id="1-索引"><a href="#1-索引" class="headerlink" title="1. 索引"></a>1. 索引</h2><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类:"></a>索引分类:</h3><ul>
<li>按<strong>数据结构</strong>分类：B+树索引、Hash索引、Full-text索引</li>
<li>按<strong>物理存储</strong>分类：聚簇索引（主键索引）、二级索引</li>
<li>按<strong>字段特性</strong>分类：主键索引、普通索引、唯一索引、前缀索引</li>
<li>按<strong>字段个数</strong>分类：唯一索引、联合索引。</li>
</ul>
<h3 id="B-树索引（主键索引-or-二级索引）"><a href="#B-树索引（主键索引-or-二级索引）" class="headerlink" title="B+树索引（主键索引 or 二级索引）"></a>B+树索引（主键索引 or 二级索引）</h3><ul>
<li>多叉树、叶子节点才存放数据、非叶子节点只存放索引</li>
<li>每个节点中的数据是按照主键顺序存放的。</li>
<li>叶子节点之间通过双向链表连接。</li>
<li>对主键索引来说，叶子节点存放的就是实际数据。</li>
<li>对二级索引来说，叶子节点存放的是主键值，而不是实际数据。<strong>回表就是指</strong>需要查询二级索引树和主键索引树两个B+树才能查到数据。</li>
<li>当查到的数据在二级索引的叶子节点就能找到时，此时就<strong>不用再回表查询</strong>了。<strong>这被称为覆盖索引</strong></li>
<li>相比于B树，B+树更适合于范围查询，因为其叶子节点用双向链表相连；而且B树的非叶子节点也要存储数据，B+树单节点数据量更小。</li>
<li>相比于二叉树，B+树能保证高度始终在3-4层左右，对IO更友好。</li>
<li>相比于Hash，查询复杂度o(1)优于B+树，但hash不适合范围查询。</li>
</ul>
<p><strong>B+树索引的优势</strong>：相比于B树和二叉树来说，最大的优势在于查询效率高，即使在数据量很大的情况下，<strong>磁盘的IO次数依然维持在3-4次</strong>。</p>
<h3 id="联合索引-amp-索引下推优化"><a href="#联合索引-amp-索引下推优化" class="headerlink" title="联合索引 &amp; 索引下推优化"></a>联合索引 &amp; 索引下推优化</h3><ul>
<li><strong>联合索引的最左匹配原则：在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配</strong></li>
<li><strong>索引下推优化：</strong><ul>
<li>对于联合索引（a, b），在执行 <code>select * from table where a &gt; 1 and b = 2</code> 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？</li>
<li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li>
<li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</li>
</ul>
</li>
<li><strong>建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到</strong>。</li>
<li>MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是”30%”）很高的时候，它一般会忽略索引，进行全表扫描。</li>
</ul>
<h3 id="⭐索引失效的情况"><a href="#⭐索引失效的情况" class="headerlink" title="⭐索引失效的情况"></a>⭐索引失效的情况</h3><ul>
<li>使用<strong>左或者左右模糊匹配</strong>的时候，会造成索引失效；</li>
<li>当在<strong>查询条件中对索引做了计算、函数、类型转换操作</strong>，这些情况下都会造成索引失效；</li>
<li>在<strong>联合索引</strong>中，没有遵循<strong>最左匹配原则</strong>，导致索引失效；</li>
<li>在 <strong>WHERE 子句</strong>中，如果在 <strong>OR 前</strong>的条件列是<strong>索引列</strong>，而在 <strong>OR 后</strong>的条件列<strong>不是索引列</strong>，那么索引会失效。</li>
<li><strong>使用like “%xxx”,索引一定会失效么？</strong>：<ul>
<li>如果数据表中的字段<strong>只有主键+二级索引</strong>，那么即使使用了左模糊匹配，也不会走全表扫描，而是<strong>走全扫描二级索引树</strong>。</li>
<li>我们都知道联合索引要遵循最左匹配才能走索引，但是<strong>如果数据表中的字段都是索引</strong>的话，即使查询过程中，<strong>没有遵循</strong>最左匹配原则，也是会<strong>走全扫描二级索引树</strong>。</li>
</ul>
</li>
</ul>
<h3 id="优化索引的方法"><a href="#优化索引的方法" class="headerlink" title="优化索引的方法"></a>优化索引的方法</h3><ul>
<li>前缀索引优化</li>
<li>覆盖索引优化</li>
<li>主键索引最好是自增的</li>
<li>防止索引失效</li>
</ul>
<h3 id="索引存储结构"><a href="#索引存储结构" class="headerlink" title="索引存储结构"></a>索引存储结构</h3><ul>
<li>根据物理存储分类，索引分为<strong>聚簇索引和二级索引</strong>。<ul>
<li>对于<strong>InnoDB</strong>引擎，聚簇索引的叶子节点存放的是实际数据，而二级节点存放的是主键值，而不是实际数据。</li>
<li>对于<strong>MyISAM</strong>引擎，聚簇索引的叶子节点存放的是具体数据的地址。</li>
</ul>
</li>
<li>MySQL的<strong>默认存储引擎</strong>是<strong>InnoDB</strong>，它采用<strong>B+树</strong>作为索引数据结构。</li>
<li><strong>MyISAM 存储引擎</strong>支持多种索引数据结构，比如 B+ 树索引、R 树索引、Full-Text 索引。MyISAM 存储引擎在创建表时，创建的主键索引默认使用的是 <strong>B+ 树索引</strong>。</li>
<li>虽然，I<strong>nnoDB 和 MyISAM 都支持 B+ 树索引</strong>，但是它们数据的存储结构实现方式<strong>不同</strong>:<ul>
<li><strong>InnoDB</strong> 存储引擎：B+ 树索引的叶子节点保存<strong>数据本身</strong>；</li>
<li><strong>MyISAM 存</strong>储引擎：B+ 树索引的叶子节点保存数据的<strong>物理地址；</strong></li>
</ul>
</li>
<li>对聚簇索引的理解：<ul>
<li>聚簇索引具有唯一性：由于聚簇索引是将索引和数据放在一块，所以一个表仅有一个聚簇索引。</li>
<li>（1）聚簇索引默认是主键。（2）如果表中没有定义主键，InnoDB会选择第一个唯一的非空索引代替。（3）如果没有这样的索引，InnoDB 会隐式定义一个主键作为聚簇索引。</li>
</ul>
</li>
</ul>
<h3 id="MySQL-表的物理结构"><a href="#MySQL-表的物理结构" class="headerlink" title="MySQL 表的物理结构"></a>MySQL 表的物理结构</h3><ul>
<li>MySQL的<strong>表数据</strong>是以<strong>页</strong>的形式存放的，页在磁盘中<strong>不一定是连续的</strong>。</li>
<li>页空间是16K，并不是所有的空间都是用来存放数据的，会有一些固定的信息，如页头、页尾、页码、校验码等。</li>
<li>在B+树中，叶子节点和非叶子节点的数据结构是一样的，区别在于，<strong>叶子节点</strong>存放的是<strong>实际的行数据</strong>，而<strong>非叶子节点</strong>存放的是<strong>主键和页号。</strong></li>
</ul>
<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240429195215797.png" alt="image-20240429195215797" style="zoom: 67%;" />



<ul>
<li>索引结构不会影响单表最大行数，2000W也只是推荐值，<strong>超过了这个值可能会导致B+树层级更高，影响查询性能</strong>。</li>
</ul>
<h2 id="2-事务"><a href="#2-事务" class="headerlink" title="2.  事务"></a>2.  事务</h2><h3 id="2-1-事务隔离级别"><a href="#2-1-事务隔离级别" class="headerlink" title="2.1 事务隔离级别"></a>2.1 事务隔离级别</h3><h4 id="四个隔离级别："><a href="#四个隔离级别：" class="headerlink" title="四个隔离级别："></a><strong>四个隔离级别：</strong></h4><ul>
<li><p>读未提交（啥都解决不了）</p>
</li>
<li><p>读已提交 （解决了脏读）</p>
</li>
<li><p>可重复读 （解决了脏读，不可重复读，InnoDB默认的隔离级别）</p>
</li>
<li><p>串行化 （解决了脏读，不可重复读以及幻读，但是效率最低，不轻易使用。）</p>
</li>
<li><p>InnoDB 引擎的<strong>默认隔离级别是 可重复读</strong>，但是它很大程度上避免了幻读现象。解决的方案有两种：</p>
<ul>
<li>针对<strong>快照读（普通select）</strong>，是通过<strong>MVCC</strong>方式解决了幻读。因为可重复读隔离级别下，事务执行<strong>过程中看到的数据</strong>，一直<strong>跟</strong>这个<strong>事务启动时看到的数据是一致的</strong>，即使中途有其他事务插入了一条数据，是查询不出来的。</li>
<li>针对<strong>当前读（select … for update等语句）</strong>，是通过<strong>next-key lock(记录锁 + 间隙锁)<strong>方式解决了幻读。因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被</strong>阻塞</strong>，无法成功插入，所以就很好了避免幻读问题。</li>
</ul>
</li>
<li><p>InnoDB引擎为了解决 <strong>可重复读</strong> 隔离级别使用 <strong>当前读</strong> 而造成的<strong>幻读</strong>问题，引出了<strong>间隙锁</strong>（<strong>即使这样也只是最大程度避免幻读，没有完全解决幻读</strong>）</p>
<ul>
<li><p>表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发生。</p>
</li>
<li><p>事务 A 执行了这面这条锁定读（for update）语句后，就在对表中的记录加上 id 范围为 (2, +∞] 的 next-key lock（next-key lock 是间隙锁+记录锁的组合）。<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240430153508438.png" alt="image-20240430153508438"></p>
<p>然后，事务 B 在执行插入语句的时候，判断到插入的位置被事务 A 加了 next-key lock，于是<strong>事物 B 会生成一个插入意向锁</strong>，同时<strong>进入等待</strong>状态，<strong>直到</strong>事务 <strong>A 提交了事务</strong>。这就<strong>避免了由于事务 B 插入新记录而导致事务 A 发生幻读</strong>的现象。</p>
</li>
</ul>
</li>
</ul>
<h4 id="四个隔离级别是如何实现的"><a href="#四个隔离级别是如何实现的" class="headerlink" title="四个隔离级别是如何实现的"></a>四个隔离级别是如何实现的</h4><ul>
<li>对于 <strong>读未提交</strong> 级别，实现方式相对简单，因为可以读到未提交事务修改的数据，所以<strong>直接读取最新的数据就好</strong>了。</li>
<li>对于 <strong>读已提交</strong> 和 <strong>可重复读</strong> 级别来说，他们是<strong>通过read view来实现</strong>的，它们的区别在于：<strong>读已提交</strong>是在 <strong>每个语句执行前</strong> 都会重新生成 read view，而<strong>可重复读</strong> 是在 <strong>启动事务时</strong> 生成一个read view，然后整个事务期间都在使用这个read view</li>
<li>对于 <strong>串行化</strong> 级别，通过添加<strong>读写锁（排他锁）</strong>的方式实现。</li>
</ul>
<h2 id="3-MySQL锁"><a href="#3-MySQL锁" class="headerlink" title="3.  MySQL锁"></a>3.  MySQL锁</h2><h3 id="全局锁："><a href="#全局锁：" class="headerlink" title="全局锁："></a><strong>全局锁</strong>：</h3><ul>
<li><p>使用全局锁后，整个数据库就处于只读状态了。这时其他线程执行以下操作，都会被阻塞：</p>
<ul>
<li>对<strong>数据的增删改</strong>操作，比如 insert、delete、update等语句；</li>
<li>对<strong>表结构的更改</strong>操作，比如 alter table、drop table 等语句。</li>
</ul>
</li>
<li><p>全局锁主要用于做<strong>全库逻辑备份</strong>，这样在备份期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
</li>
<li><p>如果备份花费很长时间，在这个时间段内业务只能读数据，造成业务的停滞。</p>
</li>
<li><p>如果数据库的引擎支持 <strong>可重复读</strong> 的隔离级别，那么在<strong>备份数据库之前先开启事务</strong>，会先创建read view ,然后整个事务执行期间都在使用这个read view，而且由于MVCC的支持，<strong>备份期间业务依然可以对数据进行更新操作</strong>。（<strong>InnoDB引</strong>擎默认的隔离级别正是可重复读，<strong>因此可采用这种方式备份库</strong>，而 <strong>MyISAM不支持事务</strong>，备份库时就<strong>只能使用全局锁</strong>）</p>
</li>
</ul>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p><strong>表级锁有这几种：</strong></p>
<ul>
<li>表锁</li>
<li>元数据锁 （MDL）</li>
<li>意向锁</li>
<li>Auto-INC 锁</li>
</ul>
<p><strong>（1） 表锁</strong></p>
<ul>
<li>表锁除了会限制别的线程读写之外，也<strong>会限制本线程接下来的读写操作</strong>。</li>
<li>尽量<strong>避免在使用InnoDB 引擎的表使用表锁</strong>，因为表锁的颗粒度太大，影响并发性能，<strong>InnoDB 实现了粒度更细的行级锁，更牛逼。</strong></li>
</ul>
<p><strong>（2）元数据锁</strong></p>
<ul>
<li><p><strong>不用显式</strong>的使用，因为我们在对数据库表进行操作时，会自动给这个表加上MDL；</p>
<ul>
<li>对<strong>表进行crud</strong>的时候，添加的时<strong>MDL读锁；</strong></li>
<li>对<strong>表结构</strong>进行变更的时候，添加的是<strong>MDL写锁</strong>；</li>
</ul>
</li>
<li><p>MDL在事务提交之后才会释放，这意味着<strong>事务执行期间，MDL是一直持有的。</strong></p>
</li>
<li><p>申请MDL锁的操作会形成一个队列，队列中，<strong>写锁的优先级高于读锁</strong>，一旦出现MDL写锁等待，<strong>会阻塞后续该表中所有的CRUD操作</strong>（因为拿不到读锁了）。</p>
</li>
</ul>
<p><strong>（3）意向锁</strong></p>
<ul>
<li>在使用 InnoDB 引擎的表里对某些记录加上<strong>「共享锁」</strong>之前，需要先在表级别加上一个「<strong>意向共享锁」</strong>；</li>
<li>在使用 InnoDB 引擎的表里对某些纪录加上<strong>「独占锁」</strong>之前，需要先在表级别加上一个<strong>「意向独占锁</strong>」；</li>
</ul>
<p><strong>意向锁是表级锁</strong>，<strong>不会和行级</strong>的共享锁和独占锁发生<strong>冲突</strong>，而且<strong>意向锁之间也不会发生冲突</strong>，只会和共享<strong>表锁</strong>和独占<strong>表锁</strong>发生冲突</p>
<p><strong>意向锁的目的是为了快速判断表里是否有记录被加锁，</strong>如果表被上了意向独占锁，表明表内有数据被加了独占锁，这样其他线程就不用再去逐条看是哪一条记录被添加了独占锁。</p>
<p><strong>（4）Auto-INC 锁</strong></p>
<ul>
<li>设置主键自增时，再插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是<strong>通过Auto_INC锁实现</strong>的。</li>
<li><strong>auto-inc是一种特殊的表锁机制</strong>，<strong>锁不再是一个事务提交之后才释放，而是在执行完插入语句之后就会立即释放。</strong></li>
<li>在插入数据时，会添加一个<strong>表级别</strong>的Auto-INC锁，然后给自增的字段赋值，等<strong>插入语句执行完</strong>后，才会把Auto-Inc<strong>释放。</strong></li>
<li><strong>InnoDB 提供了一个轻量级锁</strong>，插入时，会给自增字段加上轻量级锁，然后给该字段赋值自增，之后就释放了，<strong>不用再等插入语句结束后再释放。</strong></li>
</ul>
<h3 id="行级锁（只有InnoDB-支持）"><a href="#行级锁（只有InnoDB-支持）" class="headerlink" title="行级锁（只有InnoDB 支持）"></a>行级锁（只有InnoDB 支持）</h3><p><strong>普通的select语句是不会对记录进行加锁的</strong>，因为它属于快照读。如果要在查询时对记录加锁，可以使用下面这种方式，查询加锁的方式称为<strong>锁定读</strong>：</p>
<ul>
<li><code>select ... lock in share mode (加共享锁)</code></li>
<li><code>select ... for update（加独占锁）</code></li>
</ul>
<p><strong>行级锁有四类：</strong></p>
<ul>
<li><strong>Record lock</strong>，记录锁，也就是仅锁一条记录。<ul>
<li>记录锁有 <strong>共享锁</strong> 和 <strong>独占锁</strong> 之分。如果一个事务对当前记录加了共享锁，那么其他事务可以加共享锁但是不能加独占锁；如果是加了独占锁，那么其他事务既不能加独占锁也不能加共享锁。</li>
</ul>
</li>
<li><strong>Gap Lock</strong>， 间隙锁，锁定一个范围，但是不包含记录本身，<strong>只存在于可重复读隔离级别</strong>；目的是为了解决该级别下 <strong>幻读</strong>的现象。<ul>
<li><strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong></li>
</ul>
</li>
<li><strong>Next-Key Lock</strong> , 是上面两种锁的组合，<strong>锁定一个范围，并且锁定记录本身。</strong></li>
<li><strong>插入意向锁：</strong> 名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级锁。</strong><ul>
<li>当一个事务想插入一条记录，但是发现插入位置有其他事务设置的间隙锁，那么当前插入操作会阻塞，直到拥有这些间隙锁的事务提交为止。</li>
<li>在此期间，该事务会生成一个插入意向锁，表明有业务向再这个区间插入新纪录，但是现在在等待。</li>
</ul>
</li>
</ul>
<h2 id="4-日志"><a href="#4-日志" class="headerlink" title="4. 日志"></a>4. 日志</h2><h3 id="MySQL的三个日志："><a href="#MySQL的三个日志：" class="headerlink" title="MySQL的三个日志："></a>MySQL的三个日志：</h3><ul>
<li>undo log：回滚日志，是InnoDB<strong>存储引擎层</strong>生成的日志，实现事务的<strong>原子性</strong>。主要用于<strong>事务回滚和MVCC</strong>。</li>
<li>redo log：重做日志，是InnoDB<strong>存储引擎层</strong>生成的日志，实现事务的<strong>持久性</strong>，主要用于<strong>掉电等故障恢复</strong>。</li>
<li>binlog：二进制日志，是<strong>server层</strong>生成的日志，主要用于<strong>数据备份和主从复制</strong>（可以认为是为了实现事务的<strong>一致性</strong>）。</li>
</ul>
<h3 id="关于undo-log"><a href="#关于undo-log" class="headerlink" title="关于undo log:"></a>关于undo log:</h3><ul>
<li><strong>（作用1）</strong>undo log即回滚日志，用于在事务提交失败的时候进行回滚操作时使用，用于实现<strong>原子性</strong>。</li>
<li>每当InnoDB引擎对一条记录进行 <strong>增删改</strong> 的时候（这时候会<strong>自动隐式的开启事务</strong>），需要把回滚时需要的信息记录到 undo log 中：<ul>
<li>插入时，记录插入记录的主键值，回滚时删除就好；</li>
<li>删除时，记录该记录的所有内容，回滚时插入到表内就好；</li>
<li>更新时，记录被更新列的旧值，回滚时恢复就好。</li>
</ul>
</li>
<li><strong>（作用2）</strong>undo log的另一个作用是：<strong>通过readview + undo log来实现MVCC</strong>（多版本并发控制）：<ul>
<li>首先引入<strong>版本链</strong>：每条记录有两个隐藏列 <strong>trx_id（该记录是被哪个事务修改的）</strong> 和 <strong>roll-pointer （一个指针，可以将这些undo log 串成一个链表，这个链表称为版本链）</strong></li>
<li><strong>读已提交</strong> 和 <strong>可重复读</strong> <strong>两个隔离级别</strong>，他们的<strong>快照读</strong>都是通过read view + undo log来实现的，区别在与<strong>创建readview的时机不同：</strong><ul>
<li>读已提交是在每个select都会生成一个read view；</li>
<li>可重复读是在启动事务时生成一个read view，整个事务期间都在使用这个read view;</li>
</ul>
</li>
<li>两个隔离级别是通过 <strong>事务的read view里的字段</strong> 和 <strong>记录中的两个隐藏列</strong> 进行比对，如果不满足可见，就会顺着 undo log版本链找到满足其可见性的记录，从而控制并发事务访问同一个记录的行为。这就叫<strong>MVCC</strong></li>
</ul>
</li>
</ul>
<h3 id="关于buffer-pool"><a href="#关于buffer-pool" class="headerlink" title="关于buffer pool:"></a>关于buffer pool:</h3><p>引入buffer pool是为了提升读写性能，buffer pool中缓存的是数据页（默认16kb）：</p>
<ul>
<li>如果读记录时，该记录在缓冲池中，那么就从缓冲池中读，否则去磁盘中读；</li>
<li>修改记录时，如果记录存在于缓冲池中，那么直接修改该记录在缓冲池中的页，并将其标志为脏页。脏页不会立即写入磁盘，后台线程会挑选一个合适的时机将其写入磁盘。</li>
</ul>
<p>MySQL启动的时候，InnoDB会为 buffer pool中申请一片空闲空间，随着程序运行，磁盘上的页会逐渐放进这些空闲空间中。</p>
<p>当查询一条记录的时候，InnoDB是会把整个页的数据加载到buffer pool中，页加载后，再通过页中的 页目录 去定位到某条具体的记录。</p>
<h3 id="关于redo-log"><a href="#关于redo-log" class="headerlink" title="关于redo log:"></a>关于redo log:</h3><p>引入redo log，是因为<strong>buffer pool是基于内存</strong>的，在断电重启时，<strong>没来得及落盘的脏页数据会丢失</strong>。为了解决这个问题，<strong>当有一条记录需要修改的时候，InnoDB首先更新内存（标记为脏页），然后将本次对这个页的修改以 redo log的形式记录下来。</strong></p>
<p>随后，后台线程会在合适的时机将脏页写到磁盘中。</p>
<ul>
<li>redo log 是<strong>物理日志</strong>，记录了<strong>某个数据页做了什么修改</strong>，比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志。</li>
<li>事务提交时，只用<strong>先将redo log持久化到磁盘</strong>中就行，（内存中的脏页是在合适的时机进行落盘的）。<strong>哪怕系统崩溃发生内存掉电重启，根据磁盘中redo log中的记录进行恢复即可</strong>。</li>
</ul>
<h3 id="redo-log-和-undo-log的区别"><a href="#redo-log-和-undo-log的区别" class="headerlink" title="redo log 和 undo log的区别"></a>redo log 和 undo log的区别</h3><ul>
<li>这俩日志都是InnoDB引擎的日志；</li>
<li>redo log是重做日志，记录了此次事务完成后的状态，记录的是更新后的值；</li>
<li>undo log是回滚日志，记录了此次事务开始前的状态，记录的是更新前的值；</li>
<li>如果事务提交之前发生崩溃，会通过undo log回滚事务；如果事务提交之后发生崩溃，会通过redo log恢复事务。</li>
<li>redo log保证了持久性；而undo log保证了原子性；</li>
</ul>
<h3 id="bin-log与-redo-log的区别"><a href="#bin-log与-redo-log的区别" class="headerlink" title="bin log与 redo log的区别"></a>bin log与 redo log的区别</h3><ol>
<li><strong>适用对象不同：</strong></li>
</ol>
<ul>
<li>bin log是<strong>server层</strong>实现的日志，<strong>所有存储引擎都能用</strong>。</li>
<li>redo log和 undo log都是<strong>InnoDB引擎</strong>实现的日志。</li>
</ul>
<ol start="2">
<li><strong>文件格式不同：</strong></li>
</ol>
<ul>
<li>（<strong>记录逻辑操作</strong>）bin log 有3种格式类型，分别是<strong>statement(默认的格式)、row、mixed</strong>，区别如下：<ul>
<li>StateMent：每一条修改数据的sql都会记录到bin log中（相当于记下了逻辑操作，可以称为逻辑日志）。主从复制中 slave 根据sql语句重现。但是<strong>有动态函数的问题</strong>，比如UUID或now，在主库中执行的结果并不是从库中执行的结果。<strong>这会导致复制的数据不一致。</strong></li>
<li>Row： 记录行数据最终被变成什么样了，不会出现动态函数的问题。但它的<strong>缺点是每行数据的变化结果都会被记录</strong>，比如批量执行update , statement模式就只会记录一个update语句，而 row模式下，有多少次update 就产生多少update语句，使得binlog文件过大。</li>
<li>mixed: 包含了上面的 statement 和 row 模式，他会根据不同的情况自动使用row模式和statement模式。</li>
</ul>
</li>
<li><strong>redo log是物理日志</strong>，记录某个记录在某个数据页做了什么修改。</li>
</ul>
<ol start="3">
<li><strong>写入方式不同</strong>：</li>
</ol>
<ul>
<li><strong>bin log是追加写</strong>，写满一个文件就创建一个新的文件接着写，不会覆盖旧日志，<strong>保留的是全量日志</strong>；</li>
<li><strong>redo log是循环写</strong>，日志空间大小是固定的，全部写满就从头开始，保<strong>存未被刷入磁盘的脏页日志</strong>；</li>
</ul>
<ol start="4">
<li><strong>用途不同:</strong></li>
</ol>
<ul>
<li>bin log用于备份恢复，主从复制（一致性）；</li>
<li>redo log用于掉电等故障恢复 （持久性）；</li>
</ul>
<ol start="5">
<li><strong>写入时机不同</strong>：</li>
</ol>
<ul>
<li>bin log在<strong>事务提交之后</strong>才会被写入磁盘，因此可能会有一定的延迟；</li>
<li>redo log在<strong>事务提交之前</strong>就会被写入磁盘，确保了事务的持久性；</li>
</ul>
<p><strong>如果不小心把整个数据库的数据删除了，那么需要使用bin log来进行恢复，因为bin log保留了全量日志，这也是为什么redo log不行。</strong></p>
<h3 id="主从复制如何实现（依赖bin-log）："><a href="#主从复制如何实现（依赖bin-log）：" class="headerlink" title="主从复制如何实现（依赖bin log）："></a>主从复制如何实现（依赖bin log）：</h3><p>复制的过程就是将<strong>bin log中的数据从主库传输到从库上</strong>。这个过程一般是<strong>异步</strong>的。</p>
<p><strong>MySQL 集群的主从复制过程</strong>分为三个阶段：</p>
<ul>
<li><strong>写入 bin log</strong>： 主库写 bin log，提交事务，并更新本地存储的数据；</li>
<li><strong>同步 bin log</strong>：把bin log复制到所有从库上，每个从库把bin log写到relay log暂存日志中，返回给主库一个 复制成功 的响应；</li>
<li><strong>回放 bin log</strong>：回放 bin log，并更新存储引擎中的数据：从库创建一个用于回放 bin log的线程，去读relay log中继日志，然后回放bin log更新数据，最终实现主从的数据一致性。</li>
</ul>
<p><strong>主从复制模型</strong>：</p>
<ul>
<li>同步复制：很烂，主库要所有从库都完成复制才能返回客户端的结果，性能很差。</li>
<li><strong>异步复制</strong>：默认的模型，这种模式下，<strong>一旦主库发生宕机，数据就会发生丢失</strong>。</li>
<li><strong>半同步复制</strong>：5.7版本后增加的一种方式，事务线程不用等待所有从库复制成功响应，只<strong>要一部分复制成功响应回来就行。</strong>这种方式兼顾了同步复制和异步复制的有点，<strong>即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险。</strong></li>
</ul>
<h3 id="为什么需要进行两阶段提交？"><a href="#为什么需要进行两阶段提交？" class="headerlink" title="为什么需要进行两阶段提交？"></a>为什么需要进行两阶段提交？</h3><p>在<strong>持久化</strong>redo log和bin log这两份日志的时候，<strong>如果出现半成功的状态</strong>（两个log有一个持久化成功了，一个没成功），就<strong>会造成主从库内容的不一致性。</strong>这是因为<strong>redo log影响主库的内容，bin log影响从库的内容，所以redo log和bin log必须保持一致才能保证主从一致性。</strong></p>
<p><strong>半成功就是下面两种情况：</strong></p>
<ul>
<li><strong>redo log持久化成功了（事务成功提交了），但是bin log没有持久化成功</strong>：这导致主库恢复后根据redo log 有最新的数据，但是bin log会丢失更新，导致主从复制后，从库里保存的也不是最新的数据。</li>
<li><strong>bin log持久化成功了，但是redo log没有持久化成功（redo log没持久化成功，那么恢复时会认为该事务无效）</strong>：因为恢复后MySQL认为该事务失效，所以恢复后直接回滚，主库保留的还是旧值。但是bin log里有最新的数据，在主从复制后又会导致不一致问题。</li>
</ul>
<p><strong>&#x3D;&#x3D;两阶段提交的内容&#x3D;&#x3D;</strong></p>
<p>两阶段提交把单个事务的提交分为两个阶段： <strong>准备阶段（prepare）和 提交阶段（commit）</strong>阶段：</p>
<ul>
<li>在准备阶段，  协调者 询问两个 参与者（也就是这两个日志）有没有准备好。参与者 会做出应答，表示自己准备好了，或者没有准备好。</li>
<li>在提交阶段，如果都准备好了，那么协调者 就可以执行 两个日志的持久化过程；如果有任何一个参与者没有准备好，协调者会宣布事务失效，执行事务的回滚操作。</li>
</ul>
<p><strong>具体内容概括如下：</strong></p>
<ul>
<li><strong>准备阶段：将redo log对应的事务提交状态设置为prepare，然后将redo log刷新到硬盘；</strong></li>
<li><strong>提交阶段：将bin log刷新到磁盘，接着调用引擎的提交事务接口，将redo log状态设置为commit</strong>（将事务设置为commit状态后，把该状态刷入到磁盘 redo log文件）；</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/SHaDiaoYU/2023/10/23/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/test1/images/avatar.gif">
      <meta itemprop="name" content="jiawei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕鱼罐头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/test1/2023/10/23/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">刷题笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-10-23 14:44:21 / 修改时间：16:33:09" itemprop="dateCreated datePublished" datetime="2023-10-23T14:44:21+08:00">2023-10-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="java优先级队列-and-比较器"><a href="#java优先级队列-and-比较器" class="headerlink" title="java优先级队列 and 比较器"></a>java优先级队列 and 比较器</h3><p>(1) 比较器Comparator：</p>
<p>Comparator接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Comparator</span>&lt;T&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="title function_">compare</span><span class="params">(T o1, T o2)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类需要实现Comparator接口，它一定要实现compareTo(T o1,T o2) 函数，但可以不实现equals(Object object) 函数。</p>
<p>当第一个参数小于、等于、或大于第二个参数时，compareTo函数返回负值、零值或正值。</p>
<p>可以使用Lambda表达式实现匿名内部类的方法来定义比较器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;<span class="type">int</span>[]&gt; comparator = (arr1, arr2) -&gt; arr1[<span class="number">0</span>] - arr2[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<p>(2) 优先级队列PriorityQueue</p>
<p><strong>优先级队列默认使用小根堆，升序排列（1的优先级最高，234…优先级依次减少）。</strong></p>
<p>Java集合框架中提供了<strong>PriorityQueue</strong>和<strong>PriorityBlockingQueue</strong>两种类型的优先级队列，PriorityQueue是<strong>线程不安全</strong>的，PriorityBlockingQueue是<strong>线程安全</strong>的</p>
<p>PriorityQueue的几种常见构造方式：</p>
<ul>
<li>PriorityQueue() : 创建一个空的优先级队列，默认容量是11；</li>
<li>PriorityQueue(int initialCapacity) ：创建一个初始容量为initialCapacity的优先级队列，注意：值小于1会爆出IllegalArgumentException 异常；</li>
<li>PriorityQueue(Collection &lt;? extends E&gt; c)：用一个集合来创建优先级队列；</li>
<li>PriorityQueue(Comparator&lt;? super E&gt; comparator) ：创建具有初始容量的优先级队列，并根据指定的比较器对元素进行排序；</li>
</ul>
<p><strong>使用比较器comparator构造优先级队列priorityQueue:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((n1,n2) -&gt; n1-n2); <span class="comment">// 默认的顺序也是如此</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((n1,n2) -&gt; n2-n1); <span class="comment">// 降序排列（4优先级最高，321优先级依次降低）</span></span><br></pre></td></tr></table></figure>

<p>优先级内部依据比较器返回结果进行处理。</p>
<ul>
<li><p>在比较n1和n2的时候，如果结果大于0（n1-n2&gt;0）那么将n1下沉（大的数进行下沉，即小根堆的操作）；</p>
</li>
<li><p>当比较器返回值修改为n2-n1的时候，如果结果大于0（n2-n1&gt;0）,还是n1下沉（也就是说，无论n1大还是n2大，都会将n1下沉，但是现在这种情况相当于将小的数进行下沉，即大根堆的操作，此时应该是降序排列了）。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/SHaDiaoYU/2023/10/16/SpringCloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/test1/images/avatar.gif">
      <meta itemprop="name" content="jiawei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕鱼罐头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/test1/2023/10/16/SpringCloud%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">SpringCloud学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-16 15:27:59" itemprop="dateCreated datePublished" datetime="2023-10-16T15:27:59+08:00">2023-10-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-03 17:15:23" itemprop="dateModified" datetime="2024-04-03T17:15:23+08:00">2024-04-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-Feign与Gateway中的负载均衡："><a href="#1-Feign与Gateway中的负载均衡：" class="headerlink" title="1. Feign与Gateway中的负载均衡："></a>1. Feign与Gateway中的负载均衡：</h3><ul>
<li>Feign中的负载均衡是指微服务的实例和实例之间互相调用时进行负载均衡（内部）；</li>
<li>Gateway中的负载均衡是指对用户请求进行负载均衡（外部）；</li>
</ul>
<h3 id="2-Docker命令"><a href="#2-Docker命令" class="headerlink" title="2. Docker命令"></a>2. Docker命令</h3><h4 id="（1）Docker镜像命令："><a href="#（1）Docker镜像命令：" class="headerlink" title="（1）Docker镜像命令："></a>（1）Docker镜像命令：</h4><ul>
<li><p>查看镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o [outputFile] [imageName]</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [imageName]</span><br></pre></td></tr></table></figure>
</li>
<li><p>从文件加载镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i [xxx.tar(镜像文件)]</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（2）Docker容器命令："><a href="#（2）Docker容器命令：" class="headerlink" title="（2）Docker容器命令："></a>（2）Docker容器命令：</h4><ul>
<li><p>运行容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name [containerName] -p [80]:[80] -d [imageName]</span><br></pre></td></tr></table></figure>

<p>命令解读：</p>
<ul>
<li>docker run: 创建并运行一个容器；</li>
<li>–name: 给容器起一个名字；</li>
<li>-p: 将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口；</li>
<li>-d: 后台运行容器；</li>
<li>【imageName】: 镜像名称；</li>
</ul>
</li>
<li><p>暂停容器（运行态到暂停状态）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止暂停（暂停状态到运行状态）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause</span><br></pre></td></tr></table></figure>
</li>
<li><p>终止容器（运行态到终止态）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动容器（终止态到运行态）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入容器执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it [containerName] bash</span><br></pre></td></tr></table></figure>

<p>命令解读：</p>
<ul>
<li>docker exec：进入容器内部，执行一个命令；</li>
<li>-it：给当前进入的容器创建一个标准输入、输出终端，允许我们与容器进行交互；</li>
<li>mn：要进入的容器的名称；</li>
<li>bash：进入 容器后执行的命令，bash是一个linux终端的交互命令；</li>
</ul>
</li>
<li><p>查看容器运行日志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看所有运行的容器及状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除指定容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="（3）Docker数据卷命令"><a href="#（3）Docker数据卷命令" class="headerlink" title="（3）Docker数据卷命令"></a>（3）Docker数据卷命令</h4><ul>
<li><p>数据卷操作的基本语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume [COMMAND]</span><br></pre></td></tr></table></figure>

<p>docker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：</p>
<ul>
<li>create：创建一个volume;</li>
<li>inspect：显示一个或多个volume的信息；</li>
<li>ls：列出所有volume;</li>
<li>prune：删除未使用的volume;</li>
<li>rm：删除一个或多个指定的volume;</li>
</ul>
</li>
<li><p>例子：创建一个nginx容器，并挂载数据卷到容器内的html目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name myNginx -v html:/usr/share/nginx/html -p 80:80 -d nginx</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-Docker自定义镜像"><a href="#3-Docker自定义镜像" class="headerlink" title="3. Docker自定义镜像"></a>3. Docker自定义镜像</h3><h4 id="镜像结构："><a href="#镜像结构：" class="headerlink" title="镜像结构："></a>镜像结构：</h4><ul>
<li>镜像是将应用程序及其所需要的系统函数库、环境、配置、依赖打包而成。</li>
</ul>
<h4 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile:"></a>DockerFile:</h4><p>DockerFile就是一个文本文件，其中包含 一个个的<strong>指令（Instruction）</strong>，用指令说明要执行什么操作来构建镜像。每一个指令都会形成一层layer。</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20231021202201010.png" alt="image-20231021202201010"></p>
<p>根据dockerFile创建镜像</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t [repository:tag] [dockFilePath]</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t javaweb:1.0 ../dockerfile/</span><br></pre></td></tr></table></figure>

<ul>
<li>DockerFile的本质是一个文件，通过指令描述镜像的构建过程。</li>
<li>DockerFile的第一行必须是FROM，从一个基础镜像来构建</li>
<li>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如java8-alpine。</li>
</ul>
<h1 id="微服务架构特征"><a href="#微服务架构特征" class="headerlink" title="微服务架构特征"></a>微服务架构特征</h1><ul>
<li>单一职责：微服务拆分粒度更小，每个业务都对应唯一的业务能力，做到单一职责。</li>
<li>自治：团队独立，技术独立，数据独立，独立部署和交付。</li>
<li>面向服务：服务提供统一标准的接口，与语言和技术无关。</li>
<li>隔离性强：服务调用做好隔离，容错，降级、避免出现级联问题。</li>
</ul>
<h2 id="服务拆分原则"><a href="#服务拆分原则" class="headerlink" title="服务拆分原则"></a>服务拆分原则</h2><ul>
<li>不同微服务，不要重复开发相同的业务</li>
<li>微服务数据独立，不要访问其它微服务的数据库</li>
<li>微服务可以将自己的业务暴露为接口，供其他微服务调用</li>
</ul>
<h2 id="1-注册中心（Eureka，Nacos）"><a href="#1-注册中心（Eureka，Nacos）" class="headerlink" title="1. 注册中心（Eureka，Nacos）"></a>1. 注册中心（Eureka，Nacos）</h2><h3 id="1-1Eureka"><a href="#1-1Eureka" class="headerlink" title="1.1Eureka"></a>1.1Eureka</h3><ul>
<li><p>问题1：服务1如何得知服务2的实例地址（服务1 调用 服务2）？</p>
<p>获取地址信息的流程如下：</p>
<ul>
<li><strong>服务注册：</strong>服务2的服务实例启动后，会将自己的信息注册到 Eureka服务端 。这就叫做服务注册。</li>
<li><strong>服务端保存映射关系：</strong>Eureka服务端保存<code>服务名称</code>到<code>服务实例地址列表</code>的映射关系</li>
<li><strong>服务发现：</strong>服务1根据服务名称，拉取实力地址列表。这就叫做服务发现</li>
</ul>
</li>
<li><p>问题2：服务1如何从多个服务2的实例中选择一个具体的实例？</p>
<ul>
<li>服务1 从实力列表中，利用负载均衡算法，选择一个实例地址</li>
<li>向该实例地址发起远程调用</li>
</ul>
</li>
<li><p>服务1 如何得知某个 服务2实例是否仍然健康？是不是已经宕机？</p>
<ul>
<li>服务2（被调用方）会每隔一段时间（默认30秒），向Eureka服务端报告自己的状态，<strong>称为心跳</strong>。</li>
<li>超过一定时间没有发送心跳时，Eureka服务端会认为微服务实例故障，将该实例从服务列表中删除。</li>
<li>服务1（调用方）拉取服务时，就能将故障实例排除了。</li>
</ul>
</li>
<li><p><strong>注意，一个微服务，既可以是服务提供者，也可以是服务调用者，因此Eureka将服务注册，服务发现等功能统一封装到了Eurkea-client端</strong>。</p>
</li>
</ul>
<p>（1）具体实现（orderservice在8080，userservice有两个实例，分别部署在8081和8082）：</p>
<ol>
<li><p>服务发现、服务注册都封装在eureka-client依赖，因此两个service都要引入<code>eureka-client</code>依赖。</p>
</li>
<li><p><strong>服务注册：</strong>user service是服务提供者，我们需要在这个服务里面修改yaml，添加服务名称、eureka地址。</p>
<p>eureka.client.service-url 指定服务端的注册地址，这个是客户端使用的，告诉客户端服务的地址，它可以指定多个，有一个默认的defaultZone。</p>
<pre><code>  3.  **服务发现：**现在将orderService的逻辑修改，向eureka-server拉取user service的信息，实现服务发现。
</code></pre>
<ul>
<li><p>引入依赖，指定注册地址（就是前面的那个）</p>
</li>
<li><p>在orderservice 的主程序中，给restTemplate这个bean添加一个@LoadBanlanced注解。（这样就实现了负载均衡）。</p>
</li>
<li><p>修改orderservice服务中的orderservice类中的queryOrderById方法。修改访问的url路径，用服务名代替ip、端口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Order <span class="title function_">queryOrderById</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.查询订单</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.findById(orderId);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;http://userservice/user/&quot;</span> + order.getUserId();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> restTemplate.getForObject(url, User.class);</span><br><span class="line">        order.setUser(user);</span><br><span class="line">        <span class="comment">// 4.返回</span></span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p> spring 会自动帮助我们从eureka-server端，根据userservice这个服务名称，获取实力列表，而后完成负载均衡。</p>
<pre><code>  4.  **Ribbon负载均衡**
</code></pre>
<p> springCloud其实是使用了一个名为ribbon的组件，来实现负载均衡。</p>
<p> <img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240323202022271.png" alt="image-20240323202022271"></p>
<p> springCloudRibbon的底层采用了一个拦截器，拦截了restTemplate发出的请求，对地址做出了修改。</p>
<p> <img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240323202201453.png" alt="image-20240323202201453"></p>
<p> <strong>基本流程如下：</strong></p>
<ul>
<li>拦截rest Template请求<code>http://userservice/user/1</code></li>
<li>ribbonLoadBanlancerClient会从请求url中获取服务名称，即user service</li>
<li>DynamicServerListLoadBalander根据user service到eureka拉取服务列表。</li>
<li>eureka返回列表，user service拢共两个实例，那么就返回这两个实例的地址。</li>
<li>IRule利用内置负载均衡规则，从列表中挑选一个服务地址（假设是localhost:8081）。</li>
<li>RibbonLoadBalancer修改请求地址，用localhost:8081替代user service，得到<a target="_blank" rel="noopener" href="http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82">http://localhost:8081/user/1，发起真实请求</a></li>
</ul>
<p> <strong>Ribbon默认是采用懒加载，即第一次访问时才会去创建loadBalanceClient，请求时间会很长。</strong>而饥饿加载、会在项目启动时创建，降低第一次访问的耗时。通过下面的配置开启饥饿加载：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ribbon:</span><br><span class="line">  eager-load:</span><br><span class="line">    enabled: <span class="literal">true</span> # 开启饥饿加载</span><br><span class="line">    clients:</span><br><span class="line">      - userservice # 指定饥饿加载的服务名称</span><br><span class="line">      - xxxxservice # 如果需要指定多个，需要这么写</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-2-Nacos"><a href="#1-2-Nacos" class="headerlink" title="1.2 Nacos"></a>1.2 Nacos</h3><ol>
<li><p><strong>与eureka的联系：</strong>springCloudAlibaba也遵循spring Cloud中定义的服务注册、服务发现规范。因此使用Nacos和使用Eureka对于微服务来说，并没有太大区别。nacos跟eureka的主要区别在于（1）依赖不同（2）服务地址不同</p>
</li>
<li><p><strong>前期准备工作：</strong>安装nacos，<strong>nacos默认运行在8848端口</strong>。进入安装目录下的bin目录，执行<code>startup.cmd -m standalone</code>即可开启nacos服务。</p>
</li>
<li><p><strong>引入依赖：</strong></p>
<ul>
<li>在父工程的pom文件中引入spring Cloud Alibaba的依赖。</li>
<li>在两个服务userservice和orderService中的pom文件中引入nacos-discovery依赖。</li>
</ul>
</li>
<li><p><strong>配置nacos地址：</strong>在userservice和orderservice的application.yml中添加nacos地址如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重启微服务后，登录nacos管理页面，可以看到微服务信息。</strong></p>
</li>
<li><p><strong>服务分级存储模型：</strong></p>
<ul>
<li><p>一个服务可以有多个实例，假如这些实例分布于全国各地的不同机房，nacos就会将同一机房内的实例划分为一个<strong>集群</strong>。</p>
</li>
<li><p>也就是说，一个服务可以有多个集群，这些集群下面就是该服务的多个实例。</p>
</li>
<li><p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才会访问其他集群。</p>
</li>
</ul>
</li>
<li><p><strong>给user-service配置集群：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    nacos:</span><br><span class="line">      server-addr: localhost:<span class="number">8848</span></span><br><span class="line">      discovery:</span><br><span class="line">        cluster-name: HZ # 集群名称</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>同集群优先的负载均衡：</strong>默认的ZoneAvoidanceRule并不能</p>
</li>
</ol>
<h2 id="2-消息队列MQ（RabbitMQ-、SpringAMQP）"><a href="#2-消息队列MQ（RabbitMQ-、SpringAMQP）" class="headerlink" title="2. 消息队列MQ（RabbitMQ 、SpringAMQP）"></a>2. 消息队列MQ（RabbitMQ 、SpringAMQP）</h2><ul>
<li><p><strong>同步调用的问题（微服务间基于Feign的调用就属于同步方式，存在一些问题）：</strong></p>
<ul>
<li>（1）耦合导致改动很麻烦：每次加入新的需求，都要修改原来的代码；</li>
<li>（2）性能与吞吐量的下降：调用者需要等待服务提供者相应，如果调用链过长则响应时间等于调用的时间之和；</li>
<li>（3）产生了严重的资源浪费：调用链中的每个服务在等待响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源；</li>
<li>（4）级联失败：如果服务提供者出现问题，所有调用方都会跟着出问题；</li>
</ul>
</li>
<li><p><strong>异步调用方案：解决了上述的同步调用的问题。引入事件代理Broker，用户服务向broker发布事件，由broker进行通知。</strong></p>
<ul>
<li>另一个优势是，可以进行<strong>流量削峰</strong>，broker可以起到一个缓冲的作用，降低服务的压力。</li>
<li>总结来说，异步通信的优点在于（1）耦合度低（2）吞吐量提升（3）故障隔离（4）流量削峰；异步通信的缺点在于<strong>（1）依赖于Broker的可靠性，安全性以及吞吐能力（2）架构复杂了，业务没有明显的流程线，不好追踪管理</strong>。</li>
</ul>
</li>
<li><p><strong>各个MQ消息队列之间的对比：</strong></p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240326151804916.png" alt="image-20240326151804916"></p>
</li>
<li><p>RabbitMQ的broker工作流程：</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240326152825654.png" alt="image-20240326152825654"></p>
</li>
<li><p><strong>Rabbit中的几个概念：</strong></p>
<ul>
<li>channel：操作MQ的工具</li>
<li>exchange：路有消息到队列中</li>
<li>queue：缓存消息</li>
<li>virtual host：虚拟主机，是对queue、exchange等资源的逻辑分组。</li>
</ul>
</li>
<li><p><strong>RabbitMQ常见消息模型：</strong></p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240326153454835.png" alt="image-20240326153454835"></p>
</li>
</ul>
<h3 id="2-1-springAMQP"><a href="#2-1-springAMQP" class="headerlink" title="2.1 springAMQP"></a>2.1 springAMQP</h3><ul>
<li><p>AMQP是应用间消息通信的一种协议，与语言和平台无关。</p>
</li>
<li><p>springAMQP是基于AMQP协议定义的一套API规范，提供了模板来发送和接收消息。包含两部分，其中spring-amqp是基础抽象，spring-rabbit是底层的默认实现。</p>
</li>
<li><p><strong>利用SpringAMQP实现helloworld中的基础消息队列功能</strong></p>
<ul>
<li><p>流程如下：</p>
<ul>
<li>1.在父工程中引入spring-ampq的依赖。</li>
<li>2.在publisher服务中利用<strong>RabbitTemplate</strong>发送消息到simple.queue这个队列。</li>
<li>3.在consumer服务中编写消费逻辑，绑定simple.queue这个队列。</li>
</ul>
</li>
<li><p>首先，配置publisher和consumer的application.yaml:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.1</span>.设置连接参数，分别是：主机名、端口号、用户名、密码、vhost</span><br><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    host: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    port: <span class="number">5672</span></span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    virtual-host: /</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后编写测试类springAmqpTest用于实现消息发送:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testSendMessage2SimpleQueue</span> <span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    rabbitTemplate.convertAndSend (queueName,message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在consumer中新建一个类,来实现消息的接收：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringRabbitListener</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenSimpleQueueMessage</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;spring消费者接收到消息：&quot;</span> + meg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结，SpringAMQP如何接收消息：</strong></p>
<ul>
<li>引入amqp的starter依赖</li>
<li>配置RabbitMQ地址</li>
<li>定义类，添加@Component注解</li>
<li>类中声明方法 ，添加@RabbitListener注解，方法参数就是消息。</li>
</ul>
<p>注意，消息一旦消费就会从队列中删除，rabbitMQ没有消息回溯功能。</p>
</li>
</ul>
</li>
<li><p><strong>SpringAMQP消息预取机制</strong></p>
<ul>
<li>预取机制就是，当消息进入到消息队列的时候，消费者不管自己的消费能力有多少，轮流预取队列中的消息，随后进行消费，这会导致低消费能力的consumer也有可能处理很多的消息。</li>
<li><strong>解决办法：</strong>修改application.yaml文件，设置<code>spring-rabbitmq-listener-simple-prefetch</code>属性，可以控制预取消息的上限。</li>
</ul>
</li>
<li><p><strong>发布订阅模型：</strong>发布订阅模式与之前的区别就在于允许将同一消息发送给多个消费者，实现方式是加入了exchange（交换机）（也就是说，同一个消息可以被多个消费者消费）</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20240326170444055.png" alt="image-20240326170444055"></p>
</li>
<li><p><strong>FanoutExchange</strong></p>
<ul>
<li>交换机的作用是什么？<ul>
<li>接收publisher发送的消息</li>
<li>将消息按照规则路由到与之绑定的队列（fanout是广播，会路由到所有队列）</li>
<li>不能缓存消息，路由失败，消息会丢失</li>
<li>FanoutExchange会将消息路由到每个绑定的队列</li>
</ul>
</li>
<li>声明队列、交换机、绑定关系的Bean是什么？<ul>
<li>Queue</li>
<li>FanoutExchange</li>
<li>Binding</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>DirectExhange:</strong> 其会将接收到的消息根据路由规则路由到指定的Queue，因此称为路由模式（router）</p>
<ul>
<li>每一个Queue都与Exchange设置一个BindingKey</li>
<li>发布者发布消息时，指定消息的RoutingKey</li>
<li>Exchange将消息路由到BindingKey与消息RoutingKey一致的队列</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/SHaDiaoYU/2023/10/09/JUC%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/test1/images/avatar.gif">
      <meta itemprop="name" content="jiawei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕鱼罐头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/test1/2023/10/09/JUC%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">JUC学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-10-09 19:48:37 / 修改时间：19:52:56" itemprop="dateCreated datePublished" datetime="2023-10-09T19:48:37+08:00">2023-10-09</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-Synchroize的使用"><a href="#1-Synchroize的使用" class="headerlink" title="1. Synchroize的使用"></a>1. Synchroize的使用</h3><ul>
<li>synchronized在方法上使用时，锁住的是this对象；</li>
<li>synchronized在<strong>静态</strong>方法上使用时，锁住的是当前类；</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/SHaDiaoYU/2023/06/30/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/test1/images/avatar.gif">
      <meta itemprop="name" content="jiawei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕鱼罐头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/test1/2023/06/30/Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Java动态代理知识学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-30 15:30:10 / 修改时间：16:01:00" itemprop="dateCreated datePublished" datetime="2023-06-30T15:30:10+08:00">2023-06-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><h4 id="程序为什么需要代理？代理长什么样？"><a href="#程序为什么需要代理？代理长什么样？" class="headerlink" title="程序为什么需要代理？代理长什么样？"></a>程序为什么需要代理？代理长什么样？</h4><ul>
<li>对象如果嫌自己身上干的事情太多的话，可以通过代理来转移部分职责。</li>
<li>对象有什么方法想被代理，代理就一定要有对应的方法。</li>
<li>中介通过实现接口来知道使用哪个样子的代理。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/SHaDiaoYU/2023/06/06/SpringBoot%E5%AD%A6%E4%B9%A0-%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/test1/images/avatar.gif">
      <meta itemprop="name" content="jiawei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕鱼罐头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/test1/2023/06/06/SpringBoot%E5%AD%A6%E4%B9%A0-%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/" class="post-title-link" itemprop="url">SpringBoot学习-缓存相关内容</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-06 15:26:57" itemprop="dateCreated datePublished" datetime="2023-06-06T15:26:57+08:00">2023-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-13 15:21:48" itemprop="dateModified" datetime="2023-06-13T15:21:48+08:00">2023-06-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-SpringBoot缓存技术"><a href="#1-SpringBoot缓存技术" class="headerlink" title="1.SpringBoot缓存技术"></a>1.SpringBoot缓存技术</h4><ul>
<li><p>springboot提供了缓存技术，方便缓存使用。</p>
<ul>
<li>导入坐标：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在启动类中添加<code>@EnableCaching</code>注解，开启缓存功能。</p>
</li>
<li><p>在涉及查询的方法上添加<code>@Cachable(value=缓存空间名称,key=#变量名)</code>，表明该方法返回的结果会放入该名称的缓存空间下。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cachable(value=&quot;cacheSpace&quot;,key=&quot;#id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bookMapper.selectById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>springboot提供的缓存技术除了提供默认的缓存方案，还可以与其他缓存技术进行整合，统一接口，方便缓存技术的开发与管理。</p>
<ul>
<li>这些缓存技术包括 simple(默认)、Generic、Jcache、<strong>Ehcache</strong>、Hazelcast、Infinispan、Couchbase、<strong>Redis</strong>、Caffenine。</li>
<li>也有未被springboot整合的缓存技术：常用的是<strong>memcached</strong>。</li>
</ul>
</li>
</ul>
<h4 id="2-缓存使用案例–手机验证码"><a href="#2-缓存使用案例–手机验证码" class="headerlink" title="2.缓存使用案例–手机验证码"></a>2.缓存使用案例–手机验证码</h4><ul>
<li><p>需求：</p>
<ul>
<li>输入手机号获取验证码，组织文档以短信形式发送给用户（页面模拟）</li>
<li>输入手机号和验证码验证结果。</li>
</ul>
</li>
<li><p>需求分析：</p>
<ul>
<li>提供controller，传入手机号，业务层通过手机号计算出独有的6位验证码数据，存入缓存后返回此数据；</li>
<li>提供controller，传入手机号与验证码，业务层通过手机号从缓存中读取验证码并与输入验证码进行比对，返回比对结果；</li>
</ul>
</li>
<li><p>具体实现示例：</p>
<ul>
<li><p>第一步：创建bean，名为 SMSCode:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SMSCode</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String tele; <span class="comment">// 电话号码</span></span><br><span class="line">    <span class="keyword">private</span> String code; <span class="comment">// 验证码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步，创建用于生成验证码的工具类CodeUtils:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于补0的数组</span></span><br><span class="line">    <span class="keyword">private</span> String[] patch = &#123;<span class="string">&quot;000000&quot;</span>,<span class="string">&quot;00000&quot;</span>,<span class="string">&quot;0000&quot;</span>,<span class="string">&quot;000&quot;</span>,<span class="string">&quot;00&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据电话号码生成验证码</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">generator</span><span class="params">(String tele)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> tele.hashCode();</span><br><span class="line">        <span class="comment">// 设置加密码</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">encryption</span> <span class="operator">=</span> <span class="number">20206666</span>;</span><br><span class="line">        <span class="comment">// 与hashcode进行异或以完成加密</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> hash ^ encryption;</span><br><span class="line">        <span class="comment">// 为使验证码不唯一，获取系统当前时间，并与其再次进行异或</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">nowTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        result = nowTime ^ result;</span><br><span class="line">        <span class="comment">// 获取后六位即可</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">code</span> <span class="operator">=</span> result % <span class="number">1000000</span>;</span><br><span class="line">        <span class="comment">// 解决code值可能为负的问题</span></span><br><span class="line">        code = code &lt; <span class="number">0</span> ? -code:code;</span><br><span class="line">        <span class="type">String</span> <span class="variable">codeStr</span> <span class="operator">=</span> code + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> codeStr.length();</span><br><span class="line">        <span class="keyword">return</span>  patch[length] + codeStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Cacheable(value = &quot;smsCode&quot;, key = &quot;#tele&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCodeFromCache</span><span class="params">(String tele)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里把getCodeFromCache方法放在这个工具类之中的原因，是我们需要使用springboot容器统一管理，如果放在service下，@Cacheable注解将会失效，原因是其未被加载至springboot容器内。</p>
</li>
<li><p>第三步，新建业务层接口SMSCodeService及其实现类SMSCodeServiceImpl</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SMSCodeService</span> &#123;</span><br><span class="line">    <span class="comment">// 向手机发送验证码</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendCodeToSMS</span><span class="params">(String tele)</span>;</span><br><span class="line">    <span class="comment">// 校验验证码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(SMSCode code)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SMSCodeServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SMSCodeService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CodeUtils codeUtils;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 只用往缓存内存放验证码以供校验使用，使用下列注解</span></span><br><span class="line">    <span class="meta">@CachePut(value = &quot;smsCode&quot;,key = &quot;#tele&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendCodeToSMS</span><span class="params">(String tele)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> codeUtils.generator(tele);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(SMSCode smsCode)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> smsCode.getCode();</span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> codeUtils.getCodeFromCache(smsCode.getTele());</span><br><span class="line">        <span class="keyword">return</span> code.equals(cacheCode);</span><br><span class="line">       <span class="comment">// return false;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第四步，编写控制层SMSCodeController类用以测试：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/sms&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SMSCodeController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SMSCodeService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCode</span><span class="params">(String tele)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> service.sendCodeToSMS(tele);</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkCode</span><span class="params">(SMSCode smsCode)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> service.check(smsCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成这些步骤后，在postman中进行测试即可。</p>
</li>
</ul>
<h4 id="3-jetcache缓存方案"><a href="#3-jetcache缓存方案" class="headerlink" title="3. jetcache缓存方案"></a>3. jetcache缓存方案</h4><p>jetcache缓存方案包括 远程缓存方案 和 本地缓存方案 两种。</p>
<p><strong>（1）jetcache远程缓存方案：</strong></p>
<ul>
<li>首先，在pom文件中添加jetcache的坐标。然后，在application.yml中配置jetcache远程方案默认类型为redis，设置主机地址，端口（注意，poolconfig这一项必须配置，至少配置一条，否则初始化的时候会报错。）:</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alicp.jetcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jetcache-starter-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jetcache:</span></span><br><span class="line">  <span class="attr">remote:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.153</span><span class="number">.137</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">poolconfig:</span></span><br><span class="line">        <span class="attr">maxTotal:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第二步，在启动类中添加<code>@EnableCreateCacheAnnotation</code>注解，这个注解是jetcache启动缓存的主开关。</li>
<li>定义Cache&lt;K,V&gt;对象，并添加注解@CreateCache，告诉jetcache这是用于进行缓存的对象。name属性定义缓存空间名称，expire属性定义存活时间（默认单位为秒）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CreateCache(name = &quot;smsCache&quot;,expire = 3600)</span></span><br><span class="line">   <span class="keyword">private</span> Cache&lt;String,String &gt; jetCache;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用put和get方法即可进行缓存存取值：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">sendCodeToSMS</span><span class="params">(String tele)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> codeUtils.generator(tele);</span><br><span class="line">      jetCache.put(tele,code);</span><br><span class="line">      <span class="keyword">return</span> code;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(SMSCode smsCode)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> smsCode.getCode();</span><br><span class="line">      <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> jetCache.get(smsCode.getTele());</span><br><span class="line">        <span class="keyword">return</span> code.equals(cacheCode);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20230609143218491.png" alt="image-20230609143218491"></p>
<ul>
<li>在redis客户端进行查看，可以看到新添加的缓存。可以看到我们设置的name跟key连到一块了。所以在设置name时最好在后面加上分隔符，比如“smsCode_”，这样可以更好地做区分。</li>
</ul>
<p><strong>（2）jetcache本地缓存方案</strong></p>
<ul>
<li>首先，添加jetcache本地缓存配置：</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jetcache:</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">linkedhashmap</span></span><br><span class="line">      <span class="attr">keyConverter:</span> <span class="string">fastjson</span></span><br></pre></td></tr></table></figure>

<ul>
<li>然后，设置缓存类型为local（其中有三种类型可选，BOTH代表本地和远程同时缓存；LOCAL代表使用本地缓存；REMOTE代表使用远程缓存）</li>
</ul>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20230609154601714.png" alt="image-20230609154601714"></p>
<p><strong>（3）jetcache方法缓存</strong></p>
<p>这里的方法缓存是指在方法上添加注解使其具有缓存的功能，具体流程如下：</p>
<ul>
<li><p>首先，在启动类上添加<code>@EnableMehodCache</code>注解，并配置路径，使用缓存的类必须存在该路径内。同时，该注解必须与@EnableCacheAnnotation 注解配合使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// jetcache启用缓存的主开关</span></span><br><span class="line"><span class="meta">@EnableCreateCacheAnnotation</span></span><br><span class="line"><span class="comment">// 启用方法缓存</span></span><br><span class="line"><span class="meta">@EnableMethodCache(basePackages = &quot;com.jiawei.boot&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BootApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(BootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步，在方法上添加<code>@Cached</code>注解，指明缓存空间名称，关键字，存放时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cached(name=&quot;book_&quot;,key=&quot;#id&quot;,expire = 3600)</span></span><br><span class="line"><span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> bookMapper.selectById(id);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这之后运行会报一个空指针的异常，这个异常是由于默认使用的方案，而我们没有配置keyConverter引起的。添加该项配置即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jetcache:</span></span><br><span class="line">  <span class="attr">remote:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.153</span><span class="number">.137</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">keyConverter:</span> <span class="string">fastjson</span></span><br><span class="line">      <span class="attr">poolconfig:</span></span><br><span class="line">        <span class="attr">maxTotal:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再然后，会爆出一个未序列化的异常，这个异常是由于redis没有存储对象的功能，所以我们需要进行序列化对象进行存储。添加Book对象的序列化配置过程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置中添加：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jetcache:</span></span><br><span class="line">  <span class="attr">remote:</span></span><br><span class="line">    <span class="attr">default:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">redis</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.153</span><span class="number">.137</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">keyConverter:</span> <span class="string">fastjson</span></span><br><span class="line">      <span class="attr">valueEncode:</span> <span class="string">java</span></span><br><span class="line">      <span class="attr">valueDecode:</span> <span class="string">java</span></span><br><span class="line">      <span class="attr">poolconfig:</span></span><br><span class="line">        <span class="attr">maxTotal:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>至此问题解决，但是也存在着当数据库进行更新以及删除操作时，缓存的数据需要进行同步的问题，我们为更新和删除操作添加注解，每当进行更新或删除操作时就更新缓存内容：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新方法</span></span><br><span class="line"><span class="meta">@CacheUpdate(name=&quot;book_&quot;,key=&quot;#book.id&quot;,value=&quot;#book&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bookMapper.update(book)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除方法</span></span><br><span class="line"><span class="meta">@CacheInvalidate(name=&quot;book_&quot;,key=&quot;#id&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteBook</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bookMapper.deleteById(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设定缓存刷新（单位为秒）使用<code>@CacheRefresh（refresh = 5）</code>注解，此操作请谨慎使用。</li>
</ul>
<h4 id="4-J2cache缓存框架"><a href="#4-J2cache缓存框架" class="headerlink" title="4. J2cache缓存框架"></a>4. J2cache缓存框架</h4><p><strong>（1）整合ehcache:</strong></p>
<ul>
<li><p>第一步，导入j2cache、ehcache依赖，注意j2cache需要导入两处依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.oschina.j2cache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>j2cache-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0-release<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.oschina.j2cache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>j2cache-spring-boot2-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5-release<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步，application.yml中添加配置，指定j2cache配置文件路径：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">j2cache:</span></span><br><span class="line">  <span class="attr">config-location:</span> <span class="string">j2cache.properties</span></span><br></pre></td></tr></table></figure>

<p>添加ehcache的配置文件ehcache.xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;http://ehcache.org/ehcache.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">updateCheck</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;60&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;60&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建j2cache.properties配置文件，这里我们配置一级缓存(ehcache)和二级缓存(redis)，配置内容如下：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1级缓存</span></span><br><span class="line"><span class="attr">j2cache.L1.provider_class</span> = <span class="string">ehcache</span></span><br><span class="line"><span class="attr">ehcache.configXml</span> = <span class="string">ehcache.xml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 2级缓存</span></span><br><span class="line"><span class="attr">j2cache.L2.provider_class</span> =<span class="string">net.oschina.j2cache.cache.support.redis.SpringRedisProvider</span></span><br><span class="line"><span class="attr">j2cache.L2.config_section</span> = <span class="string">redis</span></span><br><span class="line"><span class="attr">redis.hosts</span> = <span class="string">192.168.153.127:6379</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 1级缓存中的数据如何到达2及缓存</span></span><br><span class="line"><span class="attr">j2cache.broadcast</span> = <span class="string">net.oschina.j2cache.cache.support.redis.SpringRedisPubSubPolicy</span></span><br></pre></td></tr></table></figure>

<p>SpringRedisProvider的位置，（SpringRedisPubSubPolicy在同一级）：</p>
<img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20230613144723962.png" alt="image-20230613144723962" style="zoom:67%;" />
</li>
<li><p>使用：创建CacheChannel对象，进行set和get：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SMSCodeServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">SMSCodeService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CodeUtils codeUtils;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CacheChannel cacheChannel;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sendCodeToSMS</span><span class="params">(String tele)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> codeUtils.generator(tele);</span><br><span class="line">        cacheChannel.set(<span class="string">&quot;sms&quot;</span>,tele,code);</span><br><span class="line">        <span class="comment">//jetCache.put(tele,code);</span></span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(SMSCode smsCode)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> smsCode.getCode();</span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheCode</span> <span class="operator">=</span> cacheChannel.get(<span class="string">&quot;sms&quot;</span>,smsCode.getTele()).asString();</span><br><span class="line">          <span class="keyword">return</span> code.equals(cacheCode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gitee.com/SHaDiaoYU/2023/06/01/SpringBoot%E5%AD%A6%E4%B9%A0-ES%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/test1/images/avatar.gif">
      <meta itemprop="name" content="jiawei">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="沙雕鱼罐头">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/test1/2023/06/01/SpringBoot%E5%AD%A6%E4%B9%A0-ES%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9/" class="post-title-link" itemprop="url">SpringBoot学习-ES相关内容</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-01 16:20:57" itemprop="dateCreated datePublished" datetime="2023-06-01T16:20:57+08:00">2023-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-04 16:31:47" itemprop="dateModified" datetime="2023-06-04T16:31:47+08:00">2023-06-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="1-ES-索引操作"><a href="#1-ES-索引操作" class="headerlink" title="1. ES 索引操作"></a>1. ES 索引操作</h4><p>使用方式：发送restful的web请求即可使用。假设我们要创建一个索引名为books:</p>
<ul>
<li><p><strong>创建索引：</strong>通过发送PUT请求<code>http://localhost:9200/books</code>完成，返回结果如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;acknowledged&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;shards_acknowledged&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;books&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意，索引值唯一，如果重复创建，es会报错。</p>
</li>
<li><p><strong>查询索引：</strong> 通过发送GET请求<code>http://localhost:9200/books</code>完成。返回该索引的各种信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;books&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;aliases&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;routing&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;allocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;_tier_preference&quot;</span><span class="punctuation">:</span> <span class="string">&quot;data_content&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;number_of_shards&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;provided_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;books&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;creation_date&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1685608096323&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;number_of_replicas&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;uuid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;uD2KU8OFRS2CvCj39kBCyg&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8080099&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除索引：</strong>通过发送DELETE请求<code>http://localhost:9200/books</code>完成。返回结果：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;acknowledged&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用分词器：</strong></p>
<ul>
<li><p>使用ik分词器：将其解压到elasticsearch的plugins目录下即可使用（注意版本匹配。）</p>
</li>
<li><p>重启elasticsearch，如果出现下列内容则说明ik分词器安装成功：</p>
<p><img src="https://jiawei-blog-pictures.oss-cn-beijing.aliyuncs.com/blog_pictures/image-20230602193459847.png" alt="image-20230602193459847"></p>
</li>
<li><p>创建索引并指定规则：添加请求体，postman上方式为Body-&gt;raw-JSON。为每个字段添加规则。注意，为了实现既对name字段查询，又对的description字段查询，引入了一个新的字段all，并为name以及description字段添加属性<code>&quot;copy_to&quot;:&quot;all&quot;</code>以实现该效果。</p>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span><span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span><span class="string">&quot;all&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;text&quot;</span><span class="punctuation">,</span><span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span><span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span><span class="attr">&quot;copy_to&quot;</span><span class="punctuation">:</span><span class="string">&quot;all&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;text&quot;</span><span class="punctuation">,</span><span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span><span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;all&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;text&quot;</span><span class="punctuation">,</span><span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span><span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-ES文档操作"><a href="#2-ES文档操作" class="headerlink" title="2. ES文档操作"></a>2. ES文档操作</h4><p>es的文档是无模式的。</p>
<ul>
<li><p><strong>创建文档（请求方式为post）</strong></p>
<ul>
<li>方式1：请求地址为<code>http://localhost:9200/books/_doc</code>，这种方式使用的是系统生成的id。</li>
<li>方式2：请求地址为<code>http://localhost:9200/books/_create/1</code>，这种方式使用的是指定的id（此处指定id为1）。</li>
<li>方式3：请求地址为<code>http://localhost:9200/books/_doc/1</code>，这种方式使用指定的id，id不存在则创建，存在则更新。</li>
</ul>
<p>请求体格式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;springboot&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;springboot&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;springboot&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查询文档（请求方式为get）</strong></p>
<ul>
<li>方式1：请求地址为<code>http://localhost:9200/books/_doc/1</code>，查询指定id（此处为1）的文档。</li>
<li>方式2：请求地址为<code>http://localhost:9200/books/_search</code>，查询全部的文档。</li>
</ul>
</li>
<li><p><strong>条件查询（请求方式为get）</strong></p>
<ul>
<li>请求地址为<code>http://localhost:9200/books/_search?q=name:springboot</code></li>
</ul>
</li>
<li><p><strong>删除文档（请求方式为delete）</strong></p>
<ul>
<li>请求地址为<code>http://localhost:9200/books/_doc/1</code>，删除指定id（此处为1）的文档</li>
</ul>
</li>
<li><p><strong>修改文档（全量修改，请求方式为put）</strong></p>
<ul>
<li>请求地址为<code>http://localhost:9200/books/_doc/1</code></li>
<li>请求体格式：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;springboot good&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span><span class="string">&quot;springboot&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span><span class="string">&quot;springboot&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修改文档（部分修改，请求方式为post）</strong></p>
<ul>
<li>请求地址为<code>http://localhost:9200/books/_update/1</code></li>
<li>请求体格式：</li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;springboot&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意部分修改与全量修改的请求地址之间的区别。</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/test1/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/test1/page/4/">4</a><a class="extend next" rel="next" href="/test1/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">jiawei</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/test1/archives/">
        
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jiawei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/test1/lib/anime.min.js"></script>
  <script src="/test1/lib/velocity/velocity.min.js"></script>
  <script src="/test1/lib/velocity/velocity.ui.min.js"></script>

<script src="/test1/js/utils.js"></script>

<script src="/test1/js/motion.js"></script>


<script src="/test1/js/schemes/pisces.js"></script>


<script src="/test1/js/next-boot.js"></script>




  















  

  

</body>
</html>
